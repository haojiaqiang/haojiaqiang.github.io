{"meta":{"title":"Hayato's Studio","subtitle":null,"description":null,"author":"Hayato","url":"https://haojiaqiang.github.io"},"pages":[],"posts":[{"title":"网游加速器原理、技术与实现","slug":"网游加速器原理","date":"2020-11-19T08:26:47.000Z","updated":"2020-11-19T08:50:27.989Z","comments":true,"path":"2020/11/19/网游加速器原理/","link":"","permalink":"https://haojiaqiang.github.io/2020/11/19/网游加速器原理/","excerpt":"","text":"(http://blog.csdn.net/kidwei/article/details/8559842)) 1. 前言网游加速器是针对个人用户快速连接网游服务器的一种服务。为了解决国内南北网络互联瓶颈的问题，“网络加速器”厂商通过搭建多个高带宽的双线机房(或通过租用双线VPS主机），并在这些机房的两大线路中架设多个节点服务器，然后为其编写“网络加速器客户端”，通过客户端判断用户的网络线路类型，并将用户应用客户端的网络数据转发到指定的节点服务器，由节点服务器转发给用户应用客户端请求的真正服务器。“网络加速器客户端”通过自动选择速度最快的节点服务器进行数据转发，以达到数据加速作用。优秀的网络加速器可以有效减少网络丢包和网络延迟。 本文基于前期对各种加速器的分析以及对其中的关键技术进行试验。文章首先对互联网上流行的网游加速器分析结果进行简要汇总，然后针对各种不同的加速器实现方式进行详细实现细节的介绍。 2. 流行加速器分析本文前期对目前流行的网游加速器（或网络加速器）客户端进行了一定的深度分析，了解了这些网络加速器的使用特点、应用领域以及所采用的关键技术。目前网络上流行的网络加速器主要有：迅游加速器、迅雷网游加速器、盛大ET加速器、LavaVPN、NetPas等。 迅游加速器（http://www.xunyou.com）和迅雷网络加速器迅游版（http://jaisuqi.xunlei.com）是专门针对网游的加速器。迅雷共有两款加速器，自研的“给力加速器”提供免费加速服务，“迅游版加速器”是与迅游合作的产品。它们在软件UI设计和功能大致相同，使用流程也如出一辙：启动加速功能前需要选择指定的游戏及其区服，注意：待加速游戏必须是其客户端列表中指定的游戏，对于未指定的游戏不能被加速。 启动加速后加速客户端对其全部节点服务器进行测速（迅游加速器部署了82个节点服务器），然后选择速度最快的服务器作为转发服务器，并在本地建立IP地址以172开头的虚拟网卡（局域网地址）。启动后通过抓包工具分析，所有发送到该游戏服务器的数据都是从该172开头的虚拟网卡地址发出的（VPN技术？），而不是从物理网卡地址发出。通过查看路由表，被加速的游戏当前所使用的服务器被增加到了路由表中，并指向了该172开头的虚拟网卡地址。 在对迅游加速器分析过程中还发现，迅游加速器在加速过程中使用了LSP技术（一种通过在TCP/IP协议上层安装一层用户自定义协议，可以对WinSock2 API进行拦截的技术），并对WSAConnnect函数进行了拦截。 迅雷给力加速器也提供了四种加速模式，模式一采用的是基于LSP的代理加速方式，通过LSP技术，将用户的网络数据直接转发给代理服务器，再由代理服务器将数据转发给真正的游戏服务器；模式二采用的是基于L2TP协议的VPN技术；模式三采用的是基于PPTP协议的VPN技术；模式四采用的是基于基于OpenVPN的VPN技术。这三种模式在启动加速后都需要修改路由表，以实现针对指定目的IP的加速功能。 VPN顾名思义，虚拟专网，你接入VPN就是接入了一个专有网络，那么你访问网络都是从这个专有网络的出口出去，好比你在家，你家路由器后面的网络设备是在同一个网络，而VPN则是让你的设备进入了另一个网络。同时你的IP地址也变成了由VPN分配的一个IP地址。通常是一个私网地址。你和VPN服务器之间的通信是否加密取决于连接VPN的具体方式/协议。代理服务器则是把你的网络数据请求通过一条连接你和代理服务器之间的通道，由服务器转发到目的地。你没有加入任何新的网络，只是http/socks数据经过代理服务器的转发送出，并从代理服务器接收回应。你与代理服务器通信过程不会被额外处理，如果你用https，那本身就是加密的。 LavaVPN（http://www.lavajsq.com，已经改名为LavaJSQ）是一款可以针对所有网络应用进行加速的网络加速器。它采用了VPN技术对网络进行加速，并提供四种VPN协议模型进行加速：PPTP、L2TP、OpenVPN（SSL_TCP）、OpenVPN（SSL_UDP），并可以通过增删路由表的形式，针对不同的应用进行加速：仅加速国外访问、仅加速对网通（电信）的网络访问、仅加速某些进程的网络访问等等。 对LavaVPN的分析过程中未发现其有使用到LSP技术的迹象。 盛大ET加速器（http://etspeed.sdo.com）是一款可以针对网络游戏加速以及语音加速的工具。ET加速器在结构设计上与迅游加速器有明显区别，但是功能类似：仅支持对其游戏列表中的游戏加速、启动加速功能后在本机建立了虚拟网卡，并添加了指向虚拟网卡地址的路由、在本机安装了LSP协议。ET加速器启动加速后，在“我的连接”面板里新增出现了一个名为“etaaaaaa”的网络连接。 3. 加速器实现方式概要通过对以上加速器的分析进行参考，并查阅相关资料，目前主流的加速技术可以采用两种方式来实现：“代理服务器方式”和“VPN方式”。 代理服务器方式通过部署SOCKS5代理服务器作为加速节点，加速客户端自动选择最快的代理服务器作为当前的转发节点。在客户端主要采用LSP技术，在用户的主机安装分层协议，在游戏客户端调用connect函数（或WSAConnect函数）试图连接游戏服务器时，将连接重定向到代理服务器，并采用SOCKS5协议规范与代理服务器进行数据协商，由代理服务器来连接真正的游戏服务器，并将游戏服务器的数据原封不动转发给用户、将用户的数据原封不动转发给游戏服务器。 VPN方式需要部署双线VPN服务器作为加速节点，加速客户端自动选择速度最快的VPN服务器，并通过VPN拨号连接到VPN服务器并获取一个虚拟IP地址，同时通过修改路由表的方式，将指定进程的网络访问路由到虚拟IP上，而其余地址仍经过原默认路由途径访问。 下面就这两种加速方式的具体实现以及重要的技术难点进行详细分析。另外，报告中的所有代码截图均来自之前写的测试程序，并测试通过；VPN加速方式由主要进行了原理的详细介绍，并编写了支持PPTP协议的VPN客户端和服务器进行了测试。 4. VPN加速方式4.1. VPN加速概述VPN技术常常被广泛应用于“网游加速技术”和“翻墙技术”中。如前面提到的迅游加速器、迅雷网游加速器、LavaVPN都采用到了VPN技术进行加速，而且目前主流的网游加速器都主要是采用的VPN技术。由于VPN环境的测试需要建立VPN服务器，本人的测试环境有限，所以只是进行了客户端的代码编写并连接通过，无法做相关的代理效果的测试。下面只针对实现的流程和原理给以介绍。 4.2. VPN加速实现步骤通过建立如下步骤，可以采用VPN技术来实现网络加速： 部署双线VPN服务器节点； 加速器客户端启动后选择网络性能最好的VPN服务器，并在客户端进行RAS拨号，与该VPN服务器建立隧道连接，连接建立后将会自动在本机生成一个虚拟网络地址，同时客户端的默认路由会被修改成指向该虚拟网络地址，如果此时不进行特殊处理，客户端的所有网络访问将都会通过该VPN通道出去； 因为网游加速器的功能需求是仅仅针对某款游戏进行加速，即：在知道这款游戏连接的服务器IP的前提下，只有发送到该服务器IP的数据才被加速，其他网络数据应该不受影响。因此加速客户端在建立完VPN通道以后，需要立即修改路由表：在拨号前通过修改拨号参数，使其不修改本机的默认路由表；其次，将游戏服务器IP增加到路由表中，并让其指向VPN拨号建立的虚拟网络地址上。这样，与游戏服务器之间的通信都走VPN通道，而其他网络数据都不受影响。 4.3 VPN加速使用的三种协议介绍目前网络上现有的网游加速器（或网络加速器）都使用到了三种VPN协议：PPTP、L2TP和OpenVPN。各种不同的协议在使用时可能受用户的网络状况的限制而无法使用，因此一般的网络加速器都会提供不同的加速模式供用户选择。或在启动加速过程中根据用户当前的网络状况自动选择可用的加速模式。 PPTP协议：PPTP协议是在PPP协议基础上开发的增强型安全协议。PPTP协议中有两个流：控制流和数据流。PPTP协议的数据流采用了GRE协议，由于该协议的特殊性，如果同一个NAT中有两个或以上的主机同时在发送PPTP协议数据包，当数据包从外部达到NAT时，NAT将无法通过端口将数据转发到不同的主机，因此，当使用PPTP协议时，如果用户所在的NAT网关不支持VPN穿透功能（即支持PPTP协议的NAT编辑器，该编辑器在GRE协议的报头使用了一个CallId用来表示NAT下的一个会话，通过CallId来模拟端口，做NAT映射），那么内部主机只能与同一个服务器中间建立一个会话，不能有第二个客户端。目前，大多数NAT网关都具有PPTP NAT编辑器，能很好的支持PPTP协议。 L2TP协议：第二层隧道协议，该协议是PPTP协议和Cisco第二层转发协议L2F的结合体。在windows建立的基于L2TP协议的VPN连接中，默认是启用了证书方式的IPSec协议作为安全传输协议，IPSec协议为了保护IP数据包的完整性，会禁止任何对数据包的修改，否则修改后的数据包达到目的主机后其解密和完整性认证就会失败，从而导致这个报文被认为是非法数据而被丢弃。而当加速器客户端位于NAT后时，数据包在通过NAT时，NAT会对IP头数据等进行修改，导致数据到达VPN服务器时被认为是非法数据而丢弃。 解决该问题的一种方式是通过硬件方式：要求通信的双方的边界路由都支持NAT-T，基本原理是在IPSec封装好的数据包外再进行一次UDP的数据封装，因此，当数据包穿过NAT网关时，被修改的只是外层IP/UDP头，而真正的IPSec数据未被修改；到目的主机时再将IP/UDP封装去除，这样就可以得到未被修改的IPSec数据包。 另一种方式是在L2TP协议中禁用IPSec。对于我们制作网络加速器应用来讲，IPSec协议并非必须的，因此，我们可以在加速器连接中去除IPSec协议，而不影响加速功能。在Windows系统下采用RAS进行VPN连接时，若要去除IPSec协议，需要修改注册表并重启机器使之生效。迅游的给力加速器中就是采用这种方式。 OpenVPN模式：OpenVPN是一个基于OpenSSL加密和验证的应用层VPN实现，能够在NAT环境下很好的工作，是今年来新出现的一个基于开源软件体系的VPN项目。使用OpenVPN进行连接前，需要在客户端机器上安装一个虚拟网卡设备，并需要客户端修改路由表。 以上VPN协议中，除了OpenVPN的使用可以不受用户当前网络的限制外，其他两种方式都可能收到用户的NAT情况影响而导致加速失败，因此在实际应用中，各种加速器都会把这几种模式都提供给用户，并根据用户的网络情况进行选择。 4.4 VPN拨号客户端的实现试验过程中对RAS拨号建立VPN连接功能进行了测试。如下客户端实现了连接到VPN服务器，并同时客户端用户输入的“待加速地址”列表，修改路由表，已达到“仅指定IP走VPN通道”的功能，而用户的其他网络访问完全不受影响。 4.5 VPN方式尚存在的问题 与采用代理方式一样，判断与当前启动的游戏通讯的是哪个服务器是个问题（原因如前所述），这里可以用到前面描述的LSP技术，通过在connect函数中判断欲建立连接的IP是否在当前游戏的服务器列表中。此时用到LSP技术并不是用于转发，仅仅用于判断是否加速。 采用VPN方式有一个问题：如果用户修改路由表，让其他进程的服务器IP（如p2p下载软件）或默认路由表经过VPN通道的话，可能会造成VPN通道中的数据量增大，可能会影响正常的游戏。迅游加速器也没有对该问题进行很好的解决，早前的测试发现迅游加速功能启动后，通过修改路由表，可以使任意客户端进程都使用迅游的加速通道来访问网络。 该问题的也许可以通过两种方式来解决：一种是在客户端限制用户修改路由表，另一种是通过在服务器端进行限制非游戏服务器相关的数据。具体实现方式有待研究。 5. 代理加速方式5.1. 代理加速的基本原理采用代理服务器进行网络加速是一类使用较早的技术。目前某些网游客户端和网络应用程序都直接支持SOCKS5代理协议来连接其客户端，客户端提供设置代理服务器IP和端口的方式供玩家来设置。然而大部分网游客户端并不直接支持SOCKS5代理技术。此处介绍的代理加速模式不仅支持那些无法设置SOCKS5代理的网络游戏，即使那些可以设置SOCKS5代理的游戏，玩家也可以不用手动去设置，而自动采用下面介绍的代理加速技术进行代理加速。 代理加速方式可以直接采用SOCKS5协议，由于SOCKS5协议有现成的服务器程序可用，可以节省服务器编写时间；但是也可以自己定义一个“类SOCKS5”的代理协议，自行实现代理协商和身份验证功能。下面的介绍将会基于自己定义代理协议的模式。 在使用代理方式加速时，LSP技术的使用是关键。Microsoft在Winsock2中提供了Winsock服务器提供者（SPI），允许用户在基础TCP/IP协议上层插入自己定义的分层协议（LSP），当用户通过Winsock2 API连接网络或发送网络数据时，如调用WSAConnect函数，将会首先执行到LSP协议的dll中我们定义的函数，这样我们可以先进行处理，然后再交给真正的WSAConnect函数，这样就会起到API Hook的作用。 要使用LSP技术，必须要将写好的LSP协议安装到用户的机器上，安装过程实际就是将DLL放入系统目录，并在注册表中写入该DLL位置信息的过程。注意：安装未签名的LSP时，安装过程中一般防火墙都会有警告提示。 5.2. 代理加速方式的实现概要采用LSP方式进行网络加速需要部署SOCKS5代理服务器作为加速节点，加速客户端自动选择最快的代理服务器作为当前的转发节点。 开发人员在客户端需要完成的动作有： 编写我们自己的LSP协议动态库，重新实现我们需要的相关socket函数，如connect； 在用户的主机安装我们自己的LSP协议，这一操作可以放入我们的应用程序部署的时候完成，也可以在我们的加速器每次启动的时候进行部署； 当游戏客户端调用connect函数（或WSAConnect函数）试图连接游戏服务器时，通过LSP将连接重定向到代理服务器，并采用SOCKS5协议规范与代理服务器进行数据协商，由代理服务器来连接真正的游戏服务器，并将游戏服务器的数据原封不动转发给用户、同时将用户的数据原封不动转发给游戏服务器。 由于Socks5协议并不涉及协议加密，而且Socks5协议本身协商过程较长，实际在开发中，网络加速器开发商一般都不会直接采用socks协议，而是对该协议进行改造，定义自己的代理协议。 5.3. Socks5协议与LSP结合通过LSP技术Hook到相应的套接字函数进行数据转发之前，需要进行Socks5代理协商，即将鉴权信息告诉代理服务器，以及告诉代理服务器自己想连接的真正游戏服务器地址。代理协商完成后才能进行数据的收发。 针对不同的网络连接方式，代理协商的方式有所不同： 普通阻塞方式的TCP连接最简单，可以在hook到connect函数后直接在内部进行阻塞式的代理协商，直到协商完毕后才将connect函数返回给用户，这时候用户拿到的socket实际上是连接到代理服务器的socket，当应用程序通过这个socket收发数据时，实际上是在和代理服务器交互，而这一过程对应用程序来说是透明的，应用程序以为自己是直接在和游戏服务器通信。 目前的网络应用程序很少会采用阻塞方式进行TCP连接，所以这种情况应用场景比较少。 非阻塞方式的TCP连接情况比较复杂，有的TCP连接的socket是可以修改阻塞选项，这样，我们可以在connect函数的入口处判断一下当前socket是否是非阻塞，如果是则将其改为阻塞方式，修改后以阻塞方式进行socks5代理协商，协商完毕后再将socket的阻塞方式修改为非阻塞。 另一种更为复杂的非阻塞TCP连接是基于Windows异步消息的连接，这种连接采用了WSAAsynSelect方式设置了网络消息到来时的Windows接收窗口，所有的网络数据都需要在这个窗口的消息处理函数中处理（QQ飞车的TCP连接就是采用的这种方式）。这类网络模型不能简单采用修改socket阻塞方式的方法来解决。 解决这一问题的唯一办法是在LSP中hook住WSAAsynSelect，在该函数中创建一个我们自己的隐藏窗口，让网络应用程序的所有数据都转发我们自己的窗口上来，在我们的窗口的消息处理函数中进行代理协商和网络数据转发。 对于UDP网络数据的socks5代理转发比TCP又要稍微复杂一些，TCP只需要hook到connect和WSAAsynSelect，对于网络收发数据的send和recv函数是不需要我们自己来实现的。UDP由于是不保持连接的，因此每次发送和接收的UDP包都要包含代理协商信息，因此我们需要把RecvFrom函数和SendTo函数都hook住。 对于UDP连接，需要在应用程序发送第一个UDP包的时候进行代理协商，以后发送数据的时候按照socks5协议的规定，加上socks5头部；收到的信息去除socks5头部再交给应用程序。 5.4. 代理加速方式详细实现下面就详细介绍每一步的具体实现方式，为了方便流程分析，这里从LSP实现数据包转发开始介绍，最后介绍代理服务器的实现。 利用LSP编写DLL，实现客户端数据包转发功能： 编写LSP协议并安装到现有协议之上，需要建立基于DLL的工程，并导出WSPStartup函数，这样当有应用程序创建套接字时，会自动执行到该WSPStartup函数。在WSPStartup函数函数中，参数信息指明了应用程序期望采用哪种协议来创建套接字（所有的协议存在于一个协议链中，该协议链也包含了我们安装的LSP协议），我们需要在该函数中加载下层协议，并调用下层协议提供者的WSPStartup函数初始化，并修改传递给上层的函数表，将我们需要Hook的Winsock2函数指针的地址指向我们自己的函数。关键代码如下： 如果测试程序只针对TCP数据包的转发，只需要实现WSPConnect函数就可以了，其余函数只需要直接调用g_NextProcTable中的默认函数就可以了。 当用户应用程序调用connect函数或WSAConnect函数试图进行TCP连接时，将会先进入LSP的DLL中定义的WSPConnect函数，该函数进入后我们会判断应用程序试图连接的服务器IP和端口是不是我们待加速的服务器，如果是，会执行到socksProxy函数与代理服务器连接，并进行代理协商；如果不是待加速服务器，则执行g_NextProcTable中原有的连接函数，此时LSP就没有起作用，流程与不安装LSP前的流程是一致的。 安装LSP。 要使我们上一步实现的转发协议生效，还必须将上一步生成的DLL安装到用户的系统上。只有安装了LSP，应用程序在调用ws2_32.dll中的函数时就会执行到我们的LSP的DLL中。一般来讲，生成的DLL需要放入Windows/System32目录下，一个原因是DLL路径不能有中文等特殊字符，另一方面，如果有其他程序误删了该DLL，会导致整个系统无法上网的现象，还可能导致整个系统崩溃。 安装LSP首先需要安装协议链，需要将下层协议的信息拷贝过来，修改成我们需要的协议特点，并进行安装；然后对协议链进行排序，将我们的协议放在协议链的最上层，以保证ws2_32.dll调用到的第一个协议是我们的协议。 这里需要注意的是，当安装了“迅游加速器”后，系统上原有安装的分层协议将会被移到最下层，导致原有的协议无效。因此，我们在开发自己的网游加速器时需要考虑该问题，并予以避免。 5.4. 代理方式尚存在的问题 不同网络加速器厂商的LSP安装程序相互之间可能会出现不兼容的情况，所以我们实现自己的加速LSP的时候，其他网络加速器厂商可能对我们安装的协议干扰，如迅游在安装和每次启动的时候会删除其他厂商的LSP协议； 如前所述，LSP在Hook到connect函数后，在WSPConnect函数中会判断当前连接的服务器是否是需要被加速的目的地址。如何获得用户当前启动的游戏的IP和端口是多少是一个难点，因为一个游戏可能连接了多个服务器并开启了多个端口，而真正进行通讯的只是其中一个；另一方面，通过加速客户端启动的进行可能并不是真正的游戏进程（可能只是一个升级程序）。 迅游加速器可能收集了每款待加速游戏的服务器ip和端口，如果客户端发送网络包的目的地址是这些ip的时候，才会针对这些目的ip地址进行加速。本人有过测试：首先获取迅游加速器支持的某款游戏的某个服务器IP和端口，然后自己编写一个客户端不断给该服务器的端口发送数据，当该exe替换游戏的exe并启动后，从抓包结果来看，加速功能仍然有效；当从迅游列表中选择另一款游戏，启动exe时仍启动我们刚刚编写的exe时，加速功能就失效了。因此可以推测：迅游加速器并不是通过判断进程信息来获取目的服务器的（况且通过判断进程信息来获取目的服务器IP并不容易实现，如前所述），而是通过用户从列表中选择的游戏的名称。 6. 总结本文主要介绍了两种实现网游加速的可行的技术方案，其中提到的对其他网络游戏加速器的分析以及具体实现细节可能会有一些不完善之处。 加速器实际实现过程中，还有关键一步就是判断当前用户的网络环境。比如用户当前连接的服务器是网通服务器，更智能的做法是在加速之前提前判断当前用户的网络情况，如果用户是网通用户，则不必启用加速功能，如果用户是电信或其他网络，则需要给用户提示可以启动加速功能，并由用户来决定是否启用加速。 当前游戏如果采用了P2P通信，用户网络环境的判断仍然需要被考虑。如QQ飞车和CF等对战游戏，启动游戏后建立了P2P连接，是否需要对这些P2P连接进行加速呢？这种情况也需要考虑用户的当前网络环境：如果P2P双方处于同一个NAT下，则不需要加速，如果一方是电信用户，而另一方是网通用户，就需要加速功能。 用户网络环境的判断（包括是否处于同一个NAT下的判断）是进行网络加速器的具体实现前需要解决的技术问题。","categories":[],"tags":[{"name":"proxy","slug":"proxy","permalink":"https://haojiaqiang.github.io/tags/proxy/"},{"name":"加速器","slug":"加速器","permalink":"https://haojiaqiang.github.io/tags/加速器/"}]},{"title":"关于死锁的几个经典问题","slug":"关于死锁的几个经典问题","date":"2017-11-30T02:12:19.000Z","updated":"2020-11-19T08:46:06.551Z","comments":true,"path":"2017/11/30/关于死锁的几个经典问题/","link":"","permalink":"https://haojiaqiang.github.io/2017/11/30/关于死锁的几个经典问题/","excerpt":"","text":"经典问题的实现生产者 消费者问题123456789101112131415161718192021222324semaphore mutex = 1;//互斥多个生产者与生产者、消费者与消费者semaphore fill = 0;//缓冲区填充的数据semaphore empty = CONST_BUFFER_SIZE;//缓冲区剩余空闲区域void producer () &#123; while (ture) &#123; Item item = produce(); wait(empty); wait(mutex); bufferPush(item); signal(mutex); signal(fill); &#125;&#125;void consumer () &#123; while(ture) &#123; wait(fill); wait(mutex) Item item = bufferPop(item); signal(mutex) signal(empty) consume(item); &#125;&#125; 读者 写者问题12345678910111213141516171819202122232425262728293031323334// 写者优先：// 写者互斥写着&amp;读者，读者与读者共享;// 当有读者时，写者等待；// 当有写者等待时，不会有新的读者进入，防止写者饥饿int readerCount = 0;//当前读者数量semaphore mutex = 1;//用于保护更新readerCount 变量时的互斥semaphore readWrite = 1;// 互斥读者&amp;写者访问文件semaphore writeFirst = 1;// 用于实现“写优先”void writer () &#123; P(writeFirst);//在无写进程请求时进入 P(readWrite);//互斥访问共享文件 write();//写入 V(readWrite); //释放共享文件 V(writeFirst);//恢复对共享支件的访问&#125;void reader() &#123; P(writeFirst); // 在无写进程请求时进入 P(mutex);// 互斥访问count变量 if (readerCount == 0) &#123;//当第一个读进程读共享文件时 P(readWrite);//阻止写进程写 &#125; readerCount++;//读者计数器加1 V(mutex);//释放互斥变量count V(writeFirst);//恢复对共享文件的访问 read();//读取 P(mutex);//互斥访问count变量 readerCount--;//读者计数器减1 if (readerCount == 0) &#123; //当最后一个读进程读完共享文件 V(readWrite); //允许写进程写 &#125; P(mutex);//释放互斥变量count&#125; 哲学家进餐问题 - 死锁防止方式1至多只允许四个哲学家同时进餐,以保证至少有一个哲学家能够进餐,最终总会释放出他所使用过的两支筷子,从而可使更多的哲学家进餐。以下将room 作为信号量，只允许4个哲学家同时进入餐厅就餐，这样就能保证至少有一个哲学家可以就餐，而申请进入餐厅的哲学家进入room的等待队列，根据FIFO的原则，总会进入到餐厅就餐，因此不会出现饿死和死锁的现象 1234567891011121314semaphore chopstick[5]=&#123;1，1，1，1，1&#125;; semaphore room = 4; void philosopher(int i) &#123; while(true) &#123; think(); wait(room); //请求进入房间进餐 wait(chopstick[i]); //请求左手边的筷子 wait(chopstick[(i+1)%5]); //请求右手边的筷子 eat(); signal(chopstick[(i+1)%5]); //释放右手边的筷子 signal(chopstick[i]); //释放左手边的筷子 signal(room); //退出房间释放信号量room &#125; &#125; 方式2仅当哲学家的左右两支筷子都可用时,才允许他拿起筷子进餐。 方案1利用AND型信号量机制实现：在一个原语中，将一段代码同时需要的多个临界资源，要么全部分配给它，要么一个都不分配，因此不会出现死锁的情形。当某些资源不够时阻塞调用进程;由于等待队列的存在，使得对资源的请求满足FIFO的要求，因此不会出现饥饿的情形。 123456789semaphore chopstick[5]=&#123;1，1，1，1，1&#125;; void philosopher(int i) &#123; while(true) &#123; think(); Swait(chopstick[(i+1)]%5,chopstick[i]); eat(); Ssignal(chopstick[(i+1)]%5,chopstick[i]); &#125; &#125; 方案2利用信号量的保护机制实现:通过信号量mutex对eat()之前的取左侧和右侧筷子的操作进行保护，使之成为一个原子操作，这样可以防止死锁的出现。 12345678910111213semaphore mutex = 1 ; semaphore chopstick[5]=&#123;1，1，1，1，1&#125;; void philosopher(int I) &#123; while(true) &#123; think(); wait(mutex); wait(chopstick[(I+1)]%5); wait(chopstick[I]); signal(mutex); eat(); signal(chopstick[(I+1)]%5); signal(chopstick[I]); &#125; &#125; 方案3规定奇数号的哲学家先拿起他左边的筷子,然后再去拿他右边的筷子;而偶数号的哲学家则相反。按此规定,将是1,2号哲学家竞争1号筷子,3,4号哲学家竞争3号筷子。即五个哲学家都竞争奇数号筷子,获得后,再去竞争偶数号筷子,最后总会有一个哲学家能获 得两支筷子而进餐。而申请不到的哲学家进入阻塞等待队列，根FIFO原则，则先申请的哲学家会较先可以吃饭，因此不会出现饿死的哲学家。 123456789101112131415161718192021222324semaphore chopstick[5]=&#123;1，1，1，1，1&#125;; void philosopher(int i) &#123; while(true) &#123; think(); if(i%2 == 0) //偶数哲学家，先右后左。 &#123; wait (chopstick[ i + 1 ] mod 5) ; wait (chopstick[i]) ; eat(); signal (chopstick[ i + 1 ] mod 5) ; signal (chopstick[i]) ; &#125; Else //奇数哲学家，先左后右。 &#123; wait (chopstick[i]) ; wait (chopstick[ i + 1 ] mod 5) ; eat(); signal (chopstick[i]) ; signal (chopstick[ i + 1 ] mod 5) ; &#125; &#125;&#125; 理发师睡觉问题12345678910111213141516171819202122232425262728293031323334353637383940414243//这个计数器才是共享资源int waiting=0; //控制变量, 用来记录等候理发的顾客数semaphore customers; //用来记录等候理发的顾客数，并用作阻塞理发师进程semaphore barbers; //用来记录正在等候顾客的理发师数，并用作阻塞顾客进程semaphore mutex; //用于线程互斥void barber()&#123; while(true)&#123; P(customers);//若无顾客,理发师睡眠 P(mutex); waiting--; printf(&quot;理发师：等待顾客-1，还剩%d人等待 \\n&quot;, waiting); V(barbers); V(mutex); cut_hair();//理发ing, 这个时候顾客已经独享理发师了，所以不在临界区 P(mutex); if(waiting==0)&#123; //没人就长眠去呗 V(mutex); break; &#125; V(mutex); &#125;&#125;void customer()&#123; P(mutex); //互斥 if(waiting &lt; CHAIRS)&#123; //等候的人比椅子少 waiting++; //等候的人+1 V(customers); //多了一个顾客 V(mutex); P(barbers); //如果没有理发师了，那顾客就在椅子上等着 get_cut(); &#125; else&#123; printf(&quot;顾客%u: 没椅子了，走人 \\n&quot;, (unsigned int)pthread_self()); V(mutex); &#125; V(mutex); //如果前面没有椅子了，就直接走了&#125;","categories":[],"tags":[{"name":"deadLock","slug":"deadLock","permalink":"https://haojiaqiang.github.io/tags/deadLock/"}]},{"title":"彻底理解Runtime","slug":"howRuntimeWorks","date":"2017-09-03T03:53:24.000Z","updated":"2020-11-19T08:46:06.551Z","comments":true,"path":"2017/09/03/howRuntimeWorks/","link":"","permalink":"https://haojiaqiang.github.io/2017/09/03/howRuntimeWorks/","excerpt":"","text":"内部分享文章，参考较多如blog.sunnyxx...，参与整理如@wangtao等恕无法一一列举，在此一并感谢，供参考学习 一句话解释Runtime：运行时。狭义的运行时指运行时库。 为什么要有Runtime：实现向一个 target ( class / instance ) 发送消息名 ( selector ) 动态寻找到函数实现地址 ( IMP ) 并调用的过程，还要处理消息向父类传递、消息转发（ Smalltalk 中叫 “Message-Not-Understood”）等，这些行为无法在 Preprocessing 或 Build Time 实现，需要提供若干运行时的 C 函数进行支持，所有这些函数打个包，便形成Runtime。 OC语言将很多原本需要编译或链接时决定的特性延迟到运行时决定，它会尽可能的动态处理一些事情，这就是我们为什么说OC是一门动态语言。 OC的动态性让其如此强大和灵活： 动态类型，直到运行时才会决定一个对象的类型。动态类型保证了多态，有了抽象和多态，才有了美妙的设计模式~ 动态绑定，在运行时决定哪个方法被真正调用。这样，方法的调用过程不会在被接收者的类型限制，甚至不会被方法名限制，开发者可以更灵活的设计。 动态访问和调整，我们可以随时获取应用的运行信息，并能跟踪、干预应用的运行过程。各种Hook，各种Patch，让我们为所欲为~ 为了支持OC的动态性，光有一个编译器是不够的，还需要一个运行时系统去执行编译后的代码。运行时系统就像是OC语言的操作系统，可以保证OC语言特性的正常表现。OC运行时是以动态库的形式，参与所有OC应用的链接过程。 一.学点历史，更能理解原理Smalltalk 与 C 的融合三十几年前，Brad Cox 和 Tom Love 在主流且高效的 C 语言基础上，借鉴 Smalltalk 的面向对象与消息机制，想要搞出一个易用且轻量的 C 语言扩展，但 C 和 Smalltalk 的思想和语法格格不入，比如在 Smalltalk 中一切皆对象，一切调用都是发消息： 1233 log 再比如用一个工厂方法来实例化一个对象： 1p := Person name: &apos;hayato&apos; age: 26 在当时来看，一个具有面向对象功能的 C 语言真的是非常有吸引力，但必须得解决消息语法的转换，于是乎他们开发了一个 Preprocessor(预处理器)，去解析 Smalltalk 风格的语法，再转换成 C 语言的代码，进而和其他 C 代码一起编译。这个过程和现在 JavaScript 里的 CoffeeScript、JSX 很相似，构建一个 DSL，用转化器转化成原始语言的代码。 想法很美好，但 Smalltalk 语法里面又是空格、又是冒号的，万一遇到个什么复杂嵌套调用，语法解析多难写呀，于是乎他们想，诶呀别费劲了，把消息两边加个中括号吧，这样 Parser 写起来简单多了呢对吧： 1[Person name:&quot;hayato&quot; age: 26]; 这就造就了 Objective-C 奇怪的中括号、冒号四不像语法，这怎么看都是个临时的方案，但在当时可能是唯一方法，借用已有的 C 的编译器比重造一个成本低多了，而且完全兼容 C 语言。随着这几年 Apple 开发的火热，Objective-C 越来越成为 Apple 不爽的地方，先是恨透了在 GCC 上给 Objective-C 加支持，自己重建了个 Clang，后是干脆重新发明了个 Swift 来彻底代替，用 30 年的时间终于还完了这个技术债。 好的，虽然有了个 Preprocessor，但只能做到把 Smalltalk 风格的代码分析并转译成 C，还需要解决两个问题： C 语言上实现一个 OOP 对象模型 将 Smalltalk 风格的 Message 机制转换成 C 函数调用 对象模型的设计倒很省事，直接照搬 Smalltalk 的就好了：如 Class / Meta Class / Instance Method / Class Method 这些概念，还有一些关键字如 self / super / nil 等全都是 Smalltalk 的。这步转换在 Preprocessing 过程中就可以完成，因为重写后的 Class 就是原原本本的 C 语言的 Struct，只需要按 Smalltalk 中“类-元类”的模型设置好即可，无需额外的支持。 消息机制就不一样了，要实现向一个 target ( class / instance ) 发送消息名 ( selector ) 动态寻找到函数实现地址 ( IMP ) 并调用的过程，还要处理消息向父类传递、消息转发（ Smalltalk 中叫 “Message-Not-Understood”）等，这些行为无法在 Preprocessing 或 Build Time 实现，需要提供若干运行时的 C 函数进行支持，所有这些函数打个包，便形成了最原始的 Runtime。 所以最初的 Objective-C = C + Preprocessor + Runtime 注：GCC 中一开始用预处理器来支持 Objective-C，之后作为一个编译器模块，再后来都交给了 Clang 实现。编译器的爱恨情仇请看这里：http://blog.csdn.net/itianyi/article/details/43057279 作为单纯的 C 语言扩展，Runtime 中只要实现几个最基础的函数（如 objc_msgSend）即可，但为了构建整套 Objective-C 面向对象的基础库（如 Foundation），Runtime 还需要提供像 NSObject 这样的 Root Class 作为面向对象的起点、提供运行时反射机制以及运行时对 Class 结构修改的 API 等。再后来，即便是 Objective-C 语言本身的不断发展，新语言特性的加入，也不外乎是扩展 Clang 和扩展 Runtime，比如： ARC：编译器分析对象引用关系，在合适的位置插入内存管理的函数，并需要把这些函数打包加到 Runtime 中，如 objc_storeStrong，objc_storeWeak等，同时还要处理 dealloc 函数，自动加入对 super 的调用等，具体可以看这篇文章。 Lightweight Generics：叫做 “轻量泛型” 是因为只增加了编译器检查的支持，而泛型信息并未影响到运行时，所以 Runtime 库无需改动。 Syntax Sugars：比如 Boxed Expr（@123）、Array Literal（@[…]）、Dictionary Literal（@{…}）和轻量泛型一样，只是把如 @123 在编译期 rewrite 成 [NSNumber numberWithInt:123] 而已，无需改动 Runtime。 Non Fragile Ivars: 类实例变量的动态调整技术，用于实现 Objective-C Binary 的兼容性，随着 Objective-C 2.0 出现，需要编译器和 Runtime 的共同配合，感兴趣的可以看这篇文章。 因此，Runtime 的精髓并非在于平日里很少接触的那些所谓“黑魔法” Runtime API、也并非各种 Swizzle 大法，而是在 Objective-C 语言层面如何处理 Type、处理 Value、如何设计 OOP 数据结构和消息机制、如何设计 ABI 等，去了解这么一个小而美的 C 语言运行时扩展是怎么设计出来的。假如非要让我考一道 Runtime 的题，可能是“给你 C 语言，如何实现一个 Objective-C？”，答到哪儿算哪儿。 二 如何与 Runtime 进行交互通过 Foundation 框架的 NSObject 类定义的方法在OC的世界中，除了NSProxy类以外，所有的类都是NSObject的子类。在Foundation框架下，NSObject和NSProxy两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy是专门用于实现代理对象的类，这个类暂时本篇文章不提。这两个类都遵循了NSObject协议。在NSObject协议中，声明了所有OC对象的公共方法。 在NSObject协议中，有以下5个方法，是可以从Runtime中获取信息，让对象进行自我检查。 12345- (Class)class OBJC_SWIFT_UNAVAILABLE(&quot;use &apos;anObject.dynamicType&apos; instead&quot;);- (BOOL)isKindOfClass:(Class)aClass;- (BOOL)isMemberOfClass:(Class)aClass;- (BOOL)conformsToProtocol:(Protocol *)aProtocol;- (BOOL)respondsToSelector:(SEL)aSelector; -class方法返回对象的类； -isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)； -respondsToSelector: 检查对象能否响应指定的消息； -conformsToProtocol:检查对象是否实现了指定协议类的方法； 在NSObject的类中还定义了一个方法 1- (IMP)methodForSelector:(SEL)aSelector; 这个方法会返回指定方法实现的地址IMP。 以上这些方法会在本篇文章中详细分析具体实现。 通过对 Runtime 库函数的直接调用关于库函数可以在Objective-C Runtime Reference中查看 Runtime 函数的详细文档 三 NSObject起源NSObject的定义如下 12345typedef struct objc_class *Class;@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125; 在Objc2.0之前，objc_class源码如下： 12345678910111213141516struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif &#125; OBJC2_UNAVAILABLE; 在这里可以看到，在一个类中，有超类的指针，类名，版本的信息。ivars是objc_ivar_list成员变量列表的指针；methodLists是指向objc_method_list指针的指针。methodLists是指向方法列表的指针。这里如果动态修改*methodLists的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。 关于Category，这里推荐2篇文章可以仔细研读一下。深入理解Objective-C：Category结合 Category 工作原理分析 OC2.0 中的 runtime 然后在2006年苹果发布Objc 2.0之后，objc_class的定义就变成下面这个样子了。 123456789101112131415161718192021222324252627282930typedef struct objc_class *Class;typedef struct objc_object *id;@interface Object &#123; Class isa; &#125;@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;struct objc_object &#123;private: isa_t isa;&#125;struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125;union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;&#125; 把源码的定义转化成类图，就是上图的样子。 从上述源码中，我们可以看到，Objective-C 对象都是 C 语言结构体实现的，在objc2.0中，所有的对象都会包含一个isa_t类型的结构体。 objc_ object被源码typedef成了id类型，这也就是我们平时遇到的id类型。这个结构体中就只包含了一个isa_t类型的结构体。这个结构体在下面会详细分析。 objc_ class继承于objc_ object。所以在objc_ class中也会包含isa_ t类型的结构体isa。至此，可以得出结论：Objective-C 中类也是一个对象。在objc_class中，除了isa之外，还有3个成员变量，一个是父类的指针，一个是方法缓存，最后一个这个类的实例方法链表。 object类和NSObject类里面分别都包含一个objc _class类型的isa。 上图的左半边类的关系描述完了，接着先从isa来说起。 当一个对象的实例方法被调用的时候，会通过isa找到相应的类，然后在该类的class_ data _bits _t中去查找方法。class _data _bits _t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。 但是在我们调用类方法的时候，类对象的isa里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。 关于元类，更多具体可以研究这篇文章What is a meta-class in Objective-C? 在引入元类之后，类对象和对象查找方法的机制就完全统一了。 对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。 meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。 对应关系的图如下图，下图很好的描述了对象，类，元类之间的关系: 图中实线是 super_class指针，虚线是isa指针。 Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil。每个Class都有一个isa指针指向唯一的Meta classRoot class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。每个Meta class的isa指针都指向Root class (meta)。我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在main方法执行之前，从 dyld到runtime这期间，类对象和元类对象在这期间被创建。具体可看sunnyxx这篇iOS 程序 main 函数之前发生了什么 isa_t 结构体的具体实现接下来我们就该研究研究isa的具体实现了。objc_ object里面的isa是isa_ t类型。通过查看源码，我们可以知道isa_t是一个union联合体。 123456789101112struct objc_object &#123;private: isa_t isa;public: // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ void initIsa(Class cls /*indexed=false*/); void initInstanceIsa(Class cls, bool hasCxxDtor);private: void initIsa(Class newCls, bool indexed, bool hasCxxDtor);｝ 那就从initIsa方法开始研究。下面以arm64为例。 1234567891011121314151617inline voidobjc_object::initInstanceIsa(Class cls, bool hasCxxDtor)&#123; initIsa(cls, true, hasCxxDtor);&#125;inline voidobjc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor)&#123; if (!indexed) &#123; isa.cls = cls; &#125; else &#123; isa.bits = ISA_MAGIC_VALUE; isa.has_cxx_dtor = hasCxxDtor; isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; &#125;&#125; initIsa第二个参数传入了一个true，所以initIsa就会执行else里面的语句。 1234567891011121314151617181920212223242526272829303132333435# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) &#125;;# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8;# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7) &#125;; ISA_MAGIC_VALUE = 0x000001a000000001ULL转换成二进制是11010000000000000000000000000000000000001，结构如下图： 关于参数的说明： 第一位index，代表是否开启isa指针优化。index = 1，代表开启isa指针优化。 在2013年9月，苹果推出了iPhone5s，与此同时，iPhone5s配备了首个采用64位架构的A7双核处理器，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。 在WWDC2013的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。 假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。如下图所示： 苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了Tagged Pointer对象之后，64位CPU下NSNumber的内存图变成了以下这样： 关于Tagged Pointer技术详细的，可以看上面链接那个文章。 has_assoc对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存 has_cxx_dtor表示该对象是否有 C++ 或者 Objc 的析构器 shiftcls类的指针。arm64架构中有33位可以存储类指针。 源码中isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看从 NSObject 的初始化了解 isa这篇文章里面的shiftcls分析。 magic判断对象是否初始化完成，在arm64中0x16是调试器判断当前对象是真的对象还是没有初始化的空间。 weakly_referenced对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放 deallocating对象是否正在释放内存 has_sidetable_rc判断该对象的引用计数是否过大，如果过大则需要其他散列表来进行存储。 extra_rc存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc的值就为 9。 ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取MAGIC值 和 isa类指针。 inline Classobjc_object::ISA(){ assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);} 关于x86_64的架构，具体可以看从 NSObject 的初始化了解 isa文章里面的详细分析。 cache_t的具体实现还是继续看源码 1234567891011121314151617struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125;typedef unsigned int uint32_t;typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bitstypedef unsigned long uintptr_t;typedef uintptr_t cache_key_t;struct bucket_t &#123;private: cache_key_t _key; IMP _imp;&#125; 根据源码，我们可以知道cache_t中存储了一个bucket_t的结构体，和两个unsigned int的变量。 mask：分配用来缓存bucket的总数。occupied：表明目前实际占用的缓存bucket的个数。 bucket_t的结构体中存储了一个unsigned long和一个IMP。IMP是一个函数指针，指向了一个方法的具体实现。 cache_t中的bucket_t *_buckets其实就是一个散列表，用来存储Method的链表。 Cache的作用主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。 class_ data_ bits _t的具体实现源码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;&#125;struct class _rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125;struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125;&#125;; 在 objc _class结构体中的注释写到 class _data _bits _t相当于 class _rw _t指针加上 rr/alloc 的标志。 1class _data _bits _t bits; // class_rw_t * plus custom rr/alloc flags 它为我们提供了便捷方法用于返回其中的 class _rw _t *指针： 123class_rw_t *data() &#123; return bits.data();&#125; Objc的类的属性、方法、以及遵循的协议在obj 2.0的版本之后都放在class_rw_t中。class_ro_t是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。rw-readwrite，ro-readonly 在编译期类的结构中的 class_data_bits_t data指向的是一个 class_ro_t 指针： 在运行时调用 realizeClass方法，会做以下3件事情： 从 class _data _bits _t调用 data方法，将结果从 class _rw _t强制转换为class _ ro_ t指针 初始化一个 class _rw _t结构体 设置结构体 ro的值以及 flag 最后调用methodizeClass方法，把类里面的属性，协议，方法都加载进来。 1234567891011121314struct method_t &#123; SEL name; const char *types; IMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; 方法method的定义如上。里面包含3个成员变量。SEL是方法的名字name。types是Type Encoding类型编码，类型可参考Type Encoding，在此不细说。 IMP是一个函数指针，指向的是函数的具体实现。在runtime中消息传递和转发的目的就是为了找到IMP，并执行函数。 整个运行时过程可以描述如下： 到此，总结一下objc_class 1.0和2.0的差别。 Question: 下面代码输出什么? 1@implementation Son : Father 1234567891011- (id)init&#123; self = [super init]; if (self) &#123; NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); &#125;return self;&#125;@end self和super的区别： self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。 super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用方法时，去调用父类的方法，而不是本类中的方法。 在调用[super class]的时候，runtime会去调用objc_msgSendSuper方法，而不是objc_msgSend 1234567891011121314151617OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )/// Specifies the superclass of an instance. struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class;#else __unsafe_unretained Class super_class;#endif /* super_class is the first class to search */&#125;; 在objc_ msgSendSuper方法中，第一个参数是一个objc_super的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是当前类的父类super_class。 入院考试第一题错误的原因就在这里，误认为[super class]是调用的[super_class class]。 objc_msgSendSuper的工作原理应该是这样的: 从objc_ super结构体指向的superClass父类的方法列表开始查找selector，找到后以objc_super-&gt;receiver去调用父类的这个selector。注意，最后的调用者是objc_super-&gt;receiver，而不是super_class！ 那么objc_msgSendSuper最后就转变成 1234567891011// 注意这里是从父类开始msgSend，而不是从本类开始，谢谢@Josscii 和他同事共同指点出此处描述的不妥。objc_msgSend(objc_super-&gt;receiver, @selector(class))/// Specifies an instance of a class. 这是类的一个实例 __unsafe_unretained id receiver; // 由于是实例调用，所以是减号方法- (Class)class &#123; return object_getClass(self);&#125; 由于找到了父类NSObject里面的class方法的IMP，又因为传入的入参objc_super-&gt;receiver = self。self就是son，调用class，所以父类的方法class执行IMP之后，输出还是son，最后输出两个都一样，都是输出son。 下面代码输出什么？ 12345678910111213141516 @interface Sark : NSObject @end @implementation Sark @end int main(int argc, const char * argv[]) &#123;@autoreleasepool &#123; BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]]; BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]]; NSLog(@&quot;%d %d %d %d&quot;, res1, res2, res3, res4);&#125;return 0;&#125; 先来分析一下源码,这两个函数的对象实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125;Class object_getClass(id obj)&#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125;inline Class objc_object::getIsa() &#123; if (isTaggedPointer()) &#123; uintptr_t slot = ((uintptr_t)this &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK; return objc_tag_classes[slot]; &#125; return ISA();&#125;inline Class objc_object::ISA() &#123; assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);&#125;+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125; 首先题目中NSObject 和 Sark分别调用了class方法。 (BOOL)isKindOfClass:(Class)cls方法内部，会先去获得object_getClass的类，而object_getClass的源码实现是去调用当前类的obj-&gt;getIsa()，最后在ISA()方法中获得meta class的指针。 接着在isKindOfClass中有一个循环，先判断class是否等于meta class，不等就继续循环判断是否等于super class，不等再继续取super class，如此循环下去。 [NSObject class]执行完之后调用isKindOfClass，第一次判断先判断NSObject 和 NSObject的meta class是否相等，之前讲到meta class的时候放了一张很详细的图，从图上我们也可以看出，NSObject的meta class与本身不等。接着第二次循环判断NSObject与meta class的superclass是否相等。还是从那张图上面我们可以看到：Root class(meta) 的superclass 就是 Root class(class)，也就是NSObject本身。所以第二次循环相等，于是第一行res1输出应该为YES。 同理，[Sark class]执行完之后调用isKindOfClass，第一次for循环，Sark的Meta Class与[Sark class]不等，第二次for循环，Sark Meta Class的super class 指向的是 NSObject Meta Class， 和 Sark Class不相等。第三次for循环，NSObject Meta Class的super class指向的是NSObject Class，和 Sark Class 不相等。第四次循环，NSObject Class 的super class 指向 nil， 和 Sark Class不相等。第四次循环之后，退出循环，所以第三行的res3输出为NO。 如果把这里的Sark改成它的实例对象，[sark isKindOfClass:[Sark class]，那么此时就应该输出YES了。因为在isKindOfClass函数中，判断sark的isa指向是否是自己的类Sark，第一次for循环就能输出YES了。 isMemberOfClass的源码实现是拿到自己的isa指针和自己比较，是否相等。第二行isa 指向 NSObject 的 Meta Class，所以和 NSObject Class不相等。第四行，isa指向Sark的Meta Class，和Sark Class也不等，所以第二行res2和第四行res4都输出NO。 消息发送与转发objc_msgSend函数简介最初接触到OC Runtime，一定是从[receiver message]这里开始的。[receiver message]会被编译器转化为： id objc_msgSend ( id self, SEL op, ... ); 这是一个可变参数函数。第二个参数类型是SEL。SEL在OC中是selector方法选择器。 typedef struct objc_selector *SEL; objc_selector是一个映射到方法的C字符串。需要注意的是@selector()选择子只与函数名有关。不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。由于这点特性，也导致了OC不支持函数重载。 在receiver拿到对应的selector之后，如果自己无法执行这个方法，那么该条消息要被转发。或者临时动态的添加方法实现。如果转发到最后依旧没法处理，程序就会崩溃。 所以编译期仅仅是确定了要发送消息，而消息如何处理是要运行期需要解决的事情。 objc_msgSend函数究竟会干什么事情呢？从这篇「objc_msgSend() Tour」文章里面可以得到一个比较详细的结论。 123456789Check for ignored selectors (GC) and short-circuit.Check for nil target.If nil &amp; nil receiver handler configured, jump to handlerIf nil &amp; no handler (default), cleanup and return.Search the class’s method cache for the method IMP(use hash to find&amp;store method in cache)-1. If found, jump to it.-2. Not found: lookup the method IMP in the class itself corresponding its hierarchy chain.If found, load it into cache and jump to it.If not found, jump to forwarding mechanism. 总结一下objc_msgSend会做一下几件事情： 检测这个 selector是不是要忽略的。 检查target是不是为nil。 如果这里有相应的nil的处理函数，就跳转到相应的函数中。 如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因。 确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。 如果找到，就跳转进去执行。 如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止。 如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过select()快速查找IMP的过程。 消息转发Message Forwarding阶段消息转发分为两大阶段。第一阶段先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个“未知的选择子”（unknown selector），这叫做“动态方法解析”（dynamic method resolution）。第二阶段涉及“完整的消息转发机制”。如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。这又细分为两小步。首先，请接收者看看有没有其他对象来处理这条消息。若有，则运行期系统会把消息转发给那个对象，于是消息转发过程结束，一切如常。若没有“备援的接收者”，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装在NSInvocation对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。 注意：选择子就是方法，就是@selector(methodName)这个玩意,也叫方法选择器。 动态方法解析对象在收到无法解读的消息后，首先将调用其所属类的下列类方法： 1+ (BOOL)resolveInstanceMethod:(SEL)selector 该方法的参数就是那个未知的选择子，其返回值为Boolean类型，表示这个类是否能新增一个实例方法用以处理此选择子。 如果是类方法，则会调用： 1+ (BOOL)resolveClassMethod:(SEL)selector 使用这种方法的前提是：相关方法的实现代码已经写好，只等运行的时候动态插在类里面就可以了。 完整的消息转发 如果运行期系统已经执行完了动态方法解析，消息还没有被处理，那么消息接受者自己就无法再以动态新增方法的形式来响应包含该未知选择子的消息了，此时就进入了第二阶段——完整的消息转发。运行期系统会请求消息接受者以其他手段来处理与消息相关的方法调用。 1 备援接收者 当前接收者还有第二次机会能处理未知的选择子，在这一步中运行期系统会问它：能不能把这条消息转给其他接收者来处理。就会调用如下方法： 1- (id)forwardingTargetForSelector:(SEL)selector 这里的返回值，就是备援接收者，它会继续处理这个消息。 在一个对象内部，可能还有一系列其他对象，该对象可经由此方法将能够处理某选择子的相关内部对象返回，这样的话，在外界看来，好像是该对象亲自处理了这些消息似的。 2 完整的消息转发 如果消息还没有被处理，转发算法就会来到这一步。首先创建NSInvocation对象，把尚未处理的那条消息有关的全部细节都封装其中。“消息派发系统”将把消息指派给目标对象。这里的目标对象可以自定义。此步骤会调用下列方法： 1-(void)forwardInvocation:(NSInvocation *)invocation 实现此方法时，如果发现调用操作不应该由本类处理，则需要沿着继承体系，调用父类的同名方法，这样一来，继承体系中的每个类都有机会处理这个调用请求，直至rootClass，也就是NSObject类。如果最后调用了NSObject的类方法，那么该方法还会继而调用”doesNotRecognizeSelector:“以抛出异常，此异常表明选择子最终也未能得到处理。消息转发到此结束。 关于does NotRecognizeSelector:你可能感到陌生，但是对于类似于unrecognized selector send to instance xxx这样的错误，你可能并不陌生。这种错误通常是因为调用了某个对象或者某个类里不存在的方法，从而触发了消息转发机制，最终把这个未识别的消息发送给了NSObject的默认实现。 三，消息转发全流程： 补一张消息发送和转发的图 Question 下面的代码会？Compile Error / Runtime Crash / NSLog…? 12345678910111213141516171819@interface NSObject (Sark) + (void)foo; - (void)foo; @end @implementation NSObject (Sark) - (void)foo &#123; NSLog(@&quot;IMP: -[NSObject(Sark) foo]&quot;); &#125; @end int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; [NSObject foo]; [[NSObject new] foo];&#125;return 0;&#125; OC在初始化的时候，会去加载map_images，map_images最终会调用objc-runtime-new.mm里面的_read_images方法。_read_images方法里面会去初始化内存中的map, 这个时候将会load所有的类，协议还有Category。NSOBject的+load方法就是这个时候调用的。 在这个加载中，for循环中会反复调用_getObjc2CategoryList方法，这个方法的具体实现是： 12// function name content type section nameGETSECT(_getObjc2CategoryList, category_t *, &quot;__objc_catlist&quot;); 最后一个参数__objc_catlist就是编译器刚刚生成的category数组。 加载完所有的category之后，就开始处理这些类别。大体思路还是分为2类来分开处理。 12if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties)&#123;&#125; 第一类是实例方法 12if (cat-&gt;classMethods || cat-&gt;protocols /* || cat-&gt;classProperties */) &#123;&#125; 第二类是类方法。 处理完之后的结果 1)、把category的实例方法、协议以及属性添加到类上 2)、把category的类方法和协议添加到类的metaclass上 这两种情况里面的处理方式都差不多，先去调用addUnattachedCategoryForClass函数，申请内存，分配空间。remethodizeClass这个方法里面会调用attachCategories方法。 attachCategories方法代码就不贴了，有兴趣的可以自己去看看。这个方法里面会用头插法，把新加的方法从头插入方法链表中。并且最后还会flushCaches。 这也就是为什么我们可以在Category里面覆盖原有的方法的原因，因为头插法，新的方法在链表的前面，会优先被遍历到。 以上就是Category加载时候的流程。 再回到这道题目上面来，在加载NSObject的Category中，在编译期会提示我们没有实现+(void)foo的方法，因为在.m文件中并没有找到+的方法，而是一个-号的方法，所以会提示。 但是在实际加载Category的时候，会把-(void)foo加载进去，由于是实例方法，所以会放在NSObject的实例方法链表里面。 根据第二章分析的objc_msgSend源码实现，我们可以知道： 在调用[NSObject foo]的时候，会先在NSObject的meta-class中去查找foo方法的IMP，未找到，继续在superClass中去查找，NSObject的meta-class的superClass就是本身NSObject，于是又回到NSObject的类方法中查找foo方法，于是乎找到了，执行foo方法，输出 1IMP: -[NSObject(Sark) foo] 在调用[[NSObject new] foo]的时候，会先生成一个NSObject的对象，用这个NSObject实例对象再去调用foo方法的时候，会去NSObject的实例方法里面去查找，找到，于是也会输出 1IMP: -[NSObject(Sark) foo] 所以上面这题，不会Compile Error ，更不会 Runtime Crash ，会输出两个相同的结果","categories":[],"tags":[{"name":"runtime","slug":"runtime","permalink":"https://haojiaqiang.github.io/tags/runtime/"}]},{"title":"Runloop","slug":"Runloop","date":"2017-06-29T03:04:43.000Z","updated":"2020-11-19T08:46:06.547Z","comments":true,"path":"2017/06/29/Runloop/","link":"","permalink":"https://haojiaqiang.github.io/2017/06/29/Runloop/","excerpt":"","text":"注：技术分享，参考较多诸如ibireme...恕无法一一列举，再次一并感谢，仅供内部交流学习 一 概述： 一句话解释RunLoop：运行任务的循环。 为什么要有RunLoop：解决交互式UI设计中的一个问题，如何快速响应用户输入，如何快速将程序运行结果输出到屏幕？ 计算机是个笨蛋，同一个时间里只能做同一件事情。要么处理计算任务， 要么轮询各种I/O 接口。 那么，在没有线程的情况下，如何在计算的同时， 又能够轮询各种I/O接口，以迅捷的 和用户交互呢?CS的科学家给出的答案是:看起来够迅捷就行。人的反应速度是有上限的， 因此只要把 计算机的运行时间划分成很多小片段，小到小于人的反应时间， 那么就可以从这些时间片段 中“偷”出一些时间来处理计算任务了。这么说似乎比较抽象。用个例子可以说明runloop的原理: 要求实现一个程序，当程序运行 后，用户每敲击一个字符， 就直接在屏幕上打印用户输入的字符，当程序运行十秒之后， 在 屏幕上输出“Timeout”并退出程序。 那么，问题来了:不用多线程，如何实现这个程序?按照直觉，可以这么写: 123456789101112131415error implementation⟩≡ time_t startTime = time(); char buf[255]; scanf(&quot;%s\\n&quot;, buf);printf(&quot;%s\\n&quot;, buf); sleep(5);Printf(&quot;Timeout\\n&quot;);return 0; 可是！scanf等扫描用户输入的程序是阻塞的。 也就是说, 在scanf这个地方，只要用户一直没有输入，那么程序就全部阻塞了， 接下sleep(5);在用户完成输入之前是永远不会运行 的。那么， 把sleep(5);放到scanf前面呢?也不行，因为sleep同样也是阻塞的。 也就是说， 如果sleep在前面，那么有整整5秒时间，用户都是无法输入的。 这里我们有两个任务: 1) 检测用户输入; 2) 检测时间流逝。 这两个任务是必须并行 的，可是如果直接调用系统的方法，那么我们无法并行， 因为scanf和sleep都是阻塞的，我们 没法控制阻塞的时间和条件。既然阻塞的方法不行，那么为什么不试试非阻塞的呢? 这就是runloop这种框架的动机。 这里我们假设有一个非阻塞的bool readCh(char* ch)函数。 它的作用是获取用户键入的一 个ascii字符，如果用户没有输入任何东西， 那么它将返回false，否则为true。在true的情况 下， 用户的输入通过ch参数带出。 ⟨unblocked implementation⟩≡ time_t startTime = time(NULL); while (1) { char ch; if (true == readCh(&amp;ch)) { printf(&quot;%c&quot;, ch); } if (time(NULL) - startTime &gt; 5) { printf(&quot;Timeout\\n&quot;); return; } 二 Runloop 实现:接下来的章节中我们将实际实现一个基本的runloop， 同样很阳春，具备这么些个功能: runloop 的启动、退出机制 任务注册 runloop重入，loop一段指定的时间 autorelease 同时还会实现一个Timer，演示一下runloop下的异步执行和回调机制。 2.1 问题描述我们要实现的程序还是和第一节里面的需求是一样的， 在一定时间内允许用户输入任意字 符并将用户的输入打印在屏幕上， 5秒后程序打印Timeout并退出。 2.2 Outline首先我们来看看，有了runloop之后，程序的main函数应该是怎样的: ⟨main function⟩≡ int main() { //register runloop jobs runloop_registerJob(&amp;checkAndPrintUserInput); timer_setTimer(5, &amp;printTimeoutAndExit); //kick up runloop runloop_run(); return 0; } 瞧，这就是main函数的全部了，分两部分:注册任务和启动runloop。 2.3 Register Jobs in runloop我们先来看看第一部分: runloop_registerJob(&amp;checkAndPrintUserInput); timer_setTimer(5, &amp;printTimeoutAndExit); 第一句几乎是自注释的，你应该猜到了，这句的作用是往runloop中注册一个任务， 而任 务的形式是一个函数。所以在这里， checkAndPrintUserInput这个函数的地址被当做参数传入 了。在具体谈谈注册机制的实现之前，我们先规定一下这里runloop中的“任务”。 从开发的角 度看，任务本质上就是一段代码，而用何种形式组织这段代码， 则是根据应用场景的不同而不 同的，比如这个例子中， 我们规定一个函数就是一个任务，而因为是函数，所以得有一定的调 用约定: ⟨define job function type⟩≡ typedef void (*runloopJob)(void); 而在Apple平台下，一般是用OO的方式——一个对象+它的方法来代表一个任务。 下面就是 在日常的编程中，Apple程序员最经常接触到的注册任务的方式: ⟨most familia way to register a job on runloop⟩≡ [someInstance performSelectorOnMainThread: SEL(someSelector)]; 有些惊讶么?别奇怪，NSRunloop和NSObject是紧密结合的。performSelectorOnMainThread: 这个函数背后干的就是把它的调用者—— self和参数 ——一个selector包装成一个可以在runloop中运行的任务， 并将这个任务注册到runloop里面 好，接下来要实现我们自己的任务注册机制了。 因为比较阳春，我们用一个全局的数组来 做任务队列， runloop在运行时会遍历这个数组，取出其中的函数地址并执行。 这个数组的最 末尾一个元素为NULL，作为数组结束的标志。 ⟨define a job queue⟩≡ runloopJob jobs[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}; 出于简单起见，jobs数组的长度为10，在这个例子里也够用了。 实际上一般是用动态的数 组来实现的任务队列，在Apple平台上，一般是NSArray。 有了任务队列，注册任务这个函数就很简单了:(将新任务添加到队列末尾) ⟨definition of runloop_registerJob⟩≡ bool runloop_registerJob(runloopJob newJob) { runloopJob* jobPos = jobs; runloopJob* endPos = jobs + sizeof(jobs) / sizeof(runloopJobs) - 1; while (*jobPos &amp;&amp; jobPos &lt; endPos) { jobPos++; } if (jobPos &lt; endPos) *jobPos = newJob; return true; } return false; } 2.4 Define a Timer接着是第二句话， 也是自注释的， 注册一个Timer， 时间五秒，五秒后调用printTime- outAndExit。 这里实现的Timer很简单，全局只有一个Timer，只能设置一个回调函数。 实现 Timer实际上要实现两部分内容: 1) Timer是如何利用runloop启动、运行和退出的; 2) Timer 的回调函数是如何注册的。 我们首先来看Timer需要用到的typedef和变量: ⟨definition of Timer⟩≡ typedef void (*timerCallback)(void); time_t timer_startTime = 0; time_t timeout_seconds = 0; timerCallback timer_timerCallback = NULL; bool timer_is_set = false; 上面这段代码首先是Timer的回调函数的定义， 接着是Timer开始运行的时间、Timer超时的 时间和回调函数。 最后一个变量用于防止重复设置Timer。 因为没有线程，所以我们的Timer必须在runloop中反复运行，以达到检测时间流逝的效果。所以我们需要定义Timer在runloop中运行的内容: ⟨definition of Timer⟩+≡ void timerJob() { if (time(NULL) - timer_startTime &gt; timeout_seconds) { timer_startTime = 0; timer_is_set = false; timeout_seconds = 0; runloop_unregisterJob(&amp;timerJob); timer_timerCallback(); timer_timerCallback = NULL; } } 上面这段代码很简单，每次运行都检测是否超时，如果超时则重置Timer相关的变量， 并将 timerJob从runloop的任务队列中移除，最后调用回调函数并重置回调函数 。到这里，我们已经解决了Timer是如何在runloop中运行和退出这两个问题， 最后我们来实现Timer的注册机制: ⟨definition of Timer⟩+≡ bool timer_setTimer(time_t timeout, timerCallback callback) { if (timer_is_set) { return false; } timer_startTime = time(NULL); timer_timerCallback = callback; timeout_seconds = timeout; timer_is_set = true; runloop_registerJob(timerJob); return true; } 2.5 Run a runloopOK, 接着我们可以看看，runloop是怎么run的了: ⟨definition of runloop run and quit⟩≡ bool shouldContinue; void runloop_run() { bool shouldContinue = true; int jobIndex = 0; while(1) { if (jobs[0] == NULL) { return; } if (jobs[jobIndex] != NULL) { jobs[jobIndex](); jobIndex++; } else { jobIndex = 0; } if (false == shouldContinue) { break; } } } 不复杂吧?接着就是退出机制了。 ⟨definition of runloop run and quit⟩+≡ void runloop_stop() { shouldContinue = false; } 这个退出机制一般是在某个runloop中的任务调用的。 别忘了，runloop_run实际上是阻塞式的函数，任何形如runloop_run();runloop_stop();的代码都是不能终止runloop的。 好了，到这里，一个基本的runloop就完备了，最后我们来实现 checkAndPrintUserInput和 printTimeoutAndExit两个函数: ⟨definition of checkAndPrintUserInput⟩≡ void checkAndPrintUserInput() { char ch; if (canRead(&amp;ch)) { printf(&quot;%c&quot;, ch); } } ⟨definition of printTimeoutAndExit⟩≡ void printTimeoutAndExit() { printf(&quot;Timeout\\n&quot;); exit(0); } 三 Runloop的一些特点和注意事项最后，总结一下runloop的一些特点: 单线程! runloop绝不是一个多线程的玩意， 所以不存在一个变量同时被改写这回事， 所以在NSRunloop中，如果你不希望一个变量被改写， 而使用了一个NSLock来锁住这个变 量， 那么，你要么得到一个死锁(如果你的锁是非递归的情况)， 要么你想保护的变量 还是被改写了(因为是单线程的)。 所有起点是UI的代码， 除非明确指明运行在其他线程上 (通过类似performOnBackground, performSelector:onThread: 等方式)，否则都是运行在主线程的runloop上的 不要在runloop中运行些“大任务”，比如循环个十万二十万次或者其他什么东西， 因为 你实际上是在使用和UI相同的线程。不然，你就会经常见到风火轮了。 异步! runloop的确是一个异步模型， 只不过这个异步模型是通过对任务的调度来实现 的。比如你向runloop中注册任务时， 不是添加到任务的队尾 ，而是插队,那么实际上 执行顺序就被打乱了。 插队这种现象其实很常见，每次当你在一个函数里面调用 - [NSRunloop runMode:beforeDate:] 这个方法时， 实质上就是在打断当前的runloop任 务的执行，转而执行runloop中的其他任务。 记住，这是以单线程的方式打乱了任务的时 序，所以NSLock是不起作用的。 一个runloop，一个线程。 当启动一个新的线程的时候， 这个线程并不会自动拥有一个 runloop，你必须自己完成创建等工作。 没有runloop，没有autorelease。 runloop的每次loop开始时，会建立一个autorelease pool， 于是这次loop中执行的所有任务里，任意某个对象调用了autorelease， 它都 会被注册到这个autorelease pool中。 然后在本次loop结束时，autorelease pool会被 drain。 所以，当没有runloop的时候，也就没有相关联的autorelease pool， 这个时候 调用autorelease是没有意义的 Core Animation在每个run loop周期中自动开始一次新的事务即使你不显式地使用[CATransaction begin]开始一次事务，在一个特定run loop循环中的任何属性的变化都会被收集起来，然后做一次0.25秒的动画。 四 iOS中的RunloopRunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 RunLoop 对外的接口在 CoreFoundation 里面关于 RunLoop 有5个类: 12345CFRunLoopRefCFRunLoopModeRefCFRunLoopSourceRefCFRunLoopTimerRefCFRunLoopObserverRef 其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop }; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop 的ModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： struct __CFRunLoopMode { CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot; CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ... }; struct __CFRunLoop { CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ... }; 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。 [[NSRunLoop mainRunLoop] addTimer:self.completionDelayTimer forMode:NSRunLoopCommonModes]; RunLoop主要处理以下6类事件 Observer事件，runloop中状态变化时进行通知。这里还需要特别注意，CAAnimation是由RunloopObserver触发回调来重绘。 Block事件，非延迟的NSObject PerformSelector立即调用，dispatch_after立即调用，block回调。 Main_Dispatch_Queue事件：GCD中dispatch到main queue的block会被dispatch到main loop执行。 Timer事件：延迟的NSObject PerformSelector，延迟的dispatch_after，timer事件。 Source0事件：处理如UIEvent，CFSocket这类事件。需要手动触发。触摸事件其实是Source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 _UIApplicationHandleEventQueue()。source0一定是要唤醒runloop及时响应并执行的，如果runloop此时在休眠等待系统的 mach_msg事件，那么就会通过source1来唤醒runloop执行。 Source1事件：处理系统内核的mach_msg事件。（推测CADisplayLink也是这里触发）。 RunLoop 的内部逻辑根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下: 内部代码整理如下： /// 用DefaultMode启动 void CFRunLoopRun(void) { CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); } /// 用指定的Mode启动，允许设置RunLoop超时时间 int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) { return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled); } /// RunLoop的实现 int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) { /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) { Boolean sourceHandledThisLoop = NO; int retVal = 0; do { /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) { Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; } /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) { __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); } /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// • 一个基于 port 的Source 的事件。 /// • 一个 Timer 到时间了 /// • RunLoop 自身的超时时间到了 /// • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) { mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg } /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) { __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) } /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) { __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); } /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else { CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) { mach_msg(reply, MACH_SEND_MSG, reply); } } /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) { /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; } else if (timeout) { /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; } else if (__CFRunLoopIsStopped(runloop)) { /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) { /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; } /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 } while (retVal == 0); } /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); } 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop 的底层实现从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。 Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容。 我们在深入看一下 Darwin 这个核心的架构： 其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。 Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 Mach 的消息定义是在 &lt;mach/message.h&gt; 头文件的，很简单： typedef struct { mach_msg_header_t header; mach_msg_body_t body; } mach_msg_base_t; typedef struct { mach_msg_bits_t msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id; } mach_msg_header_t; 一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port， mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify); 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 五 苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;, sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;, observers = &#123; /* same as &apos;common mode items&apos; */ &#125;, timers = &#123; /* same as &apos;common mode items&apos; */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;, sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;, observers = &#123; /* same as &apos;common mode items&apos; */ &#125;, timers = &#123; /* same as &apos;common mode items&apos; */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 注意：事件响应请关注后续的响应链分享！ 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 question：为什么要在Loop即将进入休眠的时候执行GestureRecognizer的回调 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： 1234567891011_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; Tip：当想强制刷新的时候，可以将UIView的setNeedsLayout置为YES，然后布局【view layoutIfNeeded】；注意：界面更新请关注后续的UI渲染分享 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。 注意两点： UIScrollView上的NSTimer 子线程使用NSTimer要加入到RunLoop中 思考:如何写一个相对准确的定时器 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 demo出现问题 TODO-WT 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 请看《RunLoop 的内部逻辑》的内部代码整理 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: 1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信。 CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。 NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 六 本次分享要解决的问题，使用RunLoop实现常驻线程举个例子：AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop 1234567891011121314151617+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; + (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread; RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start &#123; [self.lock lock]; if ([self isCancelled]) &#123; [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; else if ([self isReady]) &#123; self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; [self.lock unlock];&#125; 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 详情看演示demo","categories":[],"tags":[{"name":"Runloop","slug":"Runloop","permalink":"https://haojiaqiang.github.io/tags/Runloop/"}]},{"title":"计算机网络 自顶向下方法","slug":"Computer-Networking-A-Top-Down-Approach-NOTES","date":"2017-05-08T00:10:20.000Z","updated":"2020-11-19T08:46:06.543Z","comments":true,"path":"2017/05/08/Computer-Networking-A-Top-Down-Approach-NOTES/","link":"","permalink":"https://haojiaqiang.github.io/2017/05/08/Computer-Networking-A-Top-Down-Approach-NOTES/","excerpt":"","text":"1.计算机网络和英特网1.物理媒介1.双绞铜线、同轴电缆、多模光纤、陆地无线电频谱、卫星无线电频谱2.分类 1.引导线媒体：沿着特定的固体媒体前行 》双绞铜线、同轴电缆、多模光纤2.非引导型媒体：不能指定传播方向 》 陆地无线电频谱、卫星无线电频谱 2.数据传输的2中方法：1.分组交换(packet switching) &gt; 不预留带宽 趋势2.电路交换(circuit switching) &gt; 建立链接，预留1条通道（稳定，但通道会闲置浪费） 分频复用 &amp;&amp; 分时复用 3.协议栈1.协议栈分层ISO. OSI(开放互联)标准 7层协议栈 英特网 5层协议栈 应用层 应用层 表示层 会话层 传输层 传输层 网络层 网络层 数据链路层 数据链路层 物理层 物理层 2.协议含义分组/packet = 本层首部字段 + 上一层有效载荷字段（最高到应用层报文）1.应用层：A主机程序⬅ 报文/message ➡B主机程序; (HTTP、SMTP、FTP、DNS)2.传输层：A主机程序端点⬅ 报文段/segment ➡B主机程序端点; (TCP、UDP)3.网络层：A主机⬅ 数据报/datagram ➡B主机;(IP,路由选择协议)4.链路层：A结点⬅ 帧/frame ➡B结点,作用于链接结点之间的链路上的协议；（以太网，WiFi,DOCSIS协议）5.物理层：A结点 ⬅ bit ➡ B结点，作用于链路，与实际传输媒体相关，决定链路层帧的每一bit的移动;(关于双绞线，同轴电缆，光纤的协议)表示层 &amp;&amp; 会话层:互联网协议中未包含表示层+会话层，这2层功能由开发者决定是否在其程序中构建对应功能。6.表示层：使通讯的程序能够解释交换数据的含义；（数据压缩、加密、描述）7.会话层：数据交换定界和同步功能，包括建立检查点和恢复方案的方法。结点实现的协议： 1.链路层交换机：物理层+链路层（不能识别IP地址，但可以识别链路层地址如以太网地址）2.路由器：物理层+链路层+网络层3.主机端：物理层+链路层+网络层+传输层+应用层（与英特网结构将它的复杂性放在网络边缘的观点一致） 2.应用层1.应用层协议原理1.网络应用程序体系结构(applkcation architecture) 1.用户-服务器体系结构(client-server architecture)2.对等（P2P）体系结构 (不经过服务器：迅雷p2p下载) 2.套接字socket定义：用于网络发送接收报文的软件接口。为同一台主机内应用层和传输层之间的接口，也称为应用程序和网络之间的应用程序编程接口；开发者可以 控制套接字在 应用层端的一切 ，但是对于传输层的控制 仅限于选择传输层协议&amp;&amp;设定几个传输层参数 ` 3.传输服务数据传输的4个指标：可靠数据传输、吞吐量、定时和安全性 1.可靠数据传输：数据完整性；不可靠 》 容忍丢失应用（音视频应用，扰动但不致命）2.吞吐量：宽带敏感应用&lt;数据编码下限要求;弹性应用&lt;动态利用可用吞吐量3.定时：时效性要求的应用4.安全性：可以进行传输层加解密、数据完整性校验和端点鉴别 4.SSL定义：是对TCP的加强，这种强化 是在应用层上实现的,提供关键的进程到进程的安全性服务：加密、数据完整性和端点鉴别。报文&gt;SSL➡发送方socket ➡️ 接收方socket➡SSl&gt;报文 5.应用层协议定义了： 1.交换的报文类型，例如请求报文和响应报文2.各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的3.字段的语义，即这些字段中包含的信息的含义4.一个进程何时以及如何发送报文，对报文进行响应的规则 2.HTTP协议定义：超文本传输协议;HTTP服务器不保存关于客户的任何信息，因此被称为无状态协议端口号：80 1.HTTP请求报文:请求行1: 3字段 方法 &amp; URL字段 &amp; HTTP版本首部行n(主要为缓存/代理服务器使用) ：首部行1 Host请求实体: GET无，POST有 2.HTTP响应报文：状态行1：HTTP版本 &amp; 状态吗 &amp; 状态部行n：响应实体 3.HTTP的长链接和短链接1.ability:HTTP既能长链接也能短链接，默认长链接（首部字段connection:)2.常用：HTTP一般开启长链接，但会配置时间间隔，超时后自动断开链接。（实际场景一个Web页面有N多个对象需要多次通讯，短链接多次链接太浪费时间,并且一般会有并行链接，可配置并行链接数，默认5～10） 4.HTTP状态吗 （1xx ~ 5xx）123451xx:临时响应2xx:成功3xx:重定向4xx:请求错误5xx:服务器错误 状态码 描述 ::1xx:: ::(临时响应)表示临时响应并需要请求者继续执行操作的状态代码:: 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换 ::2xx:: ::(成功)表示成功处理了请求的状态代码:: 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 (已创建) 请求成功并且服务器创建了新的资源。 202 (已接受) 服务器已接受请求，但尚未处理。 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。 206 (部分内容) 服务器成功处理了部分 GET 请求。 ::3xx:: ::(重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向:: 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 ::4xx:: ::(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理:: 400 (错误请求) 服务器不理解请求的语法 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应 403 (禁止) 服务器拒绝请求 404 (未找到) 服务器找不到请求的网页 405 (方法禁用) 禁用请求中指定的方法 406 (不接受) 无法使用请求的内容特性响应请求的网页 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理 408 (请求超时) 服务器等候请求时发生超时。 409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理 415 (不支持的媒体类型) 请求的格式不受请求页面的支持 416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码 417 (未满足期望值) 服务器未满足”期望”请求标头字段的要求。 ::5xx:: ::(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错:: 500 (服务器内部错误) 服务器遇到错误，无法完成请求。 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本 5.cookie 用途：解决HTTP服务器无状态但需要内容/权限与用户身份关联的场景 4个组件：用户浏览器 ➡️ Web服务器（ 1⃣生成cookie2⃣保存cookie到后端数据库3⃣传递到响应报文首部行set-cookie)➡️用户浏览器（1⃣保存cookie2⃣每次访问对应网站HTTP请求报文都加上首部行cookie：xxx） 12341.HTTP响应报文中一个cookie首部行(set-cookie:)2.HTTP请求报文中一个cookie首部行3.用户端系统中保留一个cookie文件，并由用户浏览器管理4.Web站点维护一个数据库 6.Web代理定义：Web缓存服务器，CDN(content Distribution Network)内容分发网络问题:缓存服务器缓存的对象副本可能是陈旧的解决方案:条件GET方法1⃣请求报文使用GET方法2⃣请求报文中添加首部行“If-Modified-Since”:缓存服务器对象的最后修改时间 1234用户浏览器（条件GET）➡️缓存服务器（条件GET）➡️原始Web服务器1.无变动：原始Web服务器 &gt; 没有实体体，状态码304 Not Modified的报文 &gt; ➡️缓存服务器 &gt; 缓存服务器原来缓存的副本 ➡️ 用户浏览器2.有变动：原始Web服务器 &gt; 最新的响应报文 &gt; ➡️缓存服务器 &gt; 最新的响应报文 ➡️ 用户浏览器 3.FTP协议定义：文件传输协议服务器默认端口：21（控制链接端口） &amp;&amp; 20（文件传输端口）过程：客户端与FTP服务器21端口建立控制TCP链接，通过控制链接发送user标识和口令，发送改变远程目录的命令。FTP服务器从控制链接接收到文件传输的命令后，就通过20端口发起一个到客户端的TCP数据链接，FTP在该数据链接上准确传送一个文件，然后close该数据链接。在同一会话期间，如果还需要传送另外一个文件，FTP则打开另外一个数据连接。对FTP传输而言，FTP必须在整个会话期间保留用户的状态，包括当前路径控等。制链接贯穿整个用户回话期间，但是会话中的每一次文件传输都需要建立一条新的链接（一次只存在一条数据链接只能传输一个文件，故而文件传输是one by one)。 4.SMTP1.Email组成部分：用户代理，邮件服务器 + SMTP；其中每个邮件服务器包含2部分：SMTP客户端 + SMTP服务端2.特点：一般不使用中间服务器发送，当发送失败后会保存在发送发邮件服务器并定时直接对目的邮件服务器重新发送,几天后重试失败会3.过程：A邮件服务器客户端通过25端口与B邮件服务器服务端建立TCP链接，发送报文，如果有其他报文，亦通过该已建立的链接发送，知道全部发送完毕后，指示TCP关闭链接。4.SMTP与HTTP的差异： 1.SMTP主要是push推协议HTTP主要是pull拉协议2.SMTP报文必须使用7byte ASCII码格式编码HTTP数据编码不受限 3.SMTP把所有对象放在一个报文中HTTP把对象分别封装到对象自己的报文中 5.Email的pull协议（SMTP是push协议） 1.第三版邮局协议 POP3 &gt; 不保留状态信息，只能对邮件简单的拉取和删除，邮件目录等状态信息无法关联2.因特网邮件访问协议 IMAP &gt; 保留状态信息，效果类似于fork邮件服务器3.HTTP &gt; Web版邮箱的和邮件服务器之间的pull &amp;&amp; push 5.DNS(Domain Name System) 应用层协议1.端口：532.使用的传输层协议：UDP3.DNS的3中类型： 1.根DNS服务器 &gt; 13个服务器群2.顶级域名（TOP-Level Domain，TLD)DNS服务器 com、org、net、edu… &amp;&amp; 国际顶级域 uk、ca、us…3.权威DNS服务器（ dns.qq.com、dns.google.com…）（一般是1层，但可能是多层递归的， dns.foo.google.com 一般有公司或大学自己维护拥有）4.DNS解析过程： 浏览器等app cache &gt; 主机cache &amp;&amp; DNS文件配置 &gt; 本地DNS服务器cache(一般由ISP提供，严格来说不属于DNS层次机构,而是一个缓存服务器+DNS代理客户端) &gt; TLD服务器cache，如果均没有缓存，则依次执行以下动作1.DNS客户端➡根DNS服务器 return TLD IP address list2.DNS客户端➡TLD (one of the TLD server in the TLD IP address list,default is the first one) return 权威DNS服务器 IP address3.DNS客户端➡权威DNS服务器 return target IP address 注意：DNS各级服务器均有cache机制，自动定时更新cache 6.P2P BitTorrent 机制： 追踪器tracker，主机向tracker注册自己，并周期性通知tracker自身依旧在洪流中，并从tracker获取所有主机列表 最稀缺优先技术，每块256k 30s疏通，重新排列链接的4个伙伴 激励机制：tit-for-tat 7.UDP &amp;&amp; TCP1.TCP 3次握手：发起方通过欢迎端口发起握手，被动方会生成一个专用的socket与发起方握手并开展后续通讯 3.传输层1.定义与作用域1.定义：传输层协议为运行在不通主机上的应用进程之间提供了逻辑通讯2.作用域：作用于端系统，而对网络中的传输无影响（Ann &amp;&amp; Bill） 2.多路复用与多路分解作用：将主机间的交付扩展到进程到进程的交付1.多路复用：源主机从不同的套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层2.多路分解：目标主机将运输层报文段中的数据交付到正确的套接字的工作。注意： 1.UDP中的目标主机，目标IP &amp;&amp; 目标端口号相同，那么这些报文段都会通过相同的目的socket定向到目的进程2.TCP中的目标主机，源IP 或者 源port number不通，只有4个参数一致的(表示为同一条链接)才会被定向（解析）到相同的目的socket:1⃣源端口号2⃣源IP地址3⃣目的端口号4⃣目的IP地址3.端口号范围：端口号是16bit的数，在0～65535之间，其中0～1023为保留的周知端口号（well-known port number) 3.UDP1.定义User Datagram Protocol 用户数据报协议 2.功能内容 UDP是面向报文的，发送方UDP对应用程序交付下来的报文，在添加首部后就向下交付IP层，对报文既不合并也不拆分，而是一次发送一个完整报文(如果需要分片也是由IP协议处理) 除了复用/分解功能以及 少量差错检测 外，几乎没有对IP协议增加别的东西功能有限的差错检测功能由校验报文段首部字段 检验和（checksum field） 来实现，检验和字段来自对报文段所有16bit字的和进行反码运算（实际计算还包括IP首部的一些字段）。然而UDP只能提供差错检测，但对差错无恢复能力，只能丢弃受损报文段或者将受损报文段提供给程序并发出警告。 3.UDP与TCP的优势 1.对于时效性更好:TCP有拥塞控制机制，对于有最低交付速率要求无法实现;而且TCP只管可靠交付而无视实效性，故对于对实效性有要求，但可能容忍一些数据丢失的应用场景更适合,容忍程度由程序自行实现2.无需建立链接：建立链接耗时3.无链接状态：不需维护链接状态，一般能只会更多活跃用户4.分组首部开销小：TCP报文段首部20字节；UDP仅8字节UDP的重要应用：DNS,RIP路由选择表更新，SNMP 4.可靠数据传输原理1.可靠数据传输协议 reliable data gransfer protool 实现v1.0 经完全可靠信道的可靠数据传输v2.0 经具有bit差错信道的可靠数据传输 &gt; 停止等待协议：stop-and-wait1.差错检测 肯定确认：ACK (acknowledgment)否定确认：NAK (negative acknowledgment)2.接收方反馈一次只能传输一个packet，然后等待，直到等待接收方反馈ACK/NAK再传输下一个packet问题：ACK/NAK的packet无法保证可靠传达（丢失、差错）：引入分组序号 3.重传定时器 v3.0可能出错或丢包的信道上的可靠数据传输 &gt; 比特交替协议alternating-bit protocol必不可少：检验和、序号、定时器、肯定与否定确认分组 滑动窗口协议 sliding-window protocol序号、累计（有序）确认、检验以及超时/重传（选择重传&lt;发送方缓存所有ACK序号 &amp; 接收方缓存所有分组） 注意：发送方和接收方的窗口可能不同步，窗口大小 &lt;= 序号大小的一半 5.TCP1.定义Transmission Control Protocol 传输控制协议 2.功能 TCP是面向字节流的，TCP把应用程序交付的报文通过拆分合并转化成适合的序号依次的数据块（大小不一） TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏的、无间隔、非冗余和按序的数据流实现方式：流量控制、序号、确认反馈(TCP不使用否定确认)和定时器注意：流量控制是平衡发送速率与接收方app读取接收方TCP缓存的速率,通过控制发送速率达成（UDP没有流量控制，所以可能造成message即使被接收到但依然丢失）拥塞控制：TCP发送方因为IP网络的拥塞而被遏制,同样通过控制发送速率达成 3.参数1.最大报文段长度MSS = 最大传输单元MTU (= 链路层frame =) - TCP/IP首部长度（通常40字节） 2.定时器超时重传间隔： TimeoutInterval = EstimatedRTT + 4 * DevRTT（建议TimeoutInterval初始值 = 1s） 1.估计往返时间：隔一段时间在某个时刻做一次SampleRTT,由以前的ExtimatedRtt与新值SampleRTT加权而成，EstimatedRtt = (1-a)EstimatedRtt + a SampleRTT,其中a = 1/82.SampleRTT一般会偏离EstimatedRTT的程度：DevRTT = (1-β) DevRTT + β |SampleRTT - EstimatedRTT|,β推荐值0.253.TCP针对 重传 TimeoutInterval = 2 TimeoutInterval,但一旦接收到应用层的数据并传输或者收到ACK,则TimeoutInterval恢复成公式计算结果3.窗口大小窗口大小一直是动态变化的，发送方通过让接收方实时维护报文段首部的 接收窗口 字段来提供流量控制。 4.报文段 [image:8408E26C-8548-4836-BFCC-0D5C86BDFC44-27548-0000679B2ADEC2E4/006tNc79gy1frm77212m1j30kv0efaat.jpg] 123456789101112(1):源端口与目标端口:分别写入源端口号和目标端口号. (2):32位序列号:也就是我们tcp三次握手中的seq,表示的是我们tcp数据段发送的第一个字节的序号,范围[0,2^32 - 1],例如,我们的seq = 201,携带的数据有100,那么最后一个字节的序号就为300,那么下一个报文段就应该从301开始. (3):32位确认序列号:也就是ack(假设为y),它的值是seq+1,表示的意义是y之前的数据我都收到了,下一个我期望收到的数据是y.也就是我回过去的seq = y. (4):首部长度:占4位.也叫数据偏移,因为tcp中的首部中有长度不确定的字段. (5):URG:紧急指针（urgent pointer）有效。当URG=1时,表明紧急指针字段有效.它告诉系统中有紧急数据,应当尽快传送,这时不会按照原来的排队序列来传送.而会将紧急数据插入到本报文段数据的最前面. (6):ACK:确认序号有效。当ACK=1时,我们的确认序列号ack才有效,当ACK=0时,确认序号ack无效,TCP规定:所有建立连接的ACK必须全部置为1. (7):PSH:推送操作,接收方应该尽快将这个报文段交给应用层(8):RST:重建连接。当RST=1时,表明TCP连接出现严重错误,此时必须释放连接,之后重新连接,又叫重置位. (9):SYN:发起一个连接。同步序列号标志位,tcp三次握手中,第一次会将SYN=1,ACK=0,此时表示这是一个连接请求报文段,对方会将SYN=1,ACK=1,表示同意连接,连接完成之后将SYN=0 (10):FIN:释放一个连接。在tcp四次挥手时第一次将FIN=1,表示此报文段的发送方数据已经发送完毕,这是一个释放链接的标志. (11):16位窗口的大小:win的值是作为接收方让发送方设置其发送窗口大小的依据. (13):紧急指针:只有当URG=1时的时候,紧急指针才有效,它指出紧急数据的字节数. 4.快速重传冗余ACK:当TCP接收方接收到一个具有这样序号的报文段时，即其序号大于下一个所期望的、按序的报文段，它检测到了一个流中暂时出现了报文段丢失，因为TCP不使用否定确认，所以发送一个已经收到的最后一个按序字节序号进行重复确认（即冗余ACK）快速重传:当TCP接收到3个冗余ACK时(根据经验演化的指标)，TCP不等待计时器超时就发送冗余ACK起的报文段 5. 3次握手 establish connection1.过程：客户端TCP向服务端TCP发送一个特殊的报文段 SYN报文段 （无有效载荷，首部2个字段：SYN=1,序号 = 随机生成client_isn）➡ 服务端接收并提取SYN报文段，为该TCP链接分配缓存和变量，并向TCP客户端发送允许连接的报文段 SYNACK报文段 (无有效载荷，首部3个字段：SYN=1,确认号=client_isn+1,序号=随机生成server_isn) ➡ 客户端TCP接收并提取SYNACK报文段,为该TCP链接分配缓存和变量，并发送一个 允许服务端链接的 报文段(首部2字段：确认号=server_isn+1,SYN=0且自此以后该TCP链接SYN一直为0，此3次握手 第三阶段报文段可以携带有效载荷 )针对SYN洪泛攻击（客户端不发送第三阶段的对服务端的ACK确认报文段，造成服务端分配的资源被浪费），主流操作系统引入SYN cookie（ = 源和目的IP address &amp; port number + 仅服务器知道的security code 散列得到的特殊序列号）,当收到客户端发来的 SYN报文段 ，不立即分配资源（缓存&amp;变量），返回的 SYNACK报文段 序号=SYN cookie,但服务端并不保存此cookie,而是当收到第三阶段报文段时重新计算cookie,判断确认号==cookie+1则正式针对TCP链接分配资源不接受握手：A主机向B主机端口发送 SYN报文段 ，该端口不接受连结，则B向A反馈reset报文段（RST=1)。A收到reset报文段则表示 SYN报文段 未被防火墙拦截安全抵达，但B主机对应端口不接受连结。 6. 4次挥手 disconnectTCP是双全功的，链接的双方A &amp; B，A向B发送 FIN报文段 (FIN=1)，并进入FIN_WAIT_1状态，表示A已经向B的数据传送完成，不再发送数据 ➡ B接收FIN报文段，发送对于FIN报文段的确认报文段（ ACK=1） ➡ A收到确认报文段，进入FIN_WAIT_2状态，此时变成单功模式(B&gt;&gt;&gt;A)； A接收B发来的 FIN报文段 (FIN=1),反馈一个对此的确认报文段（ACK=1），进入TIME_WAIT状态等待，典型的30s、1min、2min，此等待为预防网络拥塞的工程处理，等待完成后TCP链接正式断开，TCP双方释放资源（包括端口号） 6.拥塞控制算法窗口大小LastByteSent - LastByteAcked &lt;= MIN(cwnd, rwnd) （cwnd:拥塞窗口，rwnd:接收方接收窗口TCP拥塞控制算法包括3个部分：1⃣慢启动2⃣拥塞避免3⃣快速恢复（非必要的补充优化），最通用的是Reno算法注意：UDP在拥塞网络中与TCP竞争占优 1.慢启动启动时拥塞窗口（congestion window）cwnd = 1MSS，每当接收到ACK报文段，则cwnd = 2*cwdn,即cwnd = 2nMSS指数增长。 切换：1⃣当出现丢包，TCP将cwnd重置为1，并将慢启动阀值ssthresh设置为原swdn/2,重新一次慢启动；2⃣当监测到3个冗余ACK，执行快速重传，进入快速恢复状态；3⃣当cwnd达到ssthresh时，进入到拥塞避免模式。 2.拥塞避免当cwnd达到ssthresh慢启动阀值时，进入拥塞避免模式，此模式下每新收到一个RTT下全部ACK,cwnd + 1MSS切换：1⃣当出现丢包或者2⃣当监测到3个冗余AC时，ssthresh = cwnd/2并进入快速恢复模式 3.快速恢复在慢启动或快速恢复状态，监测到3个冗余ACK即进入快速恢复状态； 切换:1⃣对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK,cwnd+=1MSS。当丢失报文段的ACK最终抵达是，TCP降低cwnd并进入拥塞避免状态2⃣当出现丢包cwnd的值被置为1MSS,，ssthresh = cwnd/2进入慢启动状态 7.其他运输层协议1.数据报拥塞协议：Datagram Congestion Control Protocol,DCCP ≈ UDP + 拥塞控制2.流控制传输协议:Stream Control Transmission Procotol,SCTP3.TCP友好速率控制协议：TCP-Friendly Rate Control，TFRC 仅仅是一种拥塞控制协议而不是完整齐全的运输层协议 4.网络层1.概述1.功能转发、路由选择,连结建立 因特网的网络层油3个主要组件：1⃣IP协议2⃣路由选择部分(路由选择协议)3⃣网络层差错&amp;&amp;信息报告（因特网控制报文协议ICMP） 2.协议 IP协议 尽力而为服务（best-effort service) ATM（Asynchronous Transfer Mode）协议 恒定比特率（Constant Bit Rate，CBR)ATM网络服务可用比特率（Available Bit Rate,ABR)ATM网络服务3.帧中继 2.虚电路和数据报网络主流计算机网络体系结构中（IP,ATM,帧中继）网络层只提供虚电路服务或者数据报服务，而不能不同提供2种服务 运输层的连接仅设计两个端系统，网络中的路由器对这些完全不知情。虚电路是由端系统之间的路由器参与建立的，每台路由器都知道经过它的所有虚电路 1.虚电路网络虚电路网络：仅在网络层提供连结服务的计算机网络 2.数据报网络3.路由器工作1.路由选择算法 分类方式1:全局式/分散式 1.全局式路由选择算法代表：链路状态（Link State,LS）算法例如 Dijkstra算法：迭代算法，每个结点知晓整个网络拓扑(通常由链路状态广播算法完成)并计算自身到结点中所有目标的路径，通过迭代计算出源结点到目标结点的路径 2.分散式路由选择算法代表:距离向量(Distance-Vercor， DV)算法特点：异步的、迭代的、自我终止的、分布式的算法分布式：结点发现与它直接相连的链路（费用）发生变化或从某个邻居接收到一个距离向量的更新时，它就更新其距离向量估计 分类方式2:静态/动态 分类方式3:负载敏感/负载迟钝 4.层次路由选择Autonomous System:处于相同的管理与技术控制下的路由器的集合,在AS之间都运行着康铜的路由选择协议路由器组织由自治系统统一管理，AS对外由网关路由器通讯，AS内部通过自治系统内部路由选择协议（intra-autonomoussystem routing protocol)交换路由信息 AS系统内部网关协议，历史上有2个广泛应用的协议分别为RIP 和OSPF 2.因特网中的路由选择1.AS内部路由选择1.路由选择信息协议（Routing Information Protocol，RIP)通过UDP 520端口传递RIP响应报文和RIP通告完成。一般RIP路由器大约30s相互交换通告，如果一台路由器超过180s没有从邻居听到报文，则认为邻居路由器为不可达，此中情况RIP路由器会修改本地路由选择表，并向相邻路由器通告该消息 2.开放最短路优先(Open Shortest Path First,OSPF)OSPF报文由IP承载，协议值89（不属于UDP/TCP,这部分功能由OSPF自行实现），其向AS所有其他路由广播而不仅仅是相邻路由,有一下优点： 1.安全:能够授权/鉴别OSPF报文；2.多条相同费用的路径：可以由多条相同费用的路由分载流量3.对单播和多播路由选择的综合支持4.支持在单个路由选择域内的层次结构 2.AS间路由选择边界网关协议(Broder Gateway Protocol,BGP)作用： 1.从相邻AS处获取子网可达性信息 &lt; 外部BGP会话（external BGP session&gt; 2.向本AS内部所有路由器传播这些可达性信息 &lt; 内部BGPhuihua (internal BGP session&gt;3.基于可达性和AS策略，决定到达子网的“好”路由 4.IP协议1.IP数据报格式1.一般IP数据报首部 = 20字节（无选项时） 1234567891011121314151617181920212223版本：IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6。首部长度：IP报头的长度。固定部分的长度（20字节）和可变部分的长度之和。共占4位。最大为1111，即10进制的15，代表IP报头的最大长度可以为15个32bits（4字节），也就是最长可为15*4=60字节，除去固定部分的长度20字节，可变部分的长度最大为40字节。服务类型：Type Of Service。总长度：IP报文的总长度。报头的长度和数据部分的长度之和。标识：唯一的标识主机发送的每一分数据报。通常每发送一个报文，它的值加一。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。标志：共3位。R、DF、MF三位。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8）生存时间：IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为0时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定，当前值为 64。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。协议：指出IP报文携带的数据使用的是那种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2.首部校验和：计算IP头部的校验和，检查IP报头的完整性。源IP地址：标识IP数据报的源端设备。目的IP地址：标识IP数据报的目的地址。 2.IP数据报分片IP数据报需要提交给链路层传输，而某些链路层帧能承载的最大数据量（最大传送单元Maximum Transmission Unit,MTU）小于IP数据报大小，此种情况需要对IP数据报进行分片封装成小于MTU的小片）例：以太网帧MTU = 1500字节，而IP数据报可以达到216（65535）字节 注意：IPv6已经取消分片，分片动作被设计成在端系统完成而不是路由器中 3.IPv4编址大小：232 4字节大小,常用10进制点分发策略：无类别域间路由选择（Classless Interdomain Routing,CIDR)路由选择原则：最长匹配原则 4.IP分配1.组织获取一块地址公司/组织 &lt; ISP &lt; 区域性因特网注册机构 &lt; 因特网名字和编号分配机构 (Internet Corporation for Assigned Names and Numbers,ICANN组织) 2.组织内分配IP1.DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，使用UDP协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段 2.IP由子网中的DHCP服务器提供，如果没有该服务器，则需要一个DHCP中继代理（一般是路由器），中继代理连接DHCP服务器 1.DHCP服务器发现：新加入的主机通过67端口发送DHCP发现报文，使用“本主机”源地址0..0.0.0发送255.255.255.255广播2.DHCP服务器提供：服务器收到DHCP发现报文，通过255.255.255.255广播提供DHCP提供报文(包含事务I D,推荐IP地址，掩码，IP地址租用期)3.DHCP请求：新加入主机选择一个DHCP服务器通过DHCP请求报文进行响应,回显配置参数4.DHCP ACK：服务器通过DHCP ACK报文对DHCP请求报文进行确认 3.网络地址转换（Network Address Translation,NAT路由器）结点路由器介入修改IP地址和端口号。与互联网原则违背，但现实中依旧存在 5.ICMP追踪链路路由通道：源主机向目的主机的一个不可达UDP端口号依次发送探测packet UDP报文段，并为每个发送启动timer，有效载荷是一个ICMP报文，数据报的TTL(Time To Live,可达结点数)从1开始依次+1。当第n个数据报到达第n台路由器时，路由器观察到该数据报正好过期。根据IP协议规则，路由器丢弃该数据报并向源主机反馈一个ICMP告警报文（类型11编码0），该报警报文包含路由器的name &amp;&amp; IP address，当第m个报文到达目的主机时，因为端口不可达，目的主机会向源主机反馈一个端口不可达的ICMP报文，故而源主机依次知晓路由器 &amp;&amp; 目的主机的 标识 &amp;&amp; IP address &amp;&amp; time。 6.IPv6注意：IPv6和IPv4数据报首部字段不是对应的，不能直接修改IPv6首部的version = 4，且IPv6报文转换IPv4会造成部分报文首部字段丢失 1.数据报格式1234567891011121314151、版本（Version）：4 bit，值为 6（二进制值为 0110）表示 IPv6 报文。2、流量类别（Traffic Class）：8 bit，这相当于 IPv4 协议中的 ToS 字段。但是，考虑到 ToS 字段这些年的发展，现在都用来做区分服务等级（Differentiated Class of Service，DiffServ）了。所以，即使这个字段和旧的 ToS 字段有些相似，它们的名字要比所传送的值更能确切地反映目前的用处。3、流标签（Flow Label）：20 bit，IPv6 中新增。流标签可用来标记特定流的报文，以便在网络层区分不同的报文。转发路径上的路由器可以根据流标签来区分流并进行处理。由于流标签在 IPv6 报文头中携带，转发路由器可以不必根据报文内容来识别不同的流，目的结点也同样可以根据流标签识别流，同时由于流标签在报文头中，因此使用 IPSec 后仍然可以根据流标签进行 QoS 处理。4、有效载荷长度（Payload Length）：16 bit，以字节为单位的 IPv6 载荷长度，也就是 IPv6 报文基本头以后部分的长度（包括所有扩展头部分）。IPv4 的总长度字段是 16 位的，但 IPv6 的有效载荷长度字段却是 20 位，这就意味着该字段能够指定更长的有效载荷（1 048 575 字节，相对 IPv4 中只有 65 535 字节）。5、下一报头（Next Header）：8 bit，用来标识当前头（基本头或扩展头）后下一个头的类型。此域内定义的类型与 IPv4 中的协议域值相同。IPv6 定义的扩展头由基本头或扩展头中的扩展头域链接成一条链。这一机制下处理扩展头更高效，转发路由器只处理必须处理的选项头，提高了转发效率。6、跳数限制（Hop Limit）：8 bit，和 IPv4 中的 TTL 字段类似。每个转发此报文的结点把此域减 1，如果此域值减到 0 则丢弃。注意：IPv4 中的 TTL 设计之初是以秒（s）为单位的，但实际使用时跟 IPv6 中的 Hop Limit 一样，是以跳数为单位。7、源地址（Source Address）：128 bit，报文的源地址。8、目的地址（Destination Address）：128 bit，报文的目的地址。 2.IPv6兼容IPv4的方法1.双栈（dual-stack）方法双栈结点同时具有完整的IPv6和IPv4实现，当与另外一个IPv6 ability结点通讯时使用IPv6,否则使用IPv4（注意IPv6数据报转换成IPv4数据报会有部分报文首部字段丢失）,另外双栈结点虽然都有IPv4能力，但相互之间只会用IPv6通讯。 判断一个结点是否IPv6 ability，可通过DNS等返回的其IP，如果是IPv6 address则说明是IPv6 ability,否则仅支持IPv412C为IPv4 only结点，其余为双栈结点A &lt;IPv6&gt; B &lt;IPv4&gt; C &lt;IPv4&gt; D &lt;IPv6&gt; E ️ 2.隧道(tunneling)特殊的双栈方法，即当双栈结点之间有IPv4 only结点时，以两个双栈结点为两端建立隧道，起始结点把IPv6完整数据报包装成IPv4的有效载荷，并加上IPv4数据报首部，通过IPv4 only结点发送到隧道另一段的双栈结点，并由该双栈结点取出有效载荷部分的IPv6完整数据报并向后传输（此方法不会造成数据报首部字段丢失） 5.链路层注意：链路层是硬件与软件的结合体（如当链路层帧到达时，链路层软件响应控制器中断），即此处是协议栈中软件与硬件交接的地方。 1.链路层提供的服务1.成帧2.链路接入:媒体访问控制&lt;Medium Access Control, MAC)协议协调多个结点的帧传输3.可靠交付:一般用于无线这类易于产生差错的链路，通常是通过确认和重传取得4.差错检测和纠正:差错一般由信号衰减和电磁噪声导致，差错检测根据帧中差错检测和纠正比特 由硬件完成，并能够自行修复 2.差错检测和纠正技术注意：链路层的差错检测检测方式非100% 1.奇偶校验（二维奇偶校验）2.检验和3.循环冗余检测（Cyclic redundancy check，CRC)是一种特殊的检验和，在现今的计算机网络中广泛应用。因为链路层的差错检测由硬件完成，所以相对于传输层(仅用16比特)可以执行更加复杂的CRC操作 3.多路访问协议(channel partition protocol)1.信道划分协议1.时分多路复用(TDM)2.频分多路复用(FDM)3.*码分多址(CDMA) 2.随机接入协议(random access protocol)1.ALOHA协议2.载波侦听多路访问（Carrier Sense Multiple Access, CSMA）协议;【带有冲突检测的载波侦听多路访问（Carrier Sense Multiple Access with Collision Detection, CSMA/CD）】 3.轮流协议（taking-turns protocol）1.轮流协议（taking-turns protocol）2.令牌传递协议(token-passing protocol) 4.链路层寻址3种类型地址：应用层的主机名，网络层的IP地址以及链路层的MAC地址。 1.MAC地址MAC地址（局域网地址）是主机或者路由器的网络适配器具有的链路层地址，故而一个主机可能有多个MAC地址，MAC被设计为永久的（用软件改变是可能的） 2.地址解析协议（Address Resolution Protocol, ARP)作用：IP address和MAC地址之间转换作用范围：只为同一子网中的主机和路由器接口解析IP地址特殊：ARP是跨越链路层与网络层边界的协议 3.路由器和交换机比较交换机优点： 1.即插即用2.只需处理到链路层帧，相对速度快 路由器优点： 1.提供了更健壮的流量隔离方式和对广播风暴的控制（主机数量多时需要） 路由器缺点: 1.路由器和连接到路由器的主机都需要配置IP2.处理到网络层数据报，相对复杂 4.数据中心网络1.负载均衡器（load balancer)基于目的IP &amp;&amp; port address协调向数据中心内部的主机分发请求，隐藏网络内部结构和防止用户与主机直接交互的安全性益处。 2.模块化数据中心（Modular Data Center,MDC)数据中心网路发展的趋势 6.无线网路和移动网络1.WiFi:802.11 无线LAN1.建立连接被动扫描：信标帧主动扫描：探测帧 &amp;&amp; 探测响应帧 2.MAC协议 CSMA/CA【请求发送控制帧（Request to Send,RTS) &amp;&amp; 短允许发送控制帧(Clear to Send,CTS)】 链路层确认方案【CRC校验确认帧after 短帧间间隔（Short Inter-Frame Spacing， SIFS)】 3.相同子网中的移动性由同一交换机S相连的所有站点（包括AP)都属于同一个IP子网。当主机H移动时，随着逐步远离原来连接的AP1,H检测到AP1的信号逐渐减弱，此时H开始扫描其它更强的信号。当H收到来自AP2的信标帧（通常同一IP子网中的AP设置相同的SSID）,H解除与AP1的连接并建立与AP2的连接，同时保持原IP不变和维持已建立的TCP会话。由于交换机S是自学习的，会自动构建新的转发表，之后主机H的通讯交换机S会变更成通过通往AP2的端口转发。 4.802.11中的高级特色 802.11速率适应方案，效果类似于TCP的拥塞控制，当丢包/超时发生时，自动降低传输速率 功率管理：节点能够明显的在睡眠与唤醒状态交替。节点P通过802.11帧首部功率管理=1告知接入点AP节点P将进入睡眠状态，同时节点P设置一个定时器，使得正好在AP计划发送它的信标帧前唤醒自身（AP通常 1信标帧/100 ms，节点唤醒仅需250 um）。在睡眠期间需要向P发送的帧都被AP缓存 5.蓝牙和ZigBee IEEE 802.15.1 Bluetooth IEEE 802.14.5 ZigBeeZigBee与蓝牙的优缺点：优点：低功率节能，设备便宜缺点：信道速率低，最高205kbps 6.3G &amp;&amp; 4G3G：在原核心GSM蜂窝语音网络上增加与其平行的附加蜂窝数据功能4G：全”IP”网络，语音&amp;&amp;数据功能全部由IP数据报承载 7.移动通讯 路由选择 间接路由选择：移动节点P连接到外部网路时，它向外部网络注册，外部代理F向归属代理B注册移动节点P的转交地址（Care-Of Address, COA),即外部代理F的地址，之后所有发往移动节点P的packet都发往归属代理B,归属代理B将通讯者的原始数据报封装在一个以目的地址为COA的数据报内（此封装方式类似于IPv6的隧道技术），通过外部代理转交原始数据报给移动节点P。由于P可以通过数据报知晓原始通讯者，故移动节点到原始通讯者的通讯是直连的无需归属代理和外部代理的转发 直接路由选择：通讯者避开归属代理直接由COA转交数据报，现行解决此种方式的移动性的方式是首个外部代理A为锚外部代理，当移动节点切换到下一外部代理B网路下，B向上一锚外部代理A注册，其后数据报由A转发到B，同样当移动到外部代理C之后，C会向锚外部代理A注册，其后数据由A转发到B 7.多媒体网络1.多媒体网络应用的类型 流式存储音频和视频 会话式IP语音和视频 流式实况音频和视频 2.流式储存视频（2 &amp;&amp; 3常见） UDP流(UDP streaming) HTTP流(HTTP streaming) 适应性HTTP流(adaptive HTTP streaming) 3.内容分发网名称：Content Distribution Newwork, CDN IP任播（IP anycast):不通服务器群使用相同的IP地址，当一个BGP路由器接收到相同IP的多个路由通告，它对待这些通告就像对相同物理地址（其实不同）提供了不同的路径，故而BGP路由器根据本地路由选择规则选择“最好”的路径即服务器群 4.丢包处理 向前纠错（Forward Error Correction, FEC) 交织 差错掩盖 5.实时会话式应用的协议 RTP(Real Time Protocol) 会话发起协议（Session Initiation Protocol, SIP) 8.计算机网络安全1.原则 身份验证：证书验证公钥,用户身份验证（数据报IP首部ip、TCP序号等均可以被篡改） 数据加密：可逆加密 3DES、AES… 数据完整性校验：报文鉴别码MAC(Message Authentication Code) 《 数据Hash 2.HTTPS 密钥唯一性： 每次连接密钥加入一个不重数计算生成，防止过期密钥被使用 密钥导出：4个密钥均由客户端生成的主密钥切片生成 1.A到B的会话加密密钥2.A到B的会话MAC密钥3.B到A的会话加密密钥4.B到A的会话MAC密钥 防止TCP序号篡改 MAC = 数据+MAC密钥+当前序号(由发送发维护的依次顺序，与TCP无关）的Hash 防止TCP状态被影响 特殊状态如TCP FIN均提前通过SSL告知，未经过SSL告知而直接切换TCP状态视为异常 3.网路安全层：IPsec同应用层的问题，运用到网络层，地毯式加密IPSec协议，特殊的IP数据报首部 + 加密/鉴别的内容 4.无线LAN安全 IEEE 802.11的在线等效保密（Wired Equivalent Privacy, WEP),相对较弱的加密、鉴别方式 IEEE 802.11i 引入强加密、鉴别方式 5.防火墙 目的: 1.防火墙本身免于渗透2.外部到内部和内部到外部的所有流量都通过防火墙3.仅符合安全策略的授权流量允许通过 2.方式： 检查packet首部及有效载荷特征，可以应用于网络映射（例如使用nmap进行分析）、端口扫描、TCP栈扫描、DoS带宽泛红攻击、蠕虫和病毒、操作系统脆弱性攻击和应用程序脆弱性攻击 大部分的计算机工作都是工程性的，平衡竞争各方的利益，正确折中的艺术能够满足许多相矛盾的目标 — Steven M. Bellovin","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://haojiaqiang.github.io/tags/计算机网络/"}]},{"title":"GCD队列与同步异步的组合","slug":"GCD-queue-and-sync-async","date":"2017-04-19T03:50:41.000Z","updated":"2020-11-19T08:46:06.544Z","comments":true,"path":"2017/04/19/GCD-queue-and-sync-async/","link":"","permalink":"https://haojiaqiang.github.io/2017/04/19/GCD-queue-and-sync-async/","excerpt":"","text":"串行队列 DISPATCH_QUEUE_SERIAL串行队列 + async 只会生成1个线程（如果是dispatch_get_main_queue()因为主线程已存在故不再生成） 同一队列的任务在同一个线程依次执行 串行队列 + sync 任务队列 == 任务分发队列 &gt;&gt; 死锁 任务队列 != 任务分发的队列 &gt;&gt; 不会生成新队列，所有任务在任务分发的队列所在线程依次执行 并发队列 DISPATCH_QUEUE_CONCURRENT并发队列 + async 生成无数个线程并执行对应的任务，执行顺序非依次顺序 并发队列 + sync不生成新线程，全部任务在main线程中依次执行 同步 Synchronize 同步可以导致死锁，当且仅当任务队列 == 任务分发队列，且该队列为串行队列 表示（任务分发的队列所在线程）等待（被添加的）任务执行完毕并返回 死锁 &lt; 串行队列中同步添加任务到该串行队列12345678dispatch_queue_t customSerialQueue = dispatch_queue_create(&quot;test.hayato.MyCustomQueue&quot;, DISPATCH_QUEUE_SERIAL);dispatch_async(customSerialQueue, ^&#123; DLog(@&quot;customSerialQueue-A, thread:%@&quot;, [NSThread currentThread]); # warning &gt;&gt; deadLock dispatch_async(customSerialQueue, ^&#123; DLog(@&quot;customSerialQueue-B, thread:%@&quot;, [NSThread currentThread]); &#125;);&#125;; 不死锁 &lt; 并发队列同步添加任务到该并发队列123456789101112dispatch_queue_t customConcurrentQueue = dispatch_queue_create(&quot;test.hayato.MyCustomQueue&quot;, DISPATCH_QUEUE_CONCURRENT);NSInteger blockIndex = 0;//当前主线程dispatch_sync(customConcurrentQueue, ^&#123; DLog(@&quot;blk%ld, thread:%@&quot;, blockIndex,[NSThread currentThread]); dispatch_sync(customConcurrentQueue, ^&#123; DLog(@&quot;blk%ld, thread:%@&quot;, blockIndex,[NSThread currentThread]); &#125;);&#125;);// 打印结果blk0, thread:&lt;NSThread: 0x60c000063180&gt;&#123;number = 1, name = main&#125;blk0, thread:&lt;NSThread: 0x60c000063180&gt;&#123;number = 1, name = main&#125; 异步 Asynchronize 异步不会导致死锁 表示（任务分发的队列所在线程）不等待（被添加的）任务执行完毕并返回，继续执行分发队列余下任务","categories":[],"tags":[{"name":"async","slug":"async","permalink":"https://haojiaqiang.github.io/tags/async/"},{"name":"sync","slug":"sync","permalink":"https://haojiaqiang.github.io/tags/sync/"},{"name":"queue","slug":"queue","permalink":"https://haojiaqiang.github.io/tags/queue/"}]},{"title":"iOS Core Animation","slug":"iOS-Core-Animation","date":"2017-01-02T09:43:48.000Z","updated":"2020-11-19T08:46:06.551Z","comments":true,"path":"2017/01/02/iOS-Core-Animation/","link":"","permalink":"https://haojiaqiang.github.io/2017/01/02/iOS-Core-Animation/","excerpt":"","text":"概念: Core Graphics:实际上是一个严格意义上的2D绘图API2.图层树3.OpenGL:底层C接口，提供了Core Animation的基础4.Core Animation 处在iOS的核心地位：应用内和应用间都会用到它 关于layer: 1.布局：view 的布局三属性： frame， bounds， center。对应的， layer 是 frame， bounds， position。center 和position 指示的是 anchorPoint的位置。frame是一个虚值，它通过 bounds, position, transform 自动计算出来的;另外，更改 frame 属性，也会相应的更改 bounds， position 等属性的值。当旋转的时候，frame 值可能就和bounds 的宽度和高度没啥相等的了。 2.锚点 anchorPoint默认是 {0.5,0.5} 在正中心。锚点主要影响变形的中心，和subView的坐标系统。 3.坐标系统layer 和view 类似，采用树形的父子链式的坐标系统。即，当你移动一个layer 的时候，其subView也会随之移动。在不同的树节点的坐标系统中变换某个点的话，采用下边四个方法：(CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer)layer;(CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer)layer;(CGPoint)convertRect:(CGRect)rect fromLayer:(CALayer)layer;(CGPoint)convertRect:(CGRect)rect toLayer:(CALayer)layer;iOS 上position 是对应父layer的左上角，在mac 上却是对应左下角。在 Core Animation 中，geometryFlipped 属性（BOOL类型）可以支持这两种行为。你可以在iOS上将 geometryFlipped 设置为 YES，来实现坐标是对应左下角的行为。CALayer 在z轴上有两个属性：zPosition 和 anchorPointZ， 通常用不到，因为旋转可以用 transform 来实现，如果单纯的调整view的显示前后次序，可以设置一下 zPosition 比较简单。 4.点击测试 hit testing尽管 CALayer 对响应链不知情，不知道如何去处理触摸等事件，但是它提供了两个工具方法： -containsPoint: 和 -hitTest:-containsPoint: 接受一个 CGPoint 参数，这个坐标是在本 layer 坐标系内的坐标，所以通常你需要通过 - (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer*)layer 来转换一下。返回一个 BOOL， 即检测 CGPoint 是否在本 layer 中。-hitTest: 方法接受一个 CGPoint 参数，返回 CALayer。它的意义是查找 本layer 树中（本layer 和所有的sublayer以及sub的sub etc），找出 CGPoint 所在的 layer。但是如果你设置了 zPosition 属性来调整 layer 的显示次序，可能得出的结果不是你看到的最上边的layer， 而是被盖住的layer。 4.自动布局iOS 上view的自动布局用 UIViewAutoresizingMask 和 NSLayoutConstraint API 。但是 layer 的自动布局就情况不太好了， 通过 CALayerDelegate 的 -(void)layoutSublayersOfLayer:(CALayer*)layer 来内部实现手动布局，然后在 layer的 bounds 属性被更改或 -setNeedLayout 方法被调用的时候，此布局方法会被调用。屏幕旋转的话，你还是别想了吧。所以尽可能使用 UIView 的自动布局吧，况且有 Masonry 那么强大友好的 DSL呢。 关于GPU： 现代 GPU 在处理计算机图形和图像方面非常高效，并且 GPU 的高度并行结构使其在大块数据并行处理的算法中比通用 CPU 更有效。 1.图层树1.UIView &amp; UILayer的关系 UIView仅仅是对UILayer的封装,增加了交互功能(事件响应),提供了一些Core Animation底层方法的高级接口. UIView封装的API没有实现Core Animation的全部功能,需要由UILayer实现: 阴影,圆角,带颜色的边框 3D变换 非矩形范围 透明遮罩 多级非线性动画 2.寄宿图1.Layer上添加寄宿图Core Foundation &lt;桥接&gt; Cocoa对象1234UIImage *image = [UIImage imageNamed:\"imageName\"];view.layer.contents = (__bridge id)image.CGImage;self.layerView.layer.contentsGravity = kCAGravityResizeAspect;// 内容填充模式self.layerView.layer.contentsScale = image.scale([UIScreen mainScreen].scale);// contentsScale主要是为了适配Retina,当contentsGravity是拉伸效果时,contentsScale无效,如果contentsGravity设置为无拉伸效果,必须手动设置contentsScale,否则图片在Retina上会失真变大(读取的UIImage可能是@2x,@3x,而CGImage默认是像素点与图片像素1:1) 2.contentsRect 默认{0, 0, 1, 1} &gt; {x, y, widthRatio, heightRatio},设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域 拼合图片,一张图片通过contentsRect截取不同部分显示在不同的layer上 3.contentsCenter contents赋值寄宿图的方法:CGImage &amp;&amp; Core Graphics直接绘制(-drawRect:) 如果你不需要寄宿图，那就不要创建一个空的-drawRect:(只要实现了该方法，就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale的值，造成资源浪费)) -drawRect:绘制寄宿图即使没有clipToBounds也不会显示超出部分,因为绘制在bounds内,超出部分根本没有绘制 3.图层几何学 UIView/CALayer 渲染效果：bounds,positon/AnchorPoint,transform anchorPoint zPosition (仅仅改变显示层级,不能改变时间传递的层级) 4.视觉效果cornerRadius 沿着图层的边界 默认只影响backgroundColor,不影响内容配合maskToBounds切除超出部分 border 沿着图层的边界绘制出来 borderWidth borderColor shadow 沿着自身&amp;subView&amp;寄宿图创建阴影(不是Layer自身的边界) shadowOpacity (0&lt; 显示 &lt;1) shadowColor shadowOffset shadowRadiustips: shadow在layer之外,maskToBounds会切掉 &gt; 单独增加一个layer显示阴影 要考虑所有子视图 &amp; 寄宿图,故而性能差 &gt; shadowPath123456789101112&gt; &#123;&gt; //create a square shadow&gt; CGMutablePathRef squarePath = CGPathCreateMutable();&gt; CGPathAddRect(squarePath, NULL, self.layerView1.bounds);&gt; self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);&gt; &gt; //create a circular shadow&gt; CGMutablePathRef circlePath = CGPathCreateMutable();&gt; CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);&gt; self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);&gt; &#125;&gt; 知识点: shadowPath是一个CGPathRef类型（一个指向CGPath的指针）。CGPath是一个Core Graphics对象，用来指定任意的一个矢量图形,绘制简单图形方便 UIBezierPath是UIKit提供的在CGPath基础上的Objective-C包装类 borderColor是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。CGColorRef在引用/释放时候的行为表现得与NSObject极其相似。但是Objective-C语法并不支持这一做法，所以CGColorRef属性即便是强引用也只能通过assign关键字来声明。 图层蒙版CAlyer包含一个属性CALayer *mask,只有mask图层区域内的内容会显示出来123456789101112- (void)mask &#123; [super viewDidLoad]; //create mask layer CALayer *maskLayer = [CALayer layer]; maskLayer.frame = self.layerView.bounds; UIImage *maskImage = [UIImage imageNamed:@\"Cone.png\"]; maskLayer.contents = (__bridge id)maskImage.CGImage; //apply mask to image layer self.imageView.layer.mask = maskLayer;&#125; 透明度 (UIView.alpha &amp; CALayer.opacity) Q:设置 0 &lt; alpha &lt; 1是,subView颜色和自身颜色不完全一致 A:组透明 全局设置: info.plist &gt; UIViewGroupOpacity = YES 针对设置:光栅化:图层及其子图层都会先被整合成一个整体的图片.layer.shouldRasterize = YES;.layer.rasterizationScale = [UIScreen mainScreen].scale;(Retain屏适配) 5.变换 仿射:无论变换矩阵用什么值，图层中平行的两条线在变换之后任然保持平行 1.旋转&amp;缩放&amp;平移 CGAffineTransformMakeRotation(CGFloat angle) CGAffineTransformMakeScale(CGFloat sx, CGFloat sy) CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) CGAffineTransformRotate(CGAffineTransform t, CGFloat angle) &gt; * CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy) CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty) 用CGAffineTransform &amp; CGAffineTransformConcat计算形变值12345678- (void)calculateTransform &#123; CGAffineTransform transform = CGAffineTransformIdentity; //create a new transform transform = CGAffineTransformScale(transform, 0.5, 0.5); //scale by 50% transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); //rotate by 30 degrees transform = CGAffineTransformTranslate(transform, 200, 0); //translate by 200 points //apply transform to layer self.layerView.layer.affineTransform = transform;&#125; 2.剪切(CG没有直接提供对应函数)3.3D变换 CATransform3D CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z) CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz) layer.doubleSided 是否双面绘制 6.专有图层CAShapeLayer可以用来绘制所有能够通过CGPath绘制的图形,且有优点: 渲染快速。CAShapeLayer使用了硬件加速，比用Core Graphics快很多。 高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。 不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。使用Core Graphics的普通CALayer会被剪裁掉 不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化1234567891011121314151617181920212223242526272829303132333435363738394041+ (Class)layerClass&#123; //this makes our view create a CAShapeLayer //instead of a CALayer for its backing layer return [CAShapeLayer class];&#125;- (void)setShapeLayerInfo&#123; //create a mutable path self.path = [[UIBezierPath alloc] init]; //configure the layer CAShapeLayer *shapeLayer = (CAShapeLayer *)self.layer; shapeLayer.strokeColor = [UIColor redColor].CGColor; shapeLayer.fillColor = [UIColor clearColor].CGColor; shapeLayer.lineJoin = kCALineJoinRound; shapeLayer.lineCap = kCALineCapRound; shapeLayer.lineWidth = 5;&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; //get the starting point CGPoint point = [[touches anyObject] locationInView:self]; //move the path drawing cursor to the starting point [self.path moveToPoint:point];&#125;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123; //get the current point CGPoint point = [[touches anyObject] locationInView:self]; //add a new line segment to our path [self.path addLineToPoint:point]; //update the layer with a copy of the path ((CAShapeLayer *)self.layer).path = self.path.CGPath;&#125; 如果希望沿着不规则路径剪切,可以不用蒙版,把CAShapeLayer当做宿主图层,例如corner角度不一致: 绘制圆角+直角 &gt; 可以通过UIBezierPath api直接绘制,添加到CAShapeLayer (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii; CATextLayer 使用Core text,比UILabel渲染快得多 可以渲染文本或富文本()123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)creadLabelWithTextLayer &#123;//create a text layer CATextLayer *textLayer = [CATextLayer layer]; textLayer.frame = self.labelView.bounds; textLayer.contentsScale = [UIScreen mainScreen].scale; [self.labelView.layer addSublayer:textLayer]; //set text attributes textLayer.alignmentMode = kCAAlignmentJustified; textLayer.wrapped = YES; //choose a font UIFont *font = [UIFont systemFontOfSize:15]; //choose some text NSString *text = @\"Lorem ipsum dolor sit amet, consectetur adipiscing \\ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \\ leo\"; //create attributed string NSMutableAttributedString *string = nil; string = [[NSMutableAttributedString alloc] initWithString:text]; //convert UIFont to a CTFont CFStringRef fontName = (__bridge CFStringRef)font.fontName; CGFloat fontSize = font.pointSize; CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL); //set text attributes NSDictionary *attribs = @&#123; (__bridge id)kCTForegroundColorAttributeName:(__bridge id)[UIColor blackColor].CGColor, (__bridge id)kCTFontAttributeName: (__bridge id)fontRef &#125;; [string setAttributes:attribs range:NSMakeRange(0, [text length])]; attribs = @&#123; (__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor, (__bridge id)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle), (__bridge id)kCTFontAttributeName: (__bridge id)fontRef &#125;; [string setAttributes:attribs range:NSMakeRange(6, 5)]; //release the CTFont we created earlier CFRelease(fontRef); //set layer text textLayer.string = string;&#125; CATransformLayerCAGradientLayer 生成颜色的平滑渐变,绘制使用了硬件加速 array colors必传参数 startPoint &amp; endPoint locations &gt; 非必传12345678910111213141516- (void)creatGradientLayer &#123; //create gradient layer and add it to our container view CAGradientLayer *gradientLayer = [CAGradientLayer layer]; gradientLayer.frame = self.containerView.bounds; [self.containerView.layer addSublayer:gradientLayer]; //set gradient colors gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id) [UIColor yellowColor].CGColor, (__bridge id)[UIColor greenColor].CGColor]; //set locations gradientLayer.locations = @[@0.0, @0.25, @0.5]; //set gradient start and end points gradientLayer.startPoint = CGPointMake(0, 0); gradientLayer.endPoint = CGPointMake(1, 1);&#125; CAReplicatorLayer高效生成许多相似图层123456789101112131415161718192021222324252627- (void)creatReplicatorCircleLaye&#123; //create a replicator layer and add it to our view CAReplicatorLayer *replicator = [CAReplicatorLayer layer]; replicator.frame = self.containerView.bounds; [self.containerView.layer addSublayer:replicator]; //configure the replicator replicator.instanceCount = 10; //apply a transform for each instance CATransform3D transform = CATransform3DIdentity; transform = CATransform3DTranslate(transform, 0, 200, 0); transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1); transform = CATransform3DTranslate(transform, 0, -200, 0); replicator.instanceTransform = transform; //apply a color shift for each instance replicator.instanceBlueOffset = -0.1; replicator.instanceGreenOffset = -0.1; //create a sublayer and place it inside the replicator CALayer *layer = [CALayer layer]; layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f); layer.backgroundColor = [UIColor whiteColor].CGColor; [replicator addSublayer:layer];&#125; CAScrollLayer123- (void)scrollPoint:(CGPoint)p;- (void)scrollRectToVisible:(CGRect)r;@property(readonly) CGRect visibleRect CATiledLayer 为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入 CATiledLayer不同于大部分UIKit和CA方法，它支持多线程绘制，-drawLayer:inContext:中需要注意线程安全 CAEmitterLayer 高性能粒子引擎，用来实时创建粒子动画如：烟雾，火，雨等 CAEAGLLayer 使用OpenGL ES2.0绘制上下文 AVPlayerLayer*⚠️它不是Core Animation框架的一部分，而是AVFoundation,用来在iOS上播放视频，它是高级接口如MPMoviewPlayer的底层实现，提供了显示视频的底层控制。 7.隐式动画 改变UIView的一个可做动画的属性，并没有指定任何动画的类型，然后Core Animation自动让该属性从先前的值平滑过渡到新的值，默认0.25秒的动画 隐式动画默认打开，可以手动关闭 事务：Core Animation基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画，实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值 CA事务由CATransaction来管理,[CATransaction begin] (change) [CATransaction commit],Core Animation在每个run loop周期中自动开始一次新的事务，即使不显示的调用[CATransaction begin]，任何在一次run loop中的属性修改都会被集中起来做0.25s动画 1234567891011121314151617181920212223- (void)changeColor&#123; //begin a new transaction [CATransaction begin]; //transaction content [CATransaction setAnimationDuration:1.0]; //add the spin animation on completion [CATransaction setCompletionBlock:^&#123; //rotate the layer 90 degrees CGAffineTransform transform = self.colorLayer.affineTransform; transform = CGAffineTransformRotate(transform, M_PI_2); self.colorLayer.affineTransform = transform; &#125;]; //randomize the layer background color CGFloat red = arc4random() / (CGFloat)INT_MAX; CGFloat green = arc4random() / (CGFloat)INT_MAX; CGFloat blue = arc4random() / (CGFloat)INT_MAX; self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor; //commit the transaction [CATransaction commit];&#125; 默认情况下，UIKit禁用UIView.layer的隐式动画的，做法是每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值UIView关闭了（也可通过CATransacition setDisableActions：]开关所有属性的隐式动画） UIView关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用UIView的动画函数（而不是依赖CATransaction），或者继承UIView，并覆盖-actionForLayer:forKey:方法，或者直接创建一个显式动画。对于单独存在的图层，我们可以通过实现图层的-actionForLayer:forKey:委托方法，或者提供一个actions字典来控制隐式动画。123456789101112131415161718192021- (void)layerAnimation &#123; self.colorLayer = [CALayer layer]; self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f); self.colorLayer.backgroundColor = [UIColor blueColor].CGColor; //add a custom action CATransition *transition = [CATransition animation]; transition.type = kCATransitionPush; transition.subtype = kCATransitionFromLeft; self.colorLayer.actions = @&#123;@\"backgroundColor\": transition&#125;; //add it to our view [self.layerView.layer addSublayer:self.colorLayer];&#125;- (void)changeColor&#123; //randomize the layer background color CGFloat red = arc4random() / (CGFloat)INT_MAX; CGFloat green = arc4random() / (CGFloat)INT_MAX; CGFloat blue = arc4random() / (CGFloat)INT_MAX; self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;&#125; 呈现树 呈现树：每个图层属性的显示值都被存储在一个叫做呈现图层的独立图层当中，他可以通过-presentationLayer方法来访问（呈现图层的值表示当前屏幕上真正显示出来的值，动画中会不断变化）、 需要用到呈现树的case：同步动画 &amp; 处理交互 1.如果你在实现一个基于定时器的动画，而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了2.果你想让你做动画的图层响应用户输入，你可以使用-hitTest:方法来判断指定图层是否被触摸，这时候对呈现图层而不是模型图层调用-hitTest:会显得更有意义，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置 8.显示动画1.CABasicAnimation当更新属性的时候，我们需要设置一个新的事务，并且禁用图层行为。否则动画会发生两次，一个是因为显式的CABasicAnimation，另一次是因为隐式动画。12345678- (void)animationDidStop:(CABasicAnimation \\*)anim finished:(BOOL)flag&#123; //set the backgroundColor property to match animation toValue [CATransaction begin]; [CATransaction setDisableActions:YES]; self.colorLayer.backgroundColor = (__bridge CGColorRef)anim.toValue; [CATransaction commit];&#125; 2.CAKeyframeAnimation 和CABasicAnimation不一样的是，它不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画 3.虚拟属性 CAPropertyAnimation transform.rotation属性有一个奇怪的问题是它其实并不存在。这是因为CATransform3D并不是一个对象，它实际上是一个结构体，也没有符合KVC相关属性，transform.rotation实际上是一个CALayer用于处理动画变换的虚拟属性 4.CAAnimationGroup CABasicAnimation和CAKeyframeAnimation仅仅作用于单独的属性，而CAAnimationGroup可以把这些动画组合在一起 5.过渡动画 有时候对于iOS应用程序来说，希望能通过属性动画来对比较难做动画的布局进行一些改变。比如交换一段文本和图片，或者用一段网格视图来替换，等等。属性动画只对图层的可动画属性起作用，所以如果要改变一个不能动画的属性（比如图片），或者从层级关系中添加或者移除图层，属性动画将不起作用。 renderInContext截图123UIGraphicsBeginImageContextWithOptions(view.bounds.size, YES, 0.0);[view.layer renderInContext:UIGraphicsGetCurrentContext()];UIImage *coverImage = UIGraphicsGetImageFromCurrentImageContext(); 9.图层时间 CoreAnimation有一个全局时间的概念，也就是所谓的Mach内核时间，CFTimeInterval time = CACurrentMediaTime()，它返回了设备自从上次启动后的秒数，当设备休眠的时候马赫时间会暂停，故该时间不准 对CALayer或者CAGroupAnimation调整duration和repeatCount/repeatDuration属性并不会影响到子动画。但是beginTime，timeOffset和speed属性将会影响到子动画，设置.keyWindow.speed = 0会让所有window上的视图动画停止，当然UIAlertView不会受影响（不在当前keyWindow上） 10.缓冲 动画执行速率，匀速、淡入淡出等 不同动画效果缓冲函数的算法，了解有关缓冲和CAMediaTimingFunction类，它可以允许我们创建自定义的缓冲函数来完善我们的动画，同样了解了如何用CAKeyframeAnimation来避开CAMediaTimingFunction的限制，创建完全自定义的缓冲函数。 CAAnimation &gt; [CATransaction setAnimationTimingFunction:] UIKit &gt; 1234567[UIView animateWithDuration:1.0 delay:0.0 options:UIViewAnimationOptionCurveEaseOut animations:^&#123; //set the position self.colorView.center = [[touches anyObject] locationInView:self.view]; &#125; completion:NULL]; 关键帧动画有一个NSArray类型的timingFunctions属性，但是指定函数的个数一定要等于keyframes数组的元素个数减一，因为它是描述每一帧之间动画速度的函数。 12345678910111213141516&#123; //create a keyframe animation CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; animation.keyPath = @\"backgroundColor\"; animation.duration = 2.0; animation.values = @[ (__bridge id)[UIColor blueColor].CGColor, (__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor greenColor].CGColor, (__bridge id)[UIColor blueColor].CGColor ]; //add timing function CAMediaTimingFunction *fn = [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn]; animation.timingFunctions = @[fn, fn, fn]; //apply animation to layer [self.colorLayer addAnimation:animation forKey:nil];&#125; 11.基于定时器的动画 CADisplayLink &gt; 用法与NSTimer一致，但是NSTimer当错过了时间点会在下一次执行（延后），而CADisplayLink错过了时间点直接丢弃（丢帧） NSRunLoopCommonModes来替代。但是要小心，因为如果动画在一个高帧率情况下运行，你会发现一些别的类似于定时器的任务或者类似于滑动的其他iOS动画会暂停，直到动画结束。同样可以同时对CADisplayLink指定多个run loop模式，于是我们可以同时加入NSDefaultRunLoopMode和UITrackingRunLoopMode来保证它不会被滑动打断，也不会被其他UIKit控件动画影响性能12345678910111213141516171819202122232425262728293031323334353637383940414243- (void)animate&#123; //reset ball to top of screen self.ballView.center = CGPointMake(150, 32); //configure the animation self.duration = 1.0; self.timeOffset = 0.0; self.fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)]; self.toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)]; //stop the timer if it's already running [self.timer invalidate]; //start the timer self.lastStep = CACurrentMediaTime(); self.timer = [CADisplayLink displayLinkWithTarget:self selector:@selector(step:)]; [self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; [self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:UITrackingRunLoopMode];&#125;- (void)step:(CADisplayLink *)timer&#123; //calculate time delta CFTimeInterval thisStep = CACurrentMediaTime(); CFTimeInterval stepDuration = thisStep - self.lastStep; self.lastStep = thisStep; //update time offset self.timeOffset = MIN(self.timeOffset + stepDuration, self.duration); //get normalized time offset (in range 0 - 1) float time = self.timeOffset / self.duration; //apply easing time = bounceEaseOut(time); //interpolate position id position = [self interpolateFromValue:self.fromValue toValue:self.toValue time:time]; //move ball view to new position self.ballView.center = [position CGPointValue]; //stop the timer if we've reached the end of the animation if (self.timeOffset &gt;= self.duration) &#123; [self.timer invalidate]; self.timer = nil; &#125;&#125; 12.性能优化CPU VS GPU关于绘图和动画有两种处理的方式：CPU（中央处理器）和GPU（图形处理器）。在现代iOS设备中，都有可以运行不同软件的可编程芯片，但是由于历史原因，我们可以说CPU所做的工作都在软件层面，而GPU在硬件层面。总的来说，我们可以用软件（使用CPU）做任何事情，但是对于图像处理，通常用硬件会更快，因为GPU使用图像对高度并行浮点运算做了优化。由于某些原因，我们想尽可能把屏幕渲染的工作交给硬件去处理。问题在于GPU并没有无限制处理性能，而且一旦资源用完的话，性能就会开始下降了（即使CPU并没有完全占用）大多数动画性能优化都是关于智能利用GPU和CPU，使得它们合理配合，都不会超出负荷。 渲染服务1.概念：动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。这个进程就是所谓的渲染服务。在iOS5和之前的版本是SpringBoard进程（同时管理着iOS的主屏）。在iOS6之后的版本中叫做BackBoard2.视图/动画渲染的过程一共有6个阶段： 最后两个阶段在动画过程中不停地重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，你真正只能控制前两个阶段：布局和显示。Core Animation框架在内部处理剩下的事务，你也控制不了它。 这并不是个问题，因为在布局和显示阶段，你可以决定哪些由CPU执行，哪些交给GPU去做。 app内部处理的4个阶段 1.布局 - 这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段。 2.显示 - 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的-drawRect:和-drawLayer:inContext:方法的调用路径。 3.准备 - 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。 4.提交 - 这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。 渲染服务进程处理的2个阶段一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做渲染树的图层树。使用这个树状结构，渲染服务对动画的每一帧做出如下工作： 1.对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染 2.在屏幕上渲染可见的三角形 GUP相关操作GPU为一个具体的任务做了优化：它用来采集图片和形状（三角形），运行变换，应用纹理和混合然后把它们输送到屏幕上。现代iOS设备上可编程的GPU在这些操作的执行上又很大的灵活性，但是Core Animation并没有暴露出直接的接口。除非你想绕开Core Animation并编写你自己的OpenGL着色器，从根本上解决硬件加速的问题，那么剩下的所有都还是需要在CPU的软件层面上完成。宽泛的说，大多数CALayer的属性都是用GPU来绘制。比如如果你设置图层背景或者边框的颜色，那么这些可以通过着色的三角板实时绘制出来。如果对一个contents属性设置一张图片，然后裁剪它 - 它就会被纹理的三角形绘制出来，而不需要软件层面做任何绘制。但是有一些事情会降低（基于GPU）图层绘制，比如： 太多的几何结构 - 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数 重绘 - 主要由重叠的半透明图层引起。GPU的填充比率（用颜色填充像素的比率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并任然保持60帧率的渲染（这意味着你可以绘制一个半的整屏的冗余信息，而不影响性能），并且新设备可以处理更多 离屏绘制 - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响 过大的图片 - 如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能GPU屏幕渲染有以下两种方式 On-Screen Rendering 意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行 Off-Screen Rendering 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作 离屏渲染性能差原因相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面： 1.创建新缓冲区 要想进行离屏渲染，首先要创建一个新的缓冲区。2.上下文切换 离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的,涉及到OpenGL的pipeline跟barrier，而且offscreen-render通常在每一帧都会涉及到 造成离屏渲染的原因当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤起了 CPU的offscreen-render使用CPU来完成渲染操纵，通常在你使用： 1.drawRect (如果没有自定义绘制的任务就不要在子类中写一个空的drawRect方法，因为只要实现了该方法，就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale的值，造成资源浪费) 2.使用Core Graphics上面的两种情况使用的就是CPU离屏渲染，首先分配一块内存，然后进行渲染操作生成一份bitmap位图，整个渲染过程会在你的应用中同步的进行，接着再将位图打包发送到iOS里一个单独的进程–render server，理想情况下，render server将内容交给GPU直接显示到屏幕上。 GPU的offscreen-render使用GPU在当前屏幕缓冲区以外开辟一个新的缓冲区进行绘制，通常发生的情况有： 1.设置cornerRadius(&gt; contensCenter/UIBezierPath), masks(&gt; CAShapeLayer), shadows（&gt; shadowPath）,edge antialiasing等 2.设置layer.shouldRasterize ＝ YES CPU相关的操作大多数工作在Core Animation的CPU都发生在动画开始之前。这意味着它不会影响到帧率，所以很好，但是他会延迟动画开始的时间，让你的界面看起来会比较迟钝。以下CPU的操作都会延迟动画的开始时间： 1.布局计算 - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应该是比老版的自动调整逻辑加强了CPU的工作。 2.视图懒加载 - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图从一个nib文件中加载，或者涉及IO的图片显示，都会比CPU正常操作慢得多。 3.Core Graphics绘制 - 如果对视图实现了-drawRect:方法，或者CALayerDelegate的-drawLayer:inContext:方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。 4.解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用UIImageView）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间 当图层被成功打包，发送到渲染服务器之后，CPU仍然要做如下工作：为了显示屏幕上的图层，Core Animation必须对渲染树种的每个可见图层通过OpenGL循环转换成纹理三角板。由于GPU并不知晓Core Animation图层的任何结构，所以必须要由CPU做这些事情。这里CPU涉及的工作和图层个数成正比，所以如果在你的层级关系中有太多的图层，就会导致CPU每一帧的渲染，即使这些事情不是你的应用程序可控的。 IO相关操作上下文中的IO（输入/输出）指的是例如闪存或者网络接口的硬件访问。一些动画可能需要从闪存（甚至是远程URL）来加载。一个典型的例子就是两个视图控制器之间的过渡效果，这就需要从一个nib文件或者是它的内容中懒加载，或者一个旋转的图片，可能在内存中尺寸太大，需要动态滚动来加载。IO比内存访问更慢，所以如果动画涉及到IO，就是一个大问题。总的来说，这就需要使用聪敏但尴尬的技术，也就是多线程，缓存和投机加载（提前加载当前不需要的资源，但是之后可能需要用到） 测试哪些点动画性能 一定要用真机测试（CPU往往比iOS设备要快。相反，GPU和iOS设备的完全不一样，模拟器不得已要在软件层面（CPU）模拟设备的GPU，这意味着GPU相关的操作在模拟器上运行的更慢，尤其是使用CAEAGLLayer来写一些OpenGL的代码时候） 一定要用发布模式，而不是调试模式（编译器会引入一系列提高性能的优化，例如去掉调试符号或者移除并重新组织代码 最好在你支持的设备中性能最差的设备上测试 iOS性能优化当你碰到性能问题的时候（WWDC2014） 是否受到CPU或者GPU的限制？ 是否有不必要的CPU渲染？ 是否有太多的离屏渲染操作？ 是否有太多的图层混合操作？ 是否有奇怪的图片格式或者尺寸？ 是否涉及到昂贵的view或者效果？ view的层次结构是否合理？ tips:1.Blending : 避免使用透明/半透明颜色效果，需要计算该视图透视的下面的图，对性能又影响2.OffScreen-render: 1.避免离屏渲染cornerRadius, masks, shadows,edge antialiasing，layer.shouldRasterize ＝ YES等会造成离屏渲染 cornerRadius,mask &gt; CG绘制 shadows &gt; shadowPath:[UIBezierPath bezierPathWithRect:view.bounds].CGPath; 2.对于不可避免的离屏渲染使用shouldRasterize = YES缓存，避免重复创建缓存区会把被光栅化的图层保存成bitmap并缓存起来，其中圆角或者阴影之类的效果也是直接保存到位图当中，当需要渲染到屏幕上的时候只需要到缓存中去取对应的位图进行显示就行了，相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用，加快了整个渲染过程。光栅化对于那些有很多子view嵌套在一起、view的层级复杂或者有很复杂特效效果的图层有很明显的提升，因为这些内容都被缓存到位图当中了。光栅化应用⚠️ 适用于内容基本不变的图层假如图层的内容经常变化，比如cell里面有涉及到动画之类的，那么缓存的内容就无效了，GPU需要重新创建缓存区，导致离屏渲染，这又涉及到OpenGL的上下文环境切换，反而降低性能。 不要过度使用缓存区的大小被设置为屏幕大小的2.5倍，假如过分使用同样会导致大量的离屏渲染。 如果缓存的内容超过100ms没有被使用则会被回收。123456789101112131415- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //dequeue cell UITableViewCell *cell = [self.tableView dequeueReusableCellWithIdentifier:@\"Cell\" forIndexPath:indexPath]; ... //set text shadow cell.textLabel.backgroundColor = [UIColor clearColor]; cell.textLabel.layer.shadowOffset = CGSizeMake(0, 2); cell.textLabel.layer.shadowOpacity = 0.5; //rasterize cell.layer.shouldRasterize = YES; cell.layer.rasterizationScale = [UIScreen mainScreen].scale; return cell;&#125; 3.其他延迟加载图片(图片加载的极限优化方式：FastImageCache)123456UIImage *downloadedImage = ...; [self.avatarImageView performSelector:@selector(setImage:) withObject:downloadedImage afterDelay:0 inModes:@[NSDefaultRunLoopMode]];` 13.高效绘图软件绘图术语绘图通常在Core Animation的上下文中指代软件绘图（意即：不由GPU协助的绘图）。在iOS中，软件绘图通常是由Core Graphics框架完成来完成。但是，在一些必要的情况下，相比Core Animation和OpenGL，Core Graphics要慢了不少。 软件绘图不仅效率低，还会消耗可观的内存。CALayer只需要一些与自己相关的内存：只有它的寄宿图会消耗一定的内存空间。即使直接赋给contents属性一张图片，也不需要增加额外的照片存储大小。如果相同的一张图片被多个图层作为contents属性，那么他们将会共用同一块内存，而不是复制内存块。 但是一旦你实现了CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽 图层高 4字节，宽高的单位均为像素。对于一个在Retina iPad上的全屏图层来说，这个内存量就是 2048 1526 4字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配。 软件绘图的代价昂贵，除非绝对必要，你应该避免重绘你的视图。提高绘制性能的秘诀就在于尽量避免去绘制。 矢量绘图矢量绘图包含一下这些： 任意多边形（不仅仅是一个矩形） 斜线或曲线 文本 渐变 脏矩形为了减少不必要的绘制，Mac OS和iOS设备将会把屏幕区分为需要重绘的区域和不需要重绘的区域。那些需要重绘的部分就叫脏区域 -setNeedsDisplayInRect: &gt; 指定脏区域 CGRectIntersectsRect() &gt; 避免重绘覆盖已更新过的区域 异步绘制Core Animation提供了一些选择： 1.CATiledLayer:有趣的特性：在多个线程中为每个小块同时调用-drawLayer:inContext:方法。这就避免了阻塞用户交互而且能够利用多核心新片来更快地绘制。 2.drawsAsynchronously属性：iOS6之后，layer引入drawsAsynchronously属性，对传入-drawLayer:inContext:的CGContext进行改动，允许CGContext延缓绘制命令的执行以至于不阻塞用户交互。它与CATiledLayer使用的异步绘制并不相同。它自己的-drawLayer:inContext:方法只会在主线程调用，但是CGContext并不等待每个绘制命令的结束。相反地，它会将命令加入队列，当方法返回时，在后台线程逐个执行真正的绘制。这个特性在需要频繁重绘的视图上效果最好（如TableViewCell） 14.图像IO 1.异步处理 2.避免延迟解压：[UIImage imageNamed:]立即解压，并且缓存，但只针对app资源库中的图片有效 3.第三种方式就是绕过UIKit，使用CGImageSourceRef加载图片，像下面这样使用ImageIO框架： 12345678NSInteger index = indexPath.row;NSURL *imageURL = [NSURL fileURLWithPath:self.imagePaths[index]];NSDictionary *options = @&#123;(__bridge id)kCGImageSourceShouldCache: @YES&#125;; CGImageSourceRef source = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, NULL);CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, 0,(__bridge CFDictionaryRef)options);UIImage *image = [UIImage imageWithCGImage:imageRef]; CGImageRelease(imageRef);CFRelease(source); 4.使用CATiledLayer可以用来异步加载和显示大型图片，而不阻塞用户输入 缺点是： CATiledLayer的队列和缓存算法没有暴露出来，所以我们只能祈祷它能匹配我们的需求。 CATiledLayer需要我们每次重绘图片到CGContext中，即使它已经解压缩，而且和我们单元格尺寸一样（因此可以直接用作图层内容，而不需要重绘）。 5.分辨率交换视网膜分辨率代表了人的肉眼在正常视角距离能够分辨的最小像素尺寸。但是这只能应用于静态像素。当观察一个移动图片时，人眼就会对细节不敏感，对于移动的视图可以添加低质量的图片 6.缓存 [UIImage imageNamed:]有缓存机制，但是并不适用任何情况 [UIImage imageNamed:]方法仅仅适用于在应用程序资源束目录下的图片，从网络或者是用户的相机中获取就没法用了。 [UIImage imageNamed:]缓存用来存储应用界面的图片。如果对照片这种大图也用这种缓存，那么iOS系统就很可能会移除这些图片来节省内存。那么在切换页面时性能就会下降，因为这些图片都需要重新加载。 [UIImage imageNamed:]缓存机制并不是公开的，所以你不能很好地控制它。例如，你没法做到检测图片是否在加载之前就做了缓存，不能够设置缓存大小，当图片没用的时候也不能把它从缓存中移除。 7.自定义缓存NSCache，用法和NSDictionary相似，-setObject:forKey:和-object:forKey:方法分别来插入，检索。NSCache在系统低内存的时候自动丢弃存储的对象。可以通过-setCountLimit:方法设置缓存大小，以及-setObject:forKey:cost:来对每个存储的对象指定消耗的值,值越高，丢弃优先级越低。可以用-setTotalCostLimit:方法来指定全体缓存的尺寸 8.文件格式图片格式全解析 15.图层性能隐式绘制 1.使用特性的图层属性 2.特定的视图 3.特定的图层子类 文本尝试用CATextLayer Core Text绘制 光栅化开启shouldRasterize后,CALayer会被光栅化为bitmap,layer的阴影等效果也会被保存到bitmap中。但只能用在图像内容不变的前提下 光栅化两个特点： 系统限制了缓存的大小为2.5X Screen Size. 被光栅化的图片如果超过100ms没有被使用,则会被移除 需要注意三点问题： 如果我们更新已光栅化的layer,会造成大量的offscreen渲染。 用于避免静态内容的复杂特效的重绘 用于避免多个View嵌套的复杂View的重绘。 离屏渲染 圆角（cornerRadius和maskToBounds独立作用的时候都不会有太大的性能问题，但是当他俩结合在一起，就触发了屏幕外渲染） 图层蒙板 阴影 解决办法：CAShapeLayer，contentsCenter或者shadowPath 混合和过度绘制解决办法： 给视图的backgroundColor属性设置一个固定的，不透明的颜色（superView） 设置opaque属性为YES 减少图层数量 裁切(从subLayer移除) 图层在屏幕边界之外，或是在父图层边界之外。 完全在一个不透明图层之后。 完全透明 视图对象回收UITableView/UICollectionView Core Graphics绘制复杂的视图层级(多个UILabel或者UIImageView实例去显示固定内容),你可以把他们全部替换成一个单独的视图，然后用-drawRect:方法绘制出来 -renderInContext:[layer renderInContext:]你可以将图层及其子图层快照进一个Core Graphics上下文然后得到一个图片，它可以直接显示在UIImageView中，或者作为另一个图层的contents。不同于shouldRasterize —— 要求图层与图层树相关联 —— ，这个方法没有持续的性能消耗。 16.曲线1.贝塞尔曲线2.Quartz2DQuartz 2D是一个二维绘图引擎，同时支持iOS和Mac系统 Quartz2D提供了以下几种类型的Graphics Context： Bitmap Graphics Context 位图上下文，在这个上下文上绘制或者渲染的内容，可以获取成图片（需要主动创建一个位图上下文来使用，使用完毕，一定要销毁） PDF Graphics Context Window Graphics Context Layer Graphics Context 图层上下文，针对UI控件的上下文Printer Graphics Context 总结学习了使用Core Animation图层可能遇到的性能瓶颈，并讨论了如何避免或减小压力。你学习了如何管理包含上千虚拟图层的场景（事实上只创建了几百个）。同时也学习了一些有用的技巧，选择性地选取光栅化或者绘制图层内容在合适的时候重新分配给CPU和GPU。这些就是我们要讲的关于Core Animation的全部了（至少可以等到苹果发明什么新的玩意儿）","categories":[],"tags":[{"name":"Core Animation","slug":"Core-Animation","permalink":"https://haojiaqiang.github.io/tags/Core-Animation/"}]},{"title":"大话设计模式","slug":"Design-Pattern-Odyssey","date":"2016-11-20T12:34:28.000Z","updated":"2018-11-21T14:27:47.008Z","comments":true,"path":"2016/11/20/Design-Pattern-Odyssey/","link":"","permalink":"https://haojiaqiang.github.io/2016/11/20/Design-Pattern-Odyssey/","excerpt":"","text":"设计模式总结之模式分类文章 原则 1.策略模式特点：规则封装，统一接口 2.单一职责原则特点：界面/逻辑代码分离 3.开放-封闭原则特点：封闭更改+开放扩展 4.依赖倒转原则A.高层模块不依赖低层模块，两个都应该依赖抽象-面向接口编程而不是依赖具体实现编程;B.抽象不依赖细节，而是细节依赖抽象-抽出逻辑，填充任意内容Ps：里氏代换原则：子类具有完整的父类功能，可以用子类完全替换父类 5.迪米特法则（LoD），最少指示原则描述：如果两个类不必彼此直接通信，那么这两个类就不应当直接的相互作用。此时通信可通过第三者转发类之间的松耦合-&gt;对外暴露相同业务类统一抽象的接口/管理类，通信由接口类统一管理 接口 == OC协议作用 1.工厂模式 关系:简单工厂模式 &gt; 工厂模式 &gt; 抽象工厂模式 1.1简单工厂模式特点：单独功能单独封装，一个功能一个类 1.2 工厂模式特点：定义一个统一的用于创建对象的类，让子类决定去实例化哪&gt; 一个类，类的实例化推迟到子类 1.3 抽象工厂模式特点：将一组具有同一主题的单独的工厂，封装成一个抽象接口类 2.装饰模式特点：核心职责和装饰功能分开，封装装饰功能，随用随穿 3.代理模式特点：为其他对象提供一种代理以控制对这个对象的访问，就是一种引用方法的类型。 4.原型模式特点：从一个一已生成的对象再创建copy另外一个可定制的对象。 意义：无需重复调用耗能的对象构造函数，隐藏内部创建细节。 ps深浅复制：拷贝对象与拷贝指针 5.模版方法模式特点：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中 &gt; 使子类可以在不改变算法结构的基础上实现特色的细节。 不变统一的抽到父类，差异化的具体到子类中分别实现 - 逆继承 6.外观（Facade）模式描述：提供一个抽象类，为子系统中的一组接口提供一致的高层接口 方便管理/统一维护 7.建造者模式描述：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 构建过程-抽取构建抽象类定义依次构建的方法；不同-构建方法具体在不同的子类中不同的实现。分离-定义一个抽象的指挥类供外部调用，隐藏具体构建过程 8.观察者/发布订阅模式描述：多对1的关系，让多个观察者对象同时监听某一个主题。这个主题对象在状态发生变化时，会通知所有观察者对象，是他们能够自动更新自己。 依赖倒转原则-发布者抽象类，订阅者抽象类。意义：解藕，双方无需知道对方是谁，只依赖抽象建立联系，而非具体实现。 9.反射模式特点：字符串 类 10.状态模式描述：对象的行为取决于它的状态，可以将状态的判断和该状态下的相关行为封装成单独的对象，以消除庞大的判断语句，且对不同状态达到解藕 11.适配器模式描述：将一个类的接口转换成另外一个接口，统一接口，简单直接，便于维护。 意义：Adapter模式使得原来不兼容而不能一起工作的那些类可以一起工作。 12.备忘录模式描述：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 13.组合模式描述：将对象组合成树形结构以表示“部分-整体”的层次结构。使得单个对象和组合对象的使用具有一致性，外部调用使用同样的接口，由枝叶自行递归。 14.迭代器模式描述：集合遍历-first/next/isDone/currentItem/direction 15.单例模式描述：保证一个类仅有一个实例，并提供一个访问它的全局访问点。1234567891011121314Public static Singleton getInstance() &#123; If （instance == nil） &#123; lock (syncRoot) &#123; if （instance == nil） &#123; Instance == new Singleton() &#125; &#125; &#125; return instance;&#125; 16.桥接模式描述：将抽象部分与它的实现部分分离，使他们都可以独立的变化。 抽象super api，具体子类通过api实现区别开来,抽象的super之间关联。尽量使用合成/聚合，少用类继承。使用继承时，先通过判断is a super类 17.命令模式描述：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排列活记录请求日志，以及支持可撤销的操作。 命令模式把请求一个操作的对象与知道怎么执行该操作的对象分割开。 优点： 1.能比较容易的设计一个命令队列 2.在需要的情况下，可以比较容易的将命令计入日志 3.允许接受请求的一方决定是否要否决请求 4.可以容易的实现请求的撤销和重做 5.由于加进新的具体命令类不影响其他类，因此增加新的命令类很容易 18.职责链模式描述：是多个对象都有机会处理请求，从而避免请求的发送和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。1234567891011Manager &#123; Manager : superior;//无法处理时时向上传递 handleMethod；//处理方法 &#123; If(canHandle) &#123; Handle; &#125; else if (self.superior) &#123; (self.superior handle) &#125; else &#123; //无法处理 &#125;&#125; 19.中介者模式描述：用一个中介对象来封装一些列的对象交互。中介者使各对象不需要显示的相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互。 优点：减少不需要直接通信类之间的耦合(迪米特法则)，通讯集中处理，易于统一管理缺点：如果中介者需要管理的需要通讯的类太多，中介者本身会过于臃肿 20.享元模式 Flyweight描述：运用共享技术有效地支持大量细粒度的对象特点： 享元工厂Flyweight Factory &gt; 创建并管理Flyweight对象，合理的提供一个已创建或新创建的Flyweight对象给调用者 享元对象Flyweight 内部不随环境改变而改变的部分为共享部分，称为内部状态；随环境改变而改变的不可共享部分，称为外部状态。 21.解释器模式定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。描述：解释器接收调用者发送的文本消息，解释该文本消息成定义好的行为并执行 22.访问者模式Visitor定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。示例：男人 女人，失败 恋爱 成功 访问者模式适用于数据结构相对稳定的系统，它把数据结构和作用于数据结构之上的操作之间的耦合解开，使得操作集合可以相对自由的演化 优点是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者 缺点是增加新的数据结构变的困难","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://haojiaqiang.github.io/tags/设计模式/"}]},{"title":"Algorithms","slug":"Algorithms","date":"2016-09-30T06:08:23.000Z","updated":"2020-11-19T08:46:06.542Z","comments":true,"path":"2016/09/30/Algorithms/","link":"","permalink":"https://haojiaqiang.github.io/2016/09/30/Algorithms/","excerpt":"","text":"部分算法实现动态效果animation展示数据结构与算法实现 基础二分查找有序数组 &gt; 取value[mid]比较获知目标值的位置在low区还是high区 &gt; 每次查找的数组范围都是上次的1/2 数据抽象数据类型一组值和一组对这些值的操作的集合 背包、队列和栈 背包：无序，只能添加不能移除 加减乘除+括号的最基本算法实现 用两个栈（操作数栈和运算符栈） 将操作数压入操作数栈 将运算符压入运算符栈 忽略左括号 当遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈 链表 定义：链表是一种递归的数据结构，它或者为空（null)，或者指向一个节点(node）的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用（最后一个 next == null） 字符串对象JAVA中，字符串对象会使用40字节（16字节表示对象，三个int类型的实例变量各需4字节，加上字符数组引用的8字节（64位）和4个填充字节），这是除字符数组之外字符串所需的内存空间，所有字符所需的内存需要另计，因此字符串的char数组常常实在多个字符串对象之间共享的，这种设计能个在多个对象都含有相同的value[]数组时节省内存。 子字符串由原字符串通过subString方法创建的字符串，仍然重用原字符串中的字符串数组value[],只需要改变对应的偏移量和长度域即可 算法增长数量级表 描述 增长的数量级 典型的代码 说明 举例 常数级别 1 a = b + c 普通语句 将两个数相加 对数级别 log N 二分查找 二分策略 二分查找 线性级别 N double max = a[0];for (int i = 1; i &lt; N; i++) if (a[i] &gt; max) max = a[i]; 循环 找出最大元素 线性对书级别 N log N 分治 归并排序 平方级别 N² for (int i =0; i &lt; N; i ++)for (int j = i+1; j &lt; N; j++)if (a[i] + a[j] == 0)cnt++; 双层循环 检查所有元素对 立方级别 N³ 三层循环 检查所有三元组 指数级别 2^N 穷举查找 检查所有子集 不成熟的优化时所有罪恶之源 – 快速排序发明人Knuth代码要清晰正确，之后再考虑应用场景和频率做性能优化（优化经常会产生复杂而难以理解的代码） 树定义一棵树的大小是它的节点的数量。树中的一个节点的深度是它到根节点的路径上的连接数。树的高度是它的所有节点中的最大深度。 排序Gif power by visualgo.net 各种排序方式的对比 空间复杂度冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为O(1),因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引) 快速排序空间复杂度为logn(因为递归调用了) ,归并排序空间复杂是O(n),需要一个大小为n的临时数组. 基数排序的空间复杂是O(n),桶排序的空间复杂度不确定 最快的排序算法是桶排序所有排序算法中最快的应该是桶排序(很多人误以为是快速排序,实际上不是.不过实际应用中快速排序用的多)但桶排序一般用的不多,因为有几个比较大的缺陷: 待排序的元素不能是负数,小数. 空间复杂度不确定,要看待排序元素中最大值是多少 所需要的辅助数组大小即为最大元素的值 冒泡排序实现方式 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重複上面的步骤，直到没有任何一对数字需要比较。 特点 时间复杂度：O(n) ～ O(n²) 性能非常差 示例C1234567891011121314151617/** 冒泡排序 */NSArray *bubbleSort(NSArray *unSortedArray) &#123; // please check array if has uncomparable value first NSComparisonResult order = NSOrderedAscending; NSMutableArray *processArrayM = [unSortedArray mutableCopy]; NSInteger arrayCount = processArrayM.count; for (NSInteger lastIndex = 0; lastIndex &lt; arrayCount; lastIndex++) &#123; for (NSInteger j = 0; j &lt; arrayCount - lastIndex - 1; j++) &#123; if ([processArrayM[j +1] compare:processArrayM[j]] == order) &#123; // 将整个队列中相邻的元素做比较，将较小的元素和较大的元素交换位置 id temp = processArrayM[j]; processArrayM[j] = processArrayM[j + 1]; processArrayM[j +1] = temp; &#125; &#125; &#125; return [processArrayM copy];&#125; 选择排序(在剩下的元素中找到最小的元素)实现方式首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 特点 运行时间和输入无关 (N-1)+(N-2)+…+2+1=N(N-1)/2 ~ N²次比较 数据移动是最少的 每次只会改变2个元素的值，依次选择排序用了N次交换——交换次数和数组的大小是线性关系 示例1234567891011121314151617181920212223242526272829303132/** 选择排序 */- (NSArray *)selectSortArray:(NSArray *)unSortedArray &#123; NSComparisonResult order = NSOrderedAscending; NSMutableArray *precessArrayM = [NSMutableArray arrayWithArray:unSortedArray]; NSInteger arrayCount = precessArrayM.count; // indicator BOOL showIndicator = YES; NSInteger compareTimes = 0, exchangeTimes = 0; for (int i = 0; i &lt; arrayCount - 1; i++) &#123; for (int j = i + 1; j &lt; arrayCount; j++) &#123; id value = precessArrayM[i]; id nextValue = precessArrayM[j]; // check value NSAssert([value respondsToSelector:@selector(compare:)] &amp;&amp; [nextValue respondsToSelector:@selector(compare:)], @&quot;array with uncomparable value&quot;); if (showIndicator) compareTimes++; NSComparisonResult comparisonResult = [nextValue compare:value];//考虑same情况反向对比可稍微提高性能 if (comparisonResult == order) &#123; id temp = precessArrayM[i]; precessArrayM[i] = precessArrayM[j]; precessArrayM[j] = temp; if (showIndicator) exchangeTimes++; &#125; &#125; &#125; if (showIndicator) NSLog(@&quot;%s arrayCount = %ld, compareTimes = %ld, exchangeTimes = %ld&quot;, __func__, arrayCount, compareTimes, exchangeTimes); return [NSArray arrayWithArray:precessArrayM];&#125; 直接插入排序实现方式 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 注：如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。 特点 所需时间取决于输入中元素的起始顺序，对于一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行的排序要快的多 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小-1；平均需要～N² /4次比较和～N² /4次交换。最坏情况下需要～N² /2次比较和～N² /2次交换，最好情况下需要N-1次比较和0次交换示例 1234567891011121314151617181920212223/** 插入排序 */- (NSArray *)insertSortArray:(NSArray *)unSortedArray &#123; NSComparisonResult order = NSOrderedAscending; NSMutableArray *processArrayM = [NSMutableArray arrayWithArray:unSortedArray]; NSInteger arrayCount = processArrayM.count; // check array if has uncomparable value for (NSInteger i = 1; i &lt; arrayCount; i++) &#123; id preValue = processArrayM[i -1]; id value = processArrayM[i]; NSComparisonResult comparisonResult = [value compare:preValue];//考虑same情况反向对比可稍微提高性能 if (comparisonResult == order) &#123; NSInteger insertIndex = i; while (insertIndex &gt; 0 &amp;&amp; [value compare:processArrayM[insertIndex - 1]] == order) &#123;// 将从起始位置start，i为end的已排序部分从高位开始依次往后移动一位,直到正好插入i元素的index processArrayM[insertIndex] = processArrayM[insertIndex - 1];// 整体右移已排序部分 insertIndex--; &#125; processArrayM[insertIndex] = value; &#125; &#125; return [NSArray arrayWithArray:processArrayM];&#125; 希尔排序特点 希尔排序的实质就是分组插入排序，该方法又称缩小增量排序；是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 时间复杂度：其最坏时间复杂度依然为O(n²)示例 123456789101112131415void shellSort(int array[], int arrayLength) &#123; int gap = 0, i = 0, j = 0, temp = 0; for (gap = arrayLength &gt;&gt; 1; gap &gt; 0; gap &gt;&gt; 1) &#123; for (i = gap; i &lt; arrayLength; i++) &#123; temp = array[i]; for (j = i - gap; j &gt;= 0 &amp;&amp; array[j] &gt; temp; j -= gap) &#123; array[j + gap] = array[j]; &#125; array[j + gap] = temp; &#125; &#125;&#125; 归并排序定义归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer)的一个非常典型的应用。递归分解数组（until子数组只有一个数据时，即可将该子数组视作有序），再（依次）合并(all有序的子)数组就完成了归并排序 实现方式递归法（Top-down） 1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 2.设定两个指针，最初位置分别为两个已经排序序列的起始位置 3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 4.重复步骤3直到某一指针到达序列尾 5.将另一序列剩下的所有元素直接复制到合并序列尾 迭代法（Bottom-up） 1.将序列每相邻两个数字进行归并操作，形成 ceil(n/2)个序列（数组共有n个元素），排序后每个序列包含两/一个元素 2.若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4) 个序列，每个序列包含四/三个元素 3.重复步骤2，直到所有元素排序完毕，即序列数为1 特点 时间复杂度：O(NlogN) 主要缺点：所需的额外空间和N成正比 示例1234567891011121314151617181920212223242526272829303132void merge_sort(int array[], const int length) &#123; int processArray[length]; merge_sort_recursive(array, processArray, 0, length - 1);&#125;void merge_sort_recursive(int array[], int processArray[], int start, int end) &#123; if (start &gt;= end) return; int length = end - start, mid = (length &gt;&gt; 1) + start; int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; merge_sort_recursive(array, processArray, start1, end1); merge_sort_recursive(array, processArray, start2, end2); // 合并有序子数组 int k = start; while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) &#123; processArray[k++] = array[start1] &lt; array[start2] ? array[start1++] : array[start2++]; &#125; while (start1 &lt;= end1) &#123; processArray[k++] = array[start1++]; &#125; while (start2 &lt;= end2) &#123; processArray[k++] = array[start2++]; &#125; for (k = start; k &lt;= end; k++) &#123; array[k] = processArray[k]; &#125;&#125; 快速排序(划分交换排序)实现方式 从数列中挑出一个元素，称为”基准值”（pivot）， 重新排序数列（避免选到最边缘值），所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 特点 时间复杂度：O(nlogn) ~ O(n²)，但最坏情况并不常见,通常明显比其他算法块，因为它内部循环在大部分架构上很有效率的达成 工程角度有较大优化空间： 1.对于小数组，快速排序比插入排序慢（多数&lt;15个元素）2.三取样切分3.熵最优排序 示例12345678910111213141516171819202122232425262728293031323334353637383940void quick_sort(int array[], int length) &#123; quick_sort_recursive(array, 0, length - 1);&#125;void quick_sort_recursive(int array[], int start, int end) &#123; if (start &gt;= end) return;// 递归出口 int standardValue = array[end]; // 对比参考值 int left = start, right = end - 1; while (left &lt; right) &#123; while (array[left] &lt; standardValue &amp;&amp; left &lt; right)// 依次找出左分组中&gt;对比值的index left &#123; left++; &#125; while (array[right] &gt;= standardValue &amp;&amp; left &lt; right)// 依次找出右分组中&lt;=对比值的index right &#123; right--; &#125; swap(&amp;array[left], &amp;array[right]);// 对调当前左右分组中不符合项的一对value &#125; if (array[left] &gt;= array[end]) // left &amp;&amp; right游动index汇合处 &#123; swap(&amp;array[left], &amp;array[end]); &#125; else &#123; left++; &#125; if (left) &#123; quick_sort_recursive(array, start, left - 1);// 左分组递归分组并归类 &#125; quick_sort_recursive(array, left + 1, end);// 右分组递归分组并归类&#125;void swap(int *x, int *y) &#123; int t = *x; *x = *y; *y = t;&#125; 堆排序 时间复杂度 O(NlogN) 123456789101112131415161718192021222324252627282930313233343536373839404142434445//堆排序主要算法void HeapSort(int array[], int length)&#123; //1.构建大顶堆 for (int i = length/2-1;i &gt;= 0;i--) &#123; //put the value in the final position adjustHeap(array, i, length); &#125; //2.调整堆结构+交换堆顶元素与末尾元素 for (int j = length-1;j &gt; 0;j--) &#123; //堆顶元素和末尾元素进行交换 int temp = array[0]; array[0] = array[j]; array[j] = temp; adjustHeap(array, 0, j);//重新对堆进行调整 &#125;&#125;//大根堆进行调整void adjustHeap(int array[], int start, int end)&#123; int temp = array[start]; for (int k = start * 2 + 1;k &lt; end;k = k * 2 + 1) &#123; //如果右边值大于左边值，指向右边 if (k + 1 &lt; end &amp;&amp; array[k]&lt; array[k + 1]) &#123; k++; &#125; //如果子节点大于父节点，将子节点值赋给父节点,并以新的子节点作为父节点（不用进行交换） if (array[k] &gt; temp) &#123; array[start] = array[k]; start = k; &#125; else &#123; break; &#125; &#125; //put the value in the final position array[start] = temp;&#125; 优先队列注意优先队列是基于堆的完全二叉树，它和队列的概念无关。（它并不是队列，而是树）优先队列最重要的操作就是： 删除最大元素和插入元素 表排序定义一个指针数组做为表。排序的时候，数组位置上的数值不变，改变的是指针的指向。 如该图，初始数值：f d c a g b h e 开始时，比较f&gt;d，则指针0指向d，指针1指向f。之后比较f&gt;c，d&gt;c，则指针0指向c,指针1指向d，指针2指向f。以此类推，最终指针0指向a的位置(即table[0]=3，A[3]那个位置) 时间复杂度： T = O( m N ) ，m 是每个A元素的复制时间。 桶排序(Bucket sort)桶排序或所谓的箱排序的原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来 排序过程： 假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶 将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序 将各个桶中的数据有序的合并起来 基数排序基本思想：比如十进制数字排序，先按个位数大小排，再按十位数大小排，依次。举例如下： 基数排序可以用来进行多关键字排序。如扑克牌：花色和数字大小两种关键字。 查找树定义树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 特点 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 一棵N个结点的树有N-1条边。 对于任一二叉树，有关系N0 = N2 + 1(其中N0为叶结点树，N2为度为2的结点树)种类 无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树； 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树； 二叉树：每个节点最多含有两个子树的树称为二叉树； 完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。即从根到倒数第二层为完美二叉树，只有叶结点可能缺失，而且缺失的仅仅是右侧连续的叶结点，左侧叶结点连续不中断； 完美/满二叉树：所有叶节点都在最底层的完全二叉树。即不缺任何结点，表示为深度为d则有2d-1 - 1个结点； 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树； 哈夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树； B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。 存储顺序存储结构 序号：根起始为1，按从上到下、从左到右依次+1； 对于有n个结点的完全二叉树的结点父子关系： 非根结点(i&gt;1)的父结点的序号是i/2； 结点(序号为i)的左孩子结点的序号是2i(若2i&lt;=n,否则没有左孩子); 结点(序号为i)的右孩子结点的序号是2i+1(若2i+1&lt;=n,否则没有右孩子)； 父节点表示法存储结构123456789101112/* 树节点的定义 */#define MAX_TREE_SIZE 100typedef struct&#123; TElemType data; int parent; /* 父节点位置域 */&#125; PTNode;typedef struct&#123; PTNode nodes[MAX_TREE_SIZE]; int n; /* 节点数 */&#125; PTree; 基本操作设已有链队列类型LinkQueue的定义及基本操作（参见队列） 构造空树清空或销毁一个树也是同样的操作123void ClearTree(PTree *T)&#123; T-&gt;n = 0;&#125; 构造树123456789101112131415161718192021222324252627282930313233343536void CreateTree(PTree *T)&#123; LinkQueue q; QElemType p,qq; int i=1,j,l; char c[MAX_TREE_SIZE]; /* 临时存放孩子节点数组 */ InitQueue(&amp;q); /* 初始化队列 */ printf(&quot;请输入根节点(字符型，空格为空): &quot;); scanf(&quot;%c%*c&quot;,&amp;T-&gt;nodes[0].data); /* 根节点序号为0，%*c吃掉回车符 */ if(T-&gt;nodes[0].data!=Nil) /* 非空树 */ &#123; T-&gt;nodes[0].parent=-1; /* 根节点无父节点 */ qq.name=T-&gt;nodes[0].data; qq.num=0; EnQueue(&amp;q,qq); /* 入队此节点 */ while(i&lt;MAX_TREE_SIZE&amp;&amp;!QueueEmpty(q)) /* 数组未满且队不空 */ &#123; DeQueue(&amp;q,&amp;qq); /* 节点加入队列 */ printf(&quot;请按长幼顺序输入节点%c的所有孩子: &quot;,qq.name); gets(c); l=strlen(c); for(j=0;j&lt;l;j++)&#123; T-&gt;nodes[i].data=c[j]; T-&gt;nodes[i].parent=qq.num; p.name=c[j]; p.num=i; EnQueue(&amp;q,p); /* 入队此节点 */ i++; &#125; &#125; if(i&gt;MAX_TREE_SIZE)&#123; printf(&quot;节点数超过数组容量\\n&quot;); exit(OVERFLOW); &#125; T-&gt;n=i; &#125; else T-&gt;n=0; &#125; 判断树是否为空1234Status TreeEmpty(PTree *T)&#123; /* 初始条件：树T存在。操作结果：若T为空树，则返回TRUE，否则返回FALSE */ return T-&gt;n==0;&#125; 获取树的深度123456789101112131415int TreeDepth(PTree *T)&#123; /* 初始条件：树T存在。操作结果：返回T的深度 */ int k,m,def,max=0; for(k=0;k&lt;T-&gt;n;++k)&#123; def=1; /* 初始化本节点的深度 */ m=T-&gt;nodes[k].parent; while(m!=-1)&#123; m=T-&gt;nodes[m].parent; def++; &#125; if(max&lt;def) max=def; &#125; return max; /* 最大深度 */&#125; 获取根节点12345678TElemType Root(PTree *T)&#123; /* 初始条件：树T存在。操作结果：返回T的根 */ int i; for(i=0;i&lt;T-&gt;n;i++) if(T-&gt;nodes[i].parent&lt;0) return T-&gt;nodes[i].data; return Nil;&#125; 获取第i个节点的值1234567TElemType Value(PTree *T,int i)&#123; /* 初始条件：树T存在，i是树T中节点的序号。操作结果：返回第i个节点的值 */ if(i&lt;T-&gt;n) return T-&gt;nodes[i].data; else return Nil;&#125; 改变节点的值12345678910111213Status Assign(PTree *T,TElemType cur_e,TElemType value)&#123; /* 初始条件：树T存在，cur_e是树T中节点的值。操作结果：改cur_e为value */ int j; for(j=0;j&lt;T-&gt;n;j++) &#123; if(T-&gt;nodes[j].data==cur_e) &#123; T-&gt;nodes[j].data=value; return OK; &#125; &#125; return ERROR;&#125; 获取节点的父节点123456789TElemType Parent(PTree *T,TElemType cur_e)&#123; /* 初始条件：树T存在，cur_e是T中某个节点 */ /* 操作结果：若cur_e是T的非根节点，则返回它的父节点，否则函数值为＂空＂*/ int j; for(j=1;j&lt;T-&gt;n;j++) /* 根节点序号为0 */ if(T-&gt;nodes[j].data==cur_e) return T-&gt;nodes[T-&gt;nodes[j].parent].data; return Nil;&#125; 获取节点的最左孩子节点123456789101112TElemType LeftChild(PTree *T,TElemType cur_e)&#123; /* 初始条件：树T存在，cur_e是T中某个节点 */ /* 操作结果：若cur_e是T的非叶子节点，则返回它的最左孩子，否则返回＂空＂*/ int i,j; for(i=0;i&lt;T-&gt;n;i++) if(T-&gt;nodes[i].data==cur_e) /* 找到cur_e，其序号为i */ break; for(j=i+1;j&lt;T-&gt;n;j++) /* 根据树的构造函数，孩子的序号＞其父节点的序号 */ if(T-&gt;nodes[j].parent==i) /* 根据树的构造函数，最左孩子(长子)的序号＜其它孩子的序号 */ return T-&gt;nodes[j].data; return Nil;&#125; 获取节点的右兄弟节点123456789101112TElemType RightSibling(PTree *T,TElemType cur_e)&#123; /* 初始条件：树T存在，cur_e是T中某个节点 */ /* 操作结果：若cur_e有右(下一个)兄弟，则返回它的右兄弟，否则返回＂空＂*/ int i; for(i=0;i&lt;T-&gt;n;i++) if(T-&gt;nodes[i].data==cur_e) /* 找到cur_e，其序号为i */ break; if(T-&gt;nodes[i+1].parent==T-&gt;nodes[i].parent) /* 根据树的构造函数，若cur_e有右兄弟的话则右兄弟紧接其后 */ return T-&gt;nodes[i+1].data; return Nil;&#125; 输出树12345678910111213void Print(PTree *T)&#123; /* 输出树T。加 */ int i; printf(&quot;节点个数=%d\\n&quot;,T-&gt;n); printf(&quot; 节点 父节点\\n&quot;); for(i=0;i&lt;T-&gt;n;i++) &#123; printf(&quot; %c&quot;,Value(T,i)); /* 节点 */ if(T-&gt;nodes[i].parent&gt;=0) /* 有父节点 */ printf(&quot; %c&quot;,Value(T,T-&gt;nodes[i].parent)); /* 父节点 */ printf(&quot;\\n&quot;); &#125;&#125; 向树中插入另一棵树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Status InsertChild(PTree *T,TElemType p,int i,PTree c)&#123; /* 初始条件：树T存在，p是T中某个节点，1≤i≤p所指节点的度+1，非空树c与T不相交 */ /* 操作结果：插入c为T中p节点的第i棵子树 */ int j,k,l,f=1,n=0; /* 设交换标志f的初值为1，p的孩子数n的初值为0 */ PTNode t; if(!TreeEmpty(T)) /* T不空 */ &#123; for(j=0;j&lt;T-&gt;n;j++) /* 在T中找p的序号 */ if(T-&gt;nodes[j].data==p) /* p的序号为j */ break; l=j+1; /* 如果c是p的第1棵子树，则插在j+1处 */ if(i&gt;1) /* c不是p的第1棵子树 */ &#123; for(k=j+1;k&lt;T-&gt;n;k++) /* 从j+1开始找p的前i-1个孩子 */ if(T-&gt;nodes[k].parent==j) /* 当前节点是p的孩子 */ &#123; n++; /* 孩子数加1 */ if(n==i-1) /* 找到p的第i-1个孩子，其序号为k1 */ break; &#125; l=k+1; /* c插在k+1处 */ &#125; /* p的序号为j，c插在l处 */ if(l&lt;T-&gt;n) /* 插入点l不在最后 */ for(k=T-&gt;n-1;k&gt;=l;k--) /* 依次将序号l以后的节点向后移c.n个位置 */ &#123; T-&gt;nodes[k+c.n]=T-&gt;nodes[k]; if(T-&gt;nodes[k].parent&gt;=l) T-&gt;nodes[k+c.n].parent+=c.n; &#125; for(k=0;k&lt;c.n;k++) &#123; T-&gt;nodes[l+k].data=c.nodes[k].data; /* 依次将树c的所有节点插于此处 */ T-&gt;nodes[l+k].parent=c.nodes[k].parent+l; &#125; T-&gt;nodes[l].parent=j; /* 树c的根节点的父节点为p */ T-&gt;n+=c.n; /* 树T的节点数加c.n个 */ while(f) &#123; /* 从插入点之后，将节点仍按层序排列 */ f=0; /* 交换标志置0 */ for(j=l;j&lt;T-&gt;n-1;j++) if(T-&gt;nodes[j].parent&gt;T-&gt;nodes[j+1].parent) &#123;/* 如果节点j的父节点排在节点j+1的父节点之后（树没有按层序排列），交换两节点*/ t=T-&gt;nodes[j]; T-&gt;nodes[j]=T-&gt;nodes[j+1]; T-&gt;nodes[j+1]=t; f=1; /* 交换标志置1 */ for(k=j;k&lt;T-&gt;n;k++) /* 改变父节点序号 */ if(T-&gt;nodes[k].parent==j) T-&gt;nodes[k].parent++; /* 父节点序号改为j+1 */ else if(T-&gt;nodes[k].parent==j+1) T-&gt;nodes[k].parent--; /* 父节点序号改为j */ &#125; &#125; return OK; &#125; else /* 树T不存在 */ return ERROR;&#125; 删除子树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Status deleted[MAX_TREE_SIZE+1]; /* 删除标志数组(全局量) */void DeleteChild(PTree *T,TElemType p,int i)&#123; /* 初始条件：树T存在，p是T中某个节点，1≤i≤p所指节点的度 */ /* 操作结果：删除T中节点p的第i棵子树 */ int j,k,n=0; LinkQueue q; QElemType pq,qq; for(j=0;j&lt;=T-&gt;n;j++) deleted[j]=0; /* 置初值为0(不删除标记) */ pq.name=&apos;a&apos;; /* 此成员不用 */ InitQueue(&amp;q); /* 初始化队列 */ for(j=0;j&lt;T-&gt;n;j++) if(T-&gt;nodes[j].data==p) break; /* j为节点p的序号 */ for(k=j+1;k&lt;T-&gt;n;k++) &#123; if(T-&gt;nodes[k].parent==j) n++; if(n==i) break; /* k为p的第i棵子树节点的序号 */ &#125; if(k&lt;T-&gt;n) /* p的第i棵子树节点存在 */ &#123; n=0; pq.num=k; deleted[k]=1; /* 置删除标记 */ n++; EnQueue(&amp;q,pq); while(!QueueEmpty(q)) &#123; DeQueue(&amp;q,&amp;qq); for(j=qq.num+1;j&lt;T-&gt;n;j++) if(T-&gt;nodes[j].parent==qq.num) &#123; pq.num=j; deleted[j]=1; /* 置删除标记 */ n++; EnQueue(&amp;q,pq); &#125; &#125; for(j=0;j&lt;T-&gt;n;j++) if(deleted[j]==1) &#123; for(k=j+1;k&lt;=T-&gt;n;k++) &#123; deleted[k-1]=deleted[k]; T-&gt;nodes[k-1]=T-&gt;nodes[k]; if(T-&gt;nodes[k].parent&gt;j) T-&gt;nodes[k-1].parent--; &#125; j--; &#125; T-&gt;n-=n; /* n为待删除节点数 */ &#125;&#125; 层序遍历树12345678void TraverseTree(PTree *T,void(*Visit)(TElemType))&#123; /* 初始条件：二叉树T存在,Visit是对节点操作的应用函数 */ /* 操作结果：层序遍历树T,对每个节点调用函数Visit一次且仅一次 */ int i; for(i=0;i&lt;T-&gt;n;i++) Visit(T-&gt;nodes[i].data); printf(&quot;\\n&quot;);&#125; 孩子链表表示法存储结构12345678910111213/*树的孩子链表存储表示*/typedef struct CTNode &#123; // 孩子节点 int child; struct CTNode *next;&#125; *ChildPtr;typedef struct &#123; ElemType data； // 节点的数据元素 ChildPtr firstchild； // 孩子链表头指针&#125; CTBox;typedef struct &#123; CTBox nodes[MAX_TREE_SIZE]； int n, r； // 节点数和根节点的位置&#125; CTree; 二叉树定义二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 二叉树和树的根本区别 二叉树可以为空，树不能为空 二叉树中每个元素都恰好有两棵子树（其中一个或两个可能为空）。而树中每个元素可以有若干子树。 在二叉树中每个元素的子树都是有序的，也就是说，可以用左、右子树来区别。而树的子树间是无序的。 二叉树的特性 1.包含n(n&gt;0)个元素的二叉树边数是n-1。 证明 二叉树中每个元素 (除了根节点)有且只有一个父节点。在子节点与父节点间有且只有一条边，因此边数为n-1。 2.若二叉树的高度为h,h≥0,则该二叉树最少有h个元素，最多有2h−1个元素。 二叉树的遍历意义二维结构的线性化(一维化) 分类 先序遍历 中序遍历 后序遍历 层次遍历 其中，先序遍历、中序遍历、后序遍历三种方式经过的路径相同，且每一结点均被经过三次(设没有左右子结点的结点的对应子结点为空结点)，只是被访问的时机不同(分别为第1、2、3次)。层次遍历的结果与编号序列相同 先序遍历① 访问根结点② 先序遍历其左子树③ 先序遍历其右子树12345678910void PreOrderTraversal(BinTree BT)&#123; if(BT) &#123; printf(&quot;%d&quot;, BT-&gt;Data); PreOrderTraversal(BT-&gt;Left); PreOrderTraversal(BT-&gt;Right); &#125;&#125;result: A B D F E C G H I 中序遍历① 中序遍历其左子树② 访问根结点③ 中序遍历其右子树12345678910void InOrderTraversal(BinTree BT) &#123; if(BT) &#123; InOrderTraversal(BT-&gt;Left); printf(&quot;%d&quot;, BT-&gt;Data); InOrderTraversal(BT-&gt;Right); &#125;&#125;result: D B E F A G H C I 后序遍历① 后序遍历其左子树② 后序遍历其右子树③ 访问根结点12345678910void PostOrderTraversal(BinTree BT)&#123; if (BT) &#123; PostOrderTraversal(BT-&gt;Left); PostOrderTraversal(BT-&gt;Right); printf(&quot;%d&quot;, BT-&gt;Data); &#125;&#125;resutl: D E F B H G I C A 层次遍历核心问题：二维结构的线性化 过程： 从结点访问其左、右子结点 访问左子结点后，右子结点无法访问 所以： 需要一个存储结构保存暂时不访问的结点 存储结构：堆栈、队列 队列实现：遍历从根结点开始，首先将根结点入队，然后开始执行循环：结点出队、访问该结点、其左右子结点入队 层序基本过程：先根结点入队，然后：① 从队列中取出一个元素② 访问该元素所指向的结点③ 若该元素所指的左、右子结点非空，则将其左、右子结点的指针顺序入队123456789101112131415161718void LevelOrderTraversal(BinTree BT) &#123; if (!BT) return;// 若树为空直接返回 Queue Q; BinTree T; Q = CreatQueue(MaxSize);// 创建并初始化队列Q AddQ(Q, BT); while(!IsEmpty( Q )) &#123; T = Delete( Q ); printf(&quot;%d\\n&quot;, T-&gt;Data);// 访问取出队列的结点 if(T-&gt;Left) &#123; AddQ(Q, T-&gt;Left); &#125; if(T-&gt;Right) &#123; AddQ(Q,T-&gt;Right); &#125; &#125;&#125; 二叉树的非递归遍历(使用栈)中序遍历:① 遇到一个结点，就把它压栈，并去遍历它的左子树② 当左子树遍历结束后，从栈顶弹出这个结点并访问它③ 再去中序遍历该结点的右子树123456789101112131415161718void InOrderTraversal(BinTree BT)&#123; BinTree T = BT; Stack S = CreatStack(MaxSize);// 创建并初始化栈S while(T || !IsEmpty(S)) &#123;// 树不为空或栈内有值 while(T)&#123;// 一直向左并将沿途结点压入栈 Push(S, T-&gt;Data); // printf(&quot;%d&quot;, T-&gt;Data);若在此处访问即为先序遍历 T = T-&gt;Left; &#125; if(!IsEmpty(S)) &#123; T = Pop(S);// 从栈中弹出结点 printf(&quot;%d&quot;, T-&gt;Data);// 访问(打印)结点，此处访问为中序遍历 T = T-&gt;Right;// 转向右子树 &#125; &#125;&#125; 遍历二叉树的应用输出二叉树中的叶子结点思路：在遍历算法中输出结点处增加检测：左右结点是否都为空1234567891011void PreOrderPrintLeaves(BinTree BT) &#123; if (BT) &#123; if (!BT-&gt;Left &amp;&amp; !BT-&gt;Right) &#123; printf(&quot;%d&quot;, BT-&gt;Data); &#125; PreOrderPrintLeaves(BT-&gt;Left); PreOrderPrintLeaves(BT-&gt;Right); &#125;&#125; 计算二叉树的高度思路：Height = max(LeftHeight, RightHeight) + 1; 1234567891011int PostOrderGetHeight(BinTree BT)&#123; int leftHeight, rightHeight, maxHeight; if (BT) &#123; leftHeight = PostOrderGetHeight(BT-&gt;Left);// 左子树的深度 rightHeight = PostOrderGetHeight(BT-&gt;Right);// 右子树的深度 maxHeight = max(leftHeight, rightHeight);// 取左右树较大的深度 return maxHeight + 1;// 返回树的深度 &#125; return 0;// 空树深度为0&#125; 二元运算表达树 由两种序列遍历结果确定二叉树结论已知中序遍历结果，与先序或者后序其一即可确定唯一的二叉树。如果仅有先序和后序而没有中序是不能确定的。|先序+中序|中序+后序|先序+后序||:—:|:—:|:—:||✅|✅|❌| 原因 可以根据前序/后序队列确定出根结点 在中序遍历中可由根结点分割处左右子树 对左右子树分别递归以上操作继续分解即可确定二叉树排列 二叉查找树定义二叉查找树（Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 1.若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 2.若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 3.任意节点的左、右子树也分别为二叉查找树； 4.没有键值相等的节点。 二叉搜索树查找指定值12345678910111213Position IterFind(ElementType X, BinTree BST)&#123; while( BST) &#123; if (X &gt; BST-&gt;Data) &#123; BST = BST-&gt;Right;// 向右子树移动，继续查找 &#125; else if(X &lt; BST-&gt;Data) &#123; BST = BST-&gt;Left;// 向左子树移动，继续查找 &#125; else &#123;// x == BST-&gt;Data return BST;// 查找成功，返回结点地址 &#125; &#125; return NotFound;// 查找失败&#125; 二叉搜索树查找最小值123456789Position FinMin(BinTree BST) &#123; if (!BST) &#123;// 数据校验 return NULL; &#125; else if (!BST-&gt;Left) &#123; // 找到最左叶结点 return BST-&gt;Data; &#125; else &#123; // 沿左分枝递归查找 return FinMin(BST-&gt;Left); &#125;&#125; 二叉搜索树查找最大值123456789Position FinMax(BinTree BST) &#123; if (!BST) &#123; return NULL; &#125; else if (!BST-&gt;Right) &#123; return BST-&gt;Data; &#125; else &#123; return FinMax(BST-&gt;Right); &#125;&#125; 二叉搜索树插入元素1234567891011121314151617BinTree Insert(ElementType X, BinTree BST) &#123; if (!BST) &#123;// 原树为空和递归到最后插入的子树X时的情况 BST = malloc(sizeof(struct TreeNode)); BST-&gt;Data = x; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; if (X &lt; BST-&gt;Left) &#123; // 递归插入左子树 BST-&gt;Left = Insert(X, BST-&gt;Left); &#125; else if (X &gt; BST-&gt;Right) &#123; // 递归插入右子树 BST-&gt;Right = Insert(X, BST-Right); &#125; else &#123; // X已存在，do nothing &#125; &#125; return BST;&#125; 二叉搜索树删除结点 要删除的结点只有一个子树 用该唯一子树替换被删除的结点树 要删除的结点有左、右两个子树 选取左子树的最大结点，用该最大结点替换被删除结点，并将结点左指针指向已删除该最大结点的左子树 或选取右子树的最小结点，用该最小结点替换被删除结点，并将结点右指针指向已删除该最小结点的右子树12345678910111213141516171819202122232425BinTree Delete (ElementType X, BinTree BST) &#123; Position Tmp; if (!BST) return NULL;// 数据校验 if (X &lt; BST-&gt;Data) &#123; BST-&gt;Left = Delete (X, BST-&gt;Left);// 左子树中递归删除 &#125; else if (X &gt; BST-&gt;Data) &#123; BST-&gt;Right = Delete (X, BST-&gt;Right);// 右子树中递归删除 &#125; else &#123; // 查找到要删除的结点 if (BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; // 被删除结点有左右两个子结点 Tmp = FindMin(BST-&gt;Right); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Right = Delete(tmp-&gt;Data, BST-&gt;Right); &#125; else &#123; // 被删除结点只有一个或者没有子结点 Tmp = BST-&gt;Data; if (!BST-&gt;Left) &#123; // 有右孩子或者无子结点 BST = BST-&gt;Right; &#125; else if (!BST-&gt;Right)&#123; // 有左孩子或者无子结点 BST = BST-&gt;Left; &#125; free (Tmp); &#125; &#125; return BST;&#125; 平衡二叉查找树 AVL树定义在AVL树中任何结点的左右两子树的高度差最大为1，也被称为高度平衡树 时间复杂度给定结点数为N的AVL树的最大高度为O(log2N) 平衡二叉树的调整-旋转 原因: 在每一次插入数值之后，树的平衡性都可能被破坏，这时可以通过一个简单的操作来矫正平衡–旋转。 方式：旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。 过程：通过旋转可以降低高度 所谓的左旋和右旋都是以子树为原点的：如b是a的子树，那么旋转就围绕b来进行。 如果b是a的左子树，那么就围绕b将a向右旋转，看着就像是a直接掉下来了，掉成了b的右子树。 如果b是a的右子树，那么就围绕b将a向左旋转，看着就像是a直接掉下来了，掉成了b的左子树。 插入节点时分四种情况，四种情况对应的旋转方法是不同的：例如对于被破坏平衡的挂叉着节点 a 来说： 插入方式 描述 旋转方式 LL 在a的左子树根节点的左子树上插入节点而破坏平衡 右单旋 RR 在a的右子树根节点的右子树上插入节点而破坏平衡 左单旋 LR 在a的左子树根节点的右子树上插入节点而破坏平衡 先左旋后右旋 RL 在a的右子树根节点的左子树上插入节点而破坏平衡 先右旋后左旋 LL旋转(右单旋）LL插入:不平衡的制造者插入发现者的左子树的左子结点上 -&gt;LL旋转 破坏平衡在示例VAL搜索树上插入一个元素3，就会变成下面这样，破坏平衡： 态势感知被破坏了平衡首先要找到是哪个树被破坏了平衡，然后调整这个树。然后继续往上一个一个的调整。既然是被新插入的节点3破坏的，那么不平衡的树一定在从新插入的节点3到根节点8的路径上。找离新插入的节点最近的不平衡的树进行调整，上图中就是7.节点7的左子树 高度为1，右子树为空，高度为-1 ，不平衡 确认方案根据表格要进行右单旋。 旋转 先把7这颗不平衡的树挑出来： 这棵树是最近的不平衡的树，7的左子树5高度为1，右子树为空，所以右子树高度是-1.两者的高度差达到了2，超过了1。 因为左子树5的高度更高，所以要把左子树5向上提一下，这时旋转就很明显了，抓着5向上一提，7就掉到5的右边了，成了5的右子树。这个过程就是右旋： 这时继续往上找，发现每个节点都符合了平衡条件，所以整棵树就变成了AVL树。 旋转+移花接木如果节点5在插入前有右子树，照样右旋转，只要把原来5的右子树变成旋转后的7的左子树就行了。因为5的右子树肯定比5大，但是也肯定比7小的： 其实上面最后旋转成的树是下面这样的：这棵树的根节点还是不平衡的，需要使用先左旋后右旋来调整。 使用LR先左旋后右旋调整后是这样的： LR旋转LR插入：不平衡的制造者插入发现者的左子树的右子结点 -&gt; LR旋转如果在第一个例子中插入的不是3，而是6，就成了下面的样子被破坏平衡的树依然是7，但是这次就不能通过一次旋转解决了，咋转都不行。 要从6开始到7进行先左旋再右旋才可以矫正平衡： RR旋转(左单旋)RR插入:不平衡的制造者插入发现者的右子树的右子结点上 -&gt; RR旋转 左单旋和右单旋类似，如下： RL旋转LR插入：不平衡的制造者插入发现者的右子树的左子结点 -&gt; RL旋转当破坏平衡的节点是这个树的右子树的左子树时，要进行先右旋转再左旋转来矫正。 同样是从破坏平衡的那个节点开始旋转，先右旋转后左旋转： 有时候插入元素后依旧是平衡搜索树，单需要重新计算一些平衡因子代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281// 1.建立一个节点类private static class AVLNode&lt;E&gt; &#123; E element; AVLNode&lt;E&gt; left; AVLNode&lt;E&gt; right; int height; public AVLNode(E element) &#123; this(element, null, null); &#125; public AVLNode(E element, AVLNode&lt;E&gt; left, AVLNode&lt;E&gt; right) &#123; this.element = element; this.left = left; this.right = right; &#125;&#125;// 2.建立一个树类，包括插入方法insert()，删除方法remove()，求高度的方法height()public class MyAVLTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; private AVLNode root; public MyAVLTree() &#123; this.root = null; &#125; public void insert(E x) &#123; root = insert(x, root); &#125; public void remove(E x) &#123; remove(x, root); &#125; public int height() &#123; return height(root); &#125; /** * 插入新数据 */ public AVLNode&lt;E&gt; insert(E x, AVLNode&lt;E&gt; t) &#123; if (t == null) &#123; return new AVLNode&lt;E&gt;(x); &#125; //先比较 是插左边还是插右边 int compareResult = x.compareTo(t.element); if (compareResult &lt; 0) &#123;//插到左子树上 t.left = insert(x, t.left); //插入之后要判断是否打破了平衡，因为插入的是左子树， // 只有左子树才会打破平衡，用左子树的高减去右子树的高 if (height(t.left) - height(t.right) == 2) &#123; //如果等于2，说明平衡被打破了，需要进行调整。就看选择什么方法调整 if (x.compareTo(t.left.element) &lt; 0) &#123; //如果x小于t的左子树的值，那么x会被插到t的左子树的左子树上，符合LL 用右旋转调整。 t = rightRotate(t); &#125; else &#123; //如果x大于t的左子树的值，则会被插到t的左子树的右子树上，符合LR，用先左旋转后右旋转来矫正。 t = leftAndRightRotate(t); &#125; &#125; &#125; else if (compareResult &gt; 0) &#123;//插到右子树上，逻辑和上面一样。 t.right = insert(x, t.right); if (height(t.right) - height(t.left) == 2) &#123; if (x.compareTo(t.right.element) &gt; 0) &#123; t = leftRotate(t); &#125; else &#123; t = rightAndLeftRotate(t); &#125; &#125; &#125; else &#123; //已经有这个值了 &#125; t.height = Math.max(height(t.left), height(t.right)) + 1; return t; &#125; /** * 删除数据 */ private AVLNode&lt;E&gt; remove(E x, AVLNode&lt;E&gt; t) &#123; if (t == null) return null; int compareResult = x.compareTo(t.element); if (compareResult &lt; 0) &#123; t.left = remove(x, t.left); //完了之后验证该子树是否平衡 if (t.right != null) &#123; //若右子树为空，则一定是平衡的，此时左子树相当对父节点深度最多为1, 所以只考虑右子树非空情况 if (t.left == null) &#123; //若左子树删除后为空，则需要判断右子树 if (height(t.right) - t.height == 2) &#123; AVLNode&lt;E&gt; k = t.right; if (k.right != null) &#123; //右子树存在，按正常情况单旋转 t = leftRotate(t); &#125; else &#123; //否则是右左情况，双旋转 t = rightAndLeftRotate(t); &#125; &#125; &#125; if (t.left!=null)&#123; //否则判断左右子树的高度差 //左子树自身也可能不平衡，故先平衡左子树，再考虑整体 AVLNode&lt;E&gt; k = t.left; //删除操作默认用右子树上最小节点补删除的节点 //k的左子树高度不低于k的右子树 if (k.right != null) &#123; if (height(k.left) - height(k.right) == 2) &#123; AVLNode&lt;E&gt; m = k.left; if (m.left != null) &#123; //左子树存在，按正常情况单旋转 k = rightRotate(k); &#125; else &#123; //否则是左右情况，双旋转 k = leftAndRightRotate(k); &#125; &#125; &#125; else &#123; if (height(k.left) - k.height == 2) &#123; AVLNode&lt;E&gt; m = k.left; if (m.left != null) &#123; //左子树存在，按正常情况单旋转 k = rightRotate(k); &#125; else &#123; //否则是左右情况，双旋转 k = leftAndRightRotate(k); &#125; &#125; &#125; if (height(t.right) - height(t.left) == 2) &#123; //右子树自身一定是平衡的，左右失衡的话单旋转可以解决问题 t = leftRotate(t); &#125; &#125; &#125; //完了之后更新height值 t.height = Math.max(height(t.left), height(t.right)) + 1; &#125; else if (compareResult &gt; 0) &#123; t.right = remove(x, t.right); //下面验证子树是否平衡 if (t.left != null) &#123; //若左子树为空，则一定是平衡的，此时右子树相当对父节点深度最多为1 t = balanceChild(t); &#125; //完了之后更新height值 t.height = Math.max(height(t.left), height(t.right)) + 1; &#125; else if (t.left != null &amp;&amp; t.right != null) &#123; //默认用其右子树的最小数据代替该节点的数据并递归的删除那个节点 AVLNode&lt;E&gt; min = t.right; while (min.left != null) &#123; min = min.left; &#125;// t.element = findMin(t.right).element; t.element = min.element; t.right = remove(t.element, t.right); t = balanceChild(t); //完了之后更新height值 t.height = Math.max(height(t.left), height(t.right)) + 1; &#125; else &#123; t = (t.left != null) ? t.left : t.right; &#125; return t; &#125; private AVLNode&lt;E&gt; balanceChild(AVLNode&lt;E&gt; t) &#123; if (t.right == null) &#123; //若右子树删除后为空，则只需判断左子树与根的高度差 if (height(t.left) - t.height == 2) &#123; AVLNode&lt;E&gt; k = t.left; if (k.left != null) &#123; t = rightRotate(t); &#125; else &#123; t = leftAndRightRotate(t); &#125; &#125; &#125; else &#123; //若右子树删除后非空，则判断左右子树的高度差 //右子树自身也可能不平衡，故先平衡右子树，再考虑整体 AVLNode&lt;E&gt; k = t.right; //删除操作默认用右子树上最小节点（靠左）补删除的节点 if (k.left != null) &#123; if (height(k.right) - height(k.left) == 2) &#123; AVLNode&lt;E&gt; m = k.right; if (m.right != null) &#123; //右子树存在，按正常情况单旋转 k = leftRotate(k); &#125; else &#123; //否则是右左情况，双旋转 k = rightAndLeftRotate(k); &#125; &#125; &#125; else &#123; if (height(k.right) - k.height == 2) &#123; AVLNode&lt;E&gt; m = k.right; if (m.right != null) &#123; //右子树存在，按正常情况单旋转 k = leftRotate(k); &#125; else &#123; //否则是右左情况，双旋转 k = rightAndLeftRotate(k); &#125; &#125; &#125; //左子树自身一定是平衡的，左右失衡的话单旋转可以解决问题 if (height(t.left) - height(t.right) == 2) &#123; t = rightRotate(t); &#125; &#125; return t; &#125; /** * 右旋转 * * @param t 需要调整的树 * @return 调整后的树 */ private AVLNode&lt;E&gt; rightRotate(AVLNode&lt;E&gt; t) &#123; AVLNode newTree = t.left; t.left = newTree.right; newTree.right = t; t.height = Math.max(height(t.left), height(t.right)) + 1; newTree.height = Math.max(height(newTree.left), height(newTree.right)) + 1; return newTree; &#125; /** * 左旋转 */ private AVLNode&lt;E&gt; leftRotate(AVLNode t) &#123; AVLNode&lt;E&gt; newTree = t.right; t.right = newTree.left; newTree.left = t; t.height = Math.max(height(t.left), height(t.right)) + 1; newTree.height = Math.max(height(newTree.left), height(newTree.right)) + 1; return newTree; &#125; /** * 先左旋后右旋 */ private AVLNode&lt;E&gt; leftAndRightRotate(AVLNode&lt;E&gt; t) &#123; t.left = leftRotate(t.left); return rightRotate(t); &#125; /** * 先右旋后左旋 */ private AVLNode&lt;E&gt; rightAndLeftRotate(AVLNode&lt;E&gt; t) &#123; t.right = rightRotate(t.right); return leftRotate(t); &#125; /** * 获取指定树的高度 */ private int height(AVLNode&lt;E&gt; t) &#123; return t == null ? -1 : t.height; &#125; public void printTree() &#123; printTree(root); &#125; private void printTree(AVLNode&lt;E&gt; tree) &#123; if (tree == null) &#123; return; &#125; System.out.print(tree.element + &quot; &quot;); printTree(tree.left); printTree(tree.right); &#125; private static class AVLNode&lt;E&gt; &#123; E element; AVLNode&lt;E&gt; left; AVLNode&lt;E&gt; right; int height; public AVLNode(E element) &#123; this(element, null, null); &#125; public AVLNode(E element, AVLNode&lt;E&gt; left, AVLNode&lt;E&gt; right) &#123; this.element = element; this.left = left; this.right = right; &#125; &#125;&#125; 堆本质堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 1.堆中某个节点的值总是不大于或不小于其父节点的值； 2.堆是用数组表示的一棵完全二叉树。 当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。(大顶堆的根结点是堆有序的二叉树中的最大结点。) 分类 1.大顶堆（子节点永远小于父节点） 2.小顶堆（子节点永远大于父节点）上图所示是一个大顶堆,我们可以使用一个数组来存储一个堆(通常从第1个元素开始，第0个元素一般用作哨兵)。[ -, 90, 36, 17, 25, 26, 7, 1, 2, 3, 10 ] 注意我们将数组下标为 0 的位置弃用了，根据图示我们不难得出结论：1在一个堆中，位置 k 的结点的父结点的位置为[ k / 2 ] ，而它的两个子结点的位置则分别是 2k 或者 2k+1 。 维护堆维护一个堆需要做两件事情：插入元素和删除最大元素 两个操作： 由下至上的堆有序化（上浮） 由上至下的堆有序化（下沉） 插入元素进队需要做的事情很简单，先将元素丢进队列尾，然后和父节点进行比较，比父节点大时则于其交换位置，比父节点小时则表示进队完成。 注：按定义，堆中每次都只能删除根节点数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。 删除最大元素出队如图所示，只需要将队列头位置的元素取出（下标为 1 的元素），然后将队列尾的元素填充到队列头，接下来和子节点较大者对换位置，直至比子节点的元素都要大时结束交换位置。 1234567891011121314151617181920212223242526ElementType DeleteMax( MaxHeap H )&#123; /* 从最大堆H中取出键值为最大的元素，并删除一个结点 */ int Parent, Child; ElementType MaxItem, temp; if ( IsEmpty(H) ) &#123; printf(&quot;最大堆已为空&quot;); return; &#125; MaxItem = H-&gt;Elements[1]; /* 取出根结点最大值 */ /* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */ temp = H-&gt;Elements[H-&gt;Size--]; for( Parent=1; Parent*2&lt;=H-&gt;Size; Parent=Child ) &#123; Child = Parent * 2; if((Child!= H-&gt;Size) &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child+1])) &#123; Child++; /* Child指向左右子结点的较大者 */ &#125; if( temp &gt;= H-&gt;Elements[Child] ) &#123; break; &#125; else &#123;/* 移动temp元素到下一层 */ H-&gt;Elements[Parent] = H-&gt;Elements[Child]; &#125; &#125; H-&gt;Elements[Parent] = temp; return MaxItem;&#125; 堆的建立建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中方法： 通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为O(N logN)。 在线性时间复杂度下建立最大堆。 1.将N个元素按输入顺序存入，先满足完全二叉树的结构特性2.调整各结点位置，以满足最大堆的有序特性。 技巧：完全二叉树完成后需要排序，从最后一个结点的父结点开始排序 哈夫曼树(最优二叉树)定义带权路径长度(WPL)：二叉树有n个叶子结点，每个叶子结点带有权值W，从根结点到每个叶子结点的长度为L，则每个叶子结点的带权路径长度之和就是：WPL = W1L1 + W2L2 + … Wn*Ln。哈夫曼树即为WPL最小的树 构造选出两棵权值最小的二叉树，组成一棵新的二叉树，其权值为这两棵二叉树的权值之和。该和加入到集合中，重复执行上述操作则按照以上步骤，可以构造出如下面左图所示的赫夫曼树当然也可能构造出如下面右图所示的赫夫曼树，这并不是唯一的 注意：可以构造出不同的哈夫曼树，但是WPL是相同的 整体复杂度为O(N logN)1234567891011121314151617181920212223typedef struct TreeNode *HuffmanTree;struct TreeNode&#123; int Weight; HuffmanTree Left, Right;&#125;HuffmanTree Huffman( MinHeap H )&#123; /* 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里 */ int i; HuffmanTree T; BuildMinHeap(H); /*将H-&gt;Elements[]按权值调整为最小堆*/ for (i = 1; i &lt; H-&gt;Size; i++) &#123; /*做H-&gt;Size-1次合并*/ T = malloc( sizeof( struct TreeNode) ); /*建立新结点*/ T-&gt;Left = DeleteMin(H); /*从最小堆中删除一个结点，作为新T的左子结点*/ T-&gt;Right = DeleteMin(H); /*从最小堆中删除一个结点，作为新T的右子结点*/ T-&gt;Weight = T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight; /*计算新权值*/ Insert( H, T ); /*将新T插入最小堆*/ &#125; T = DeleteMin(H); return T;&#125; 特点 没有度为1的结点 n个叶子结点的哈夫曼树共有2n-1个结点 哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树 对同一组数据，可能构造出不止一种哈夫曼树，但是WPL相同 哈夫曼编码 避免二义性 -&gt; 不出现前缀码(不能存在父结点) 效率高 -&gt; 哈夫曼树 对每个字符设计长度不等的编码，让电文中出现较多的字符采用尽可能短的编码 左分支编码为字符0，右分支编码为字符1，将从根节点到叶子节点的路径上分支字符组成的字符串作为叶子节点字符的编码，这便是赫夫曼编码。 上图各叶子节点的赫夫曼编码如下： 权值为5的也自己节点的赫夫曼编码为：00权值为4的也自己节点的赫夫曼编码为：01权值为3的也自己节点的赫夫曼编码为：10权值为2的也自己节点的赫夫曼编码为：110权值为1的也自己节点的赫夫曼编码为：111 图定义表示多对多的关系 组成 一组定点：通常用V(Vertex)表示顶点集合 一组边：通常用E(Edge)表示边的集合 边是顶点对：(v,w) ∈ E,其中v,w ∈ V V — W有向边&lt;v,w&gt;表示从v指向w的边(单行线） V –&gt; W不考虑重边和自回路 数据类型 类型名称：图（Graph) 数据对象集：G(V,E)由一个非空的有限顶点集合v和一个有限边集合E组成 操作集：对于任意图G ∈ Graph,以及v ∈ V，e ∈ E Graph Create():建立并返回空图;Graph InsertVertex(Graph G, Vertex v):将v插入G;Graph InsertEdge(Graph G, Edge e):将e插入G;void DFS(Graph G, Vertex v):从顶点v出发深度优先遍历图G;void BFS(Graph G, Vertex v):从顶点v出发宽度优先遍历图G;void ShortestPath(Graph G, Vertex v, int Dist[]):计 算图G中顶点v到任意其他顶点的最短距离;void MST(Graph G):计算图G的最小生成树; 程序表示邻接矩阵 特点 直观、简单、好理解 方便检查任意一对顶点间是否存在边 方便找任一顶点的所有“邻接点”(有边直接相连的顶点） 方便计算任一顶点的“度”(从该点发出的边数为“出 度”，指向该点的边数为“入度”) 无向图:对应行(或列)非0元素的个数有向图:对应行非0元素的个数是“出度”;对应列非0元素的 个数是“入度” 改善 - 针对无向图节省一半空间用一个长度为N(N+1)/2的1维数组A存储 {G00,G10,G11,……,Gn-1 0,…,Gn-1 n-1}， 则Gij在A中对应的下标是:(i*(i+1)/2 + j) 对于网络，只要把G[i][j]的值定义为边&lt; vi ,vj &gt;的权重即可 代码实现1234567891011121314151617181920212223242526272829303132333435/* 图的邻接矩阵表示法（C语言实现） */#define MaxVertexNum 100 /* 最大顶点数设为100 */#define INFINITY 65535 /* ∞设为双字节无符号整数的最大值65535*/typedef char VertexType; /* 顶点类型设为字符型 */typedef int EdgeType; /* 边的权值设为整型 */enum GraphType &#123; DG, UG, DN, UN &#125;; /* 有向图,无向图,有向网图,无向网图*/ typedef struct &#123; VertexType Vertices[ MaxVertexNum ]; /* 顶点表 */ EdgeType Edges[ MaxVertexNum ][ MaxVertexNum ]; /* 邻接矩阵，即边表 */ int n, e; /* 顶点数n和边数e */ enum GraphType GType; /* 图的类型分4种：UG、DG、UN、DN */&#125; MGraph; /* MGragh是以邻接矩阵存储的图类型 */ void CreateMGraph ( MGraph *G )&#123; int i, j, k, w; G-&gt; GType = UN; /* Undirected Network 无向网图 */ printf( &quot;请输入顶点数和边数(输入格式为:顶点数, 边数):\\n&quot; ); scanf( &quot;%d, %d&quot;,&amp;(G-&gt;n), &amp;(G-&gt;e) ); /* 输入顶点数和边数 */ printf(&quot;请输入顶点信息(输入格式为:顶点号&lt;CR&gt;):\\n&quot;); for ( i = 0; i &lt; G-&gt;n; i++ ) scanf( &quot;%c&quot;,&amp;(G-&gt; Vertices[i]) ); /* 输入顶点信息，建立顶点表 */ for ( i = 0; i &lt; G-&gt;n; i++ ) for ( j = 0; j &lt; G-&gt;n; j++ ) G-&gt;Edges[i][j] = INFINITY; /* 初始化邻接矩阵 */ printf( &quot;请输入每条边对应的两个顶点的序号和权值，输入格式为:i, j, w:\\n&quot; ); for ( k = 0; k &lt; G-&gt;e; k++ ) &#123; scanf(&quot;%d,%d,%d &quot;,&amp;i, &amp;j, &amp;w); /* 输入e条边上的权，建立邻接矩阵 */ G-&gt;Edges[i][j] = w; G-&gt;Edges[j][i] = w; /* 因为无向网图的邻接矩阵是对称的 */ &#125;&#125; 邻接表G[N]为指针数组，对应矩阵每行一个链表， 只存非0元素。对于网络，结构中要增加权重的域 特点 方便找任一顶点的所有“邻接点” 节约稀疏图的空间 需要N个头指针 + 2E个结点(每个结点至少2个域) 方便计算任一顶点的“度”? 对无向图:是的对有向图:只能计算“出度”;需要构造“逆邻接表”(存指向自己 的边)来方便计算“入度” 不方便检查任意一对顶点间是否存在边 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 图的邻接表表示法（C语言实现） */#define MaxVertexNum 100 /* 最大顶点数为100 */enum GraphType &#123; DG, UG, DN, UN &#125;; /* 有向图,无向图,有向网图,无向网图*/typedef struct node&#123; /* 边表结点 */ int AdjV; /* 邻接点域 */ struct node *Next; /* 指向下一个邻接点的指针域 */ /* 若要表示边上的权值信息，则应增加一个数据域Weight */&#125; EdgeNode;typedef char VertexType; /* 顶点用字符表示 */typedef struct Vnode&#123; /* 顶点表结点 */ VertexType Vertex; /* 顶点域 */ EdgeNode *FirstEdge; /* 边表头指针 */&#125; VertexNode; typedef VertexNode AdjList[ MaxVertexNum ]; /* AdjList是邻接表类型 */typedef struct&#123; AdjList adjlist; /* 邻接表 */ int n, e; /* 顶点数和边数 */ enum GraphType GType; /* 图的类型分4种：UG、DG、UN、DN */&#125; ALGraph; /*ALGraph是以邻接表方式存储的图类型 */ void CreateALGraph( ALGraph *G )&#123; int i, j, k; EdgeNode *edge; G-&gt; GType = DG; /* Directed Graph 有向图 */ printf( &quot;请输入顶点数和边数(输入格式为:顶点数,边数)：\\n&quot; ); scanf( &quot;%d,%d&quot;, &amp;(G-&gt;n), &amp;(G-&gt;e) ); /* 读入顶点数和边数 */ printf( &quot;请输入顶点信息(输入格式为:顶点号&lt;CR&gt;)：\\n&quot; ); for ( i=0; i &lt; G-&gt;n; i++ ) &#123; /* 建立有n个顶点的顶点表 */ scanf( &quot; %c&quot;, &amp;(G-&gt;adjlist[i].Vertex) ); /* 读入顶点信息 */ G-&gt;adjlist[i].FirstEdge = NULL; /* 顶点的边表头指针设为空 */ &#125; printf( &quot;请输入边的信息(输入格式为: i, j &lt;CR&gt;)：\\n&quot; ); for ( k=0; k &lt; G-&gt;e; k++ )&#123; /* 建立边表 */ scanf( &quot;\\n%d,%d&quot;, &amp;i, &amp;j); /* 读入边&lt;vi,vj&gt;的顶点对应序号*/ edge = (EdgeNode*)malloc(sizeof(EdgeNode)); /* 生成新边结点edge */ edge-&gt;AdjV = j; /* 邻接点序号为j */ edge-&gt;Next = G-&gt;adjlist[i].FirstEdge; /* 将新边表结点edge插入到顶点vi的边表头部 */ G-&gt;adjlist[i].FirstEdge = edge; /* 若是无向图，还要生成一个结点，用来表示边&lt; vj, vi&gt; */ &#125;&#125; 遍历深度优先搜索(Depth First Search, DFS)ps:类似于树的先序遍历路径特点：原路返回 123456void DFS ( Vertex V ) &#123; visited[ V ] = true; for ( V 的每个邻接点 W ) &#123; if ( !visited[ W ] ) &#125; DFS( W ); &#125; 广度优先搜索(Breadth First Search, BFS)ps：类似于树中的层序遍历路径特带：辐射 代码实现123456789101112/* 邻接表存储的图 – DFS（C语言实现） *//* Visited[]为全局变量，已经初始化为FALSE */void DFS( ALGraph *G, int i )&#123; /* 以Vi为出发点对邻接表存储的图G进行DFS搜索 */ EdgeNode *W; printf( &quot;visit vertex: %c\\n&quot;, G-&gt;adjlist[i].Vertex ); /* 相当于访问顶点Vi */ Visited[i] = TRUE; /* 标记Vi已访问 */ for( W = G-&gt;adjlist[i].FirstEdge; W; W = W-&gt;Next ) if ( !Visited[ W-&gt;AdjV ] ) DFS( G, W-&gt;AdjV );&#125; 1234567891011121314151617181920212223242526/* 邻接矩阵存储的图 – BFS（C语言实现） */void BFS ( MGraph G )&#123; /* 按广度优先遍历图G。使用辅助队列Q和访问标志数组Visited */ Queue *Q; VertexType U, V, W; for ( U = 0; U &lt; G.n; ++U ) Visited[U] = FALSE; Q = CreatQueue( MaxSize ); /* 创建空队列Q */ for ( U = 0; U&lt;G.n; ++U ) if ( !Visited[U] ) &#123; /* 若U尚未访问 */ Visited[U] = TRUE; printf( &quot;visit vertex: %c\\n&quot;, G.Vertices[U] ); /* 相当于访问顶点U */ AddQ (Q, U); /* U入队列 */ while ( ! IsEmptyQ(Q) ) &#123; V = DeleteQ( Q ); /* 队头元素出队并置为V */ for( W = FirstAdjV(G, V); W; W = NextAdjV(G, V, W) ) if ( !Visited[W] ) &#123; Visited[W] = TRUE; printf( &quot;visit vertex: %c\\n&quot;, G.Vertices[W] ); /* 相当于访问顶点W */ AddQ (Q, W); &#125; &#125; /* while结束*/ &#125; /* 结束从U开始的BFS */&#125; 时间复杂度时间复杂度与搜索方式无关，只与存储方式有关，搜索方式只影响搜索路径。 若有N个顶点、E条边，时间复杂度是： 用邻接表存储图，有O(N+E) 用邻接矩阵存储图，有O(N 2 ) 连通性 连通：如果从V到W存在一条（无向）路径，则称 V和W是连通的 路径：V到W的路径是一系列顶点{V, v1, v2, …, vn, W}的集合，其中任一对相邻的顶点间都有图中的边。路径的长度是路径中的边数（如果带权，则是所有边的权重和）。如果V到W之间的所有顶点都不同(没有回路)，则称简单路径 回路：起点等于终点的路径 连通图：图中任意两顶点均连通 连通分量：无向图的最大连通子图 最大顶点数：再加1个顶点就不连通了最大边数：包含子图中所有顶点相连的所有边 强连通：有向图中顶点V和W之间存在双向路径，则称V和W是强连通的 强连通图：有向图中任意两顶点均强连通 强连通分量：有向图的最大强连通子图 12345678void ListComponents ( Graph G ) &#123; for ( each V in G ) &#123; if ( !visited[V] ) &#123; DFS( V ); /*or BFS( V )*/ &#125; &#125;&#125; 应用范例拯救007123456789101112131415161718void ListComponents ( Graph G ) &#123; for ( each V in G ) &#123; if ( !visited[V] ) &#123; DFS( V ); &#125; &#125;&#125;void Save007 ( Graph G ) &#123; for ( each V in G ) &#123; if (!visited[V] &amp;&amp; FirstJump(V)) &#123; answer = DFS( V ); if (answer==YES) break; &#125; &#125; if (answer==YES) output(“Yes”); else output(“No”);&#125; 6度空间理论算法思路： 对每个结点，进行广度优先搜索 搜索过程中累积访问的结点数 记录层数，限定在6层以内 12345678910111213141516171819202122232425262728293031void SDS() &#123; for ( each V in G ) &#123; count = BFS(V); Output(count/N); &#125; &#125;int BFS ( Vertex V )&#123; visited[V] = true; count = 1; level = 0; last = V; tail = V; Enqueue(V, Q); while(!IsEmpty(Q))&#123; V = Dequeue(Q); for ( V 的每个邻接点 W ) &#123; if ( !visited[W] ) &#123; visited[W] = true; Enqueue(W, Q); count++; tail = W; &#125; &#125; if ( V == last ) &#123; level++; last = tail; &#125; if ( level == 6 ) break; &#125; return count;&#125; 根据中序结果 + 前序结果 直接计算 后序1234567891011121314151617void solve( int preL, int inL, int postL, int n ) &#123; if (n==0) return; if (n==1) &#123; post[postL] = pre[preL]; return; &#125; root = pre[preL]; post[postL+n-1] = root; for (i=0; i&lt;n; i++) &#123; if (in[inL+i] == root) break; &#125; L = i; R = n-L-1; solve(preL+1, inL, postL, L); solve(preL+L+1, inL+L+1, postL+L, R);&#125; 输入一组数据 求 完全二叉搜索树 层序输出结果输入： 1 2 3 4 5 6 7 8 9 0 输出： 6 3 8 1 5 7 9 0 2 4 数组表示 排列 == 层序遍历对于非完全二叉树，浪费空间 链表 节省空间需要操作指针 思路：对于一个有序的一组树，可以根据完全二叉树的特征确认root及左右子树的集合，递归即可得出完全二叉树的分布 如何计算左子树的规模H为树的高度，Hroot = 1; 则有： 完美二叉树节点总数 = 2H - 1 对于完全二叉树需要考虑最下非满层的叶结点X 完全二叉树节点数 N = 2H - 1 + X可以推导出 H = log2 (N+1） 有效X = MIN(X,2H - 1),超过2H - 1的部分在右子树上 代码实现12345678910111213// ALeft &amp;&amp; ARight分别表示输入排序后数组的起始和终止// T表示输出结果数组void solve( int ALeft, int ARight, int TRoot ) &#123; /* 初始调用为 solve(0, N-1, 0) */ n = ARight – ALeft + 1; if (n==0) return; L = GetLeftLength(n); /* 计算出n个结点的树其左子树有多少个结点 */ T[TRoot] = A[ALeft + L]; LeftTRoot = TRoot * 2 + 1; RightTRoot = LeftTRoot + 1; solve(ALeft, ALeft+L-1, LeftTRoot); solve(ALeft+L+1, ARight, RightTRoot);&#125; 最短路径问题抽象问题在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径 这条路径就是两点之间的最短路径（Shortest Path） 第一个顶点为源点（Source） 最后一个顶点为终点（Destination） 问题分类单源最短路径问题：从某固定源点出发，求其 到所有其他顶点的最短路径 （有向）无权图 （有向）有权图 多源最短路径问题：求任意两顶点间的最短路径 无权图的单源最短路算法类似图的BFS算法T = O( |V| + |E| )1234567891011121314151617// dist[W] = S到W的最短距离 // dist[S] = 0 // path[W] = S到W的路上经过的某顶点void Unweighted ( Vertex S ) &#123; Enqueue(S, Q); while(!IsEmpty(Q))&#123; V = Dequeue(Q); for ( V 的每个邻接点 W ) &#123; if ( dist[W]==-1 ) &#123; dist[W] = dist[V]+1; path[W] = V; Enqueue(W, Q); &#125; &#125; &#125;&#125; 有权图的单源最短路算法 Dijkstra 算法有权图最短路径算法不能有负值圈，即不能有权重为负的环形路径，否则可以不断重复无边界) 思路 令S={源点s + 已经确定了最短路径的顶点vi } 对任一未收录的顶点v，定义dist[v]为s到v的最 短路径长度，但该路径仅经过S中的顶点。即路径 {s -&gt; (vi ∈ S) -&gt; v}的最小长度 若路径是按照递增（非递减）的顺序生成的，则 真正的最短路必须只经过S中的顶点每次从未收录的顶点中选一个dist最小的收录（贪心算法）增加一个v进入S，可能影响另外一个w的dist值！(dist[w] = min{dist[w], dist[v] + &lt;v,w&gt;的权重}) 代码123456789101112131415161718void Dijkstra( Vertex s ) &#123; while (1) &#123; V = 未收录顶点中dist最小者; if ( 这样的V不存在 ) break; collected[V] = true; for ( V 的每个邻接点 W ) &#123; if ( collected[W] == false ) &#123; if ( dist[V]+E&lt;V,W&gt; &lt; dist[W] &#123; dist[W] = dist[V] + E&lt;V,W&gt; ; path[W] = V; &#125; &#125; &#125; &#125;&#125; /* 不能解决有负边的情况 */ 时间复杂度 直接扫描所有未收录顶点 &gt; T = O( |V| 2 + |E| ) &gt; 稠密图效果好 将dist存在最小堆中 &gt; T = O( |E| log|V| ) &gt; 稀疏图效果好 多源最短路算法 Floyd算法思路 Dk[i][j] = 路径{ i -&gt; { l &lt;= k } -&gt; j }的最小长度 D0, D1, …, D|V|-1 [i][j]即给出了i到j的真正最短距离 当Dk-1已经完成，递推到D0k时： 或者k ∉ 最短路径{ i -&gt; { l &lt;= k } -&gt; j }，则Dk = Dk-1或者k ∈ 最短路径{ i -&gt; { l &lt;= k } -&gt; j }，则该路径必定由两段最短路径组成： Dk[i][j]=Dk-1[i][k]+Dk-1 [k][j] 代码123456789101112131415161718void Floyd() &#123; for ( i = 0; i &lt; N; i++ ) &#123; for( j = 0; j &lt; N; j++ ) &#123; D[i][j] = G[i][j]; path[i][j] = -1; &#125; &#125; for( k = 0; k &lt; N; k++ ) &#123; for( i = 0; i &lt; N; i++ ) &#123; for( j = 0; j &lt; N; j++ ) &#123; if( D[i][k] + D[k][j] &lt; D[i][j] ) &#123; D[i][j] = D[i][k] + D[k][j]; path[i][j] = k; &#125; &#125; &#125; &#125;&#125; 时间复杂度T = O(|V|3) 最小生成树 是一颗树 无回路(环)|V|个顶点一定有|V|-1条边 是生成树 包含全部顶点|V|-1条边都在图里 边的权重和最小 特点 最小生成树存在的图肯定是连通的图 向生成树中任加一条边都一定构成回路 Prim算法 - 让一颗小树长大T = O(|V|2) -&gt; 稠密图合算123456789101112131415161718192021void Prim()&#123; MST = &#123;s&#125;; while (1) &#123; V = 未收录顶点中dist最小者; if ( 这样的V不存在 ) &#123; break; &#125; 将V收录进MST: dist[V] = 0; for ( V 的每个邻接点 W ) &#123; if ( dist[W]!= 0 ) &#123; if ( E(V,W) &lt; dist[W] ) &#123; dist[W] = E(V,W) ; parent[W] = V; &#125; &#125; &#125; &#125; if ( MST中收的顶点不到|V|个 ) Error ( “生成树不存在” );&#125; Kruskal算法 - 将森林合并成树T = O( |E| log |E| )12345678910111213141516void Kruskal ( Graph G )&#123; MST = &#123; &#125; ; while ( MST 中不到 |V| - 1 条边 &amp;&amp; E 中还有边 ) &#123; 从 E 中取一条权重最小的边 E(v,w) ;// 最小堆 将 E(v,w)从 E 中删除; if ( E(V,W)不在 MST 中构成回路) &#123;// 并查集 将 E(V,W) 加入 MST; &#125; else &#123; 彻底无视 E(V,W); &#125; &#125; if ( MST 中不到 |V| - 1 条边 ) &#123; Error ( “生成树不存在” ); &#125;&#125; 拓扑排序 拓扑序：如果图中从V到W有一条有向路径，则V一定排在W之前。满足此条件的顶点序列称为一个拓扑序 获得一个拓扑序的过程就是拓扑排序 AOV如果有合理的拓扑序，则必定是有向无环图（Directed Acyclic Graph, DAG） 算法T = O( |V| + |E| ) 可以用来检测有向图是否DAG12345678910111213141516171819// 将入度变为0的顶点放到一个容器里void TopSort()&#123; for ( 图中每个顶点 V ) if ( Indegree[V]==0 ) &#123; Enqueue( V, Q ); &#125; while ( !IsEmpty(Q) ) &#123; V = Dequeue( Q ); 输出V，或者记录V的输出序号; cnt++; for ( V 的每个邻接点 W ) &#123; if ( ––Indegree[W]==0 ) &#123; Enqueue( W, Q ); &#125; &#125; &#125; if ( cnt != |V| ) Error( “图中有回路” );&#125; 关键路径问题AOE (Activity On Edge) 网络，一般用于安排项目的工序 路线规划问题 城市为节点 公路为边 权重1:距离权重2:收费 单源最短路 Dijkstra - 距离等距离时按收费更新 核心算法1234567891011121314151617181920212223void Dijkstra( Vertex s )&#123; while (1) &#123; V = 未收录顶点中dist最小者; if ( 这样的V不存在 ) &#123; break; &#125; collected[V] = true; for ( V 的每个邻接点 W ) &#123; if ( collected[W] == false ) &#123; if ( dist[V]+E&lt;V,W&gt; &lt; dist[W] ) &#123; dist[W] = dist[V] + E&lt;V,W&gt; ; path[W] = V; cost[W] = cost[V] + C&lt;V,W&gt; ; &#125; else if ( (dist[V]+E&lt;V,W&gt; == dist[W])&amp;&amp; (cost[V]+C&lt;V,W&gt; &lt; cost[W]) ) &#123; cost[W] = cost[V] + C&lt;V,W&gt; ; path[W] = V; &#125; &#125; &#125; &#125; &#125; 其他类似问题 要求数最短路径有多少条 count[s] = 1如果找到更短路：count[W]=count[V]如果找到等长路：count[W]+=count[V] 要求边数最少的最短路 count[s] = 0如果找到更短路：count[W]=count[V]+1如果找到等长路：count[W]=count[V]+1 散列表(哈希表)定义符号表：SymbolTable 数据对象集:符号表是”名字(Name)-属性(Attibute)”对的集合 基本思路 以关键字key为自变量，通过一个确定的哈希函数hash，计算出对应的函数值hash(key)作为数据对象的存储地址 需要冲突解决策略：不同的key可能哈希映射到一个哈希地址上，即hash(key1) == hash(key2)(key1 ≠ key2)称为冲突(Collision) 装填因子（Loading Factor）：设散列表空间大小为m，填入表中元素个数是n，则称α＝ n / m为散列表的装填因子 操作集Table ∈ SymbolTable, Name ∈ NameType, Arrt ∈ ArrtibuteType123456789101112// 1.创建一个长度为TableSize的符号表SymbolTable InitializeTable( int TableSize )：// 2.查找特定的名字Name是否在符号表Table中Boolean IsIn( SymbolTable Table, NameType Name)：// 3.获取Table中指定名字Name对应的属性AttributeType Find( SymbolTable Table, NameType Name)：// 4.将Table中指定名字Name的属性修改为AttrSymbolTable Modefy(SymbolTable Table, NameType Name, AttributeType Attr)：// 5.向Table中插入一个新名字Name及其属性AttrSymbolTable Insert(SymbolTable Table, NameType Name, AttributeType Attr)：// 6.从Table中删除一个名字Name及其属性SymbolTable Delete(SymbolTable Table, NameType Name)： 散列函数2个重要指标 足够简单：访问频率高，以便提高转换速度 Key对应的地址空间分布均匀，以尽量减少冲突 常用数字key散列函数 直接定址法 hash(key) = a * key + b (a、b为常数） 除留余数法： hash(key) = key % p (p为素数, p = Tablesize） 数字分析法： hash(key) = atoi(key + 7) 分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址 折叠法：把关键词分割成位数相同的几个部分，然后叠加 平方取中法 常用字符key散列函数位移法12345678Index hash(const char *key, int tableSize) &#123; unsigned int h = 0;// 散列函数值，初始化为0 while (*key != ‘\\0’) &#123;// 位移映射 h = (h &lt;&lt; 5) + *key==; &#125; return h % tableSize;&#125; 处理冲突开放地址法 Open Addressing一旦产生冲突(该地址已有其他元素)，就按某种规则去寻找另一空地址； 若发生了第 i 次冲突，试探的下一个地址将增加di，基本公式是：hashi(key) = (hash(key) + di) % tableSize (1 ≤ i &lt; tableSize)(di 决定了不同的解决冲突方案：线性探测di = i、平方探测di = ± i2、双散列di = i * hash2(key)) 注意：在开放地址散列表中，删除操作要很小心。通常只能“懒惰删除”，即需要增加一个“删除标记(Deleted)”，而并不是真正删除它。以便查找时不会“断链”。其空间可以在下次插入时重用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*开放地址法*/#define tablesize 10//定义hash表的长度 typedef int HashTable[10];typedef int KeyType; #include &lt;iostream&gt;using namespace std; //Searchint Search_HashTable(HashTable ht, KeyType key)&#123; int address = key % tablesize; int comparetimer = 0; //aviod the loop of death. while(comparetimer &lt; tablesize &amp;&amp; ht[address] != key &amp;&amp; ht[address] != -1) &#123; comparetimer ++; address = (address + 1) % tablesize; // *****sequence probing. ***** &#125; if(comparetimer == tablesize) return -1; return address; // no match if ht[address] = -1.&#125; //Insertint Insert_HashTable(HashTable ht, KeyType key)&#123; int address; address = Search_HashTable(ht, key); if(ht[address] == -1) &#123; ht[address] = key; return 1; //insert success. &#125; else return -1; //the key has been insert into the hashtable yet,or the HashTable is full.&#125; //initializationvoid Initial_HashTable(HashTable ht)&#123; for(int i = 0; i &lt; tablesize; i++) &#123; ht[i] = -1; &#125; 线性探测法(Linear Probing)平方探测法（Quadratic Probing)如果散列表长度TableSize是某个4k+3（k是正整数）形式的素数时，平方探测法就可以探查到整个散列表空间。 双散列探测法再散列 当散列表元素太多(即装填因子α太大）时，查找效率会下降 实用最大装填因子一般取 0.5 &lt;= α&lt;= 0.85 当装填因子过大时，解决的方法是加倍扩大散列表，这个过程叫做“再散列（Rehashing）” 分离链接法（Separate Chaining）分离链接法：将相应位置上冲突的所有关键词存储在同一个单链表中123456789101112131415161718192021struct ListNode;typedef struct ListNode *Position, *List;struct HashTbl;typedef struct HashTbl *HashTable; struct ListNode&#123; ElementType Element; Position Next;&#125;;Position Find( ElementType Key, HashTable H ) &#123; Position P; List L; L = &amp;( H-&gt;TheLists[ Hash( Key, H-&gt;TableSize ) ] ); P = L-&gt;Next; while（ P != NULL &amp;&amp; strcmp(P-&gt;Element, Key)） &#123; P = P-&gt;Next; &#125; return P;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* 链地址法*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #define tablesize 5typedef int ElemType; typedef struct HashNode &#123; ElemType elem; // 记录key值，出现冲突时确定结点 struct HashNode *next; &#125;HashNode; typedef struct &#123; HashNode ChainHash[tablesize]; int count; &#125;HashTable; int hash_mod(ElemType key) &#123; return key % tablesize; &#125; void InsertHash(HashTable *h, int key) &#123; HashNode *p; int index; p = (HashNode*)malloc(sizeof(HashNode)); p-&gt;elem = key; index = hash_mod(key); p-&gt;next = h-&gt;ChainHash[index].next; h-&gt;ChainHash[index].next = p; h-&gt;count++; &#125; void CreateHashTable(HashTable *h, int n) &#123; int key; int i; for(i = 0; i &lt; n; i++) &#123; printf(&quot;Input the %d key :&quot;, i+1); scanf_s(&quot;%d&quot;, &amp;key); InsertHash(h, key); &#125; &#125; void PrintHashTable(HashTable *h) &#123; int i; HashNode *p; for(i = 0;i &lt;= tablesize; i++) &#123; p = h-&gt;ChainHash[i].next; while(p) &#123; printf(&quot;%-5d&quot;, p-&gt;elem); p = p-&gt;next; &#125; &#125; &#125; int SearchHash(HashTable *h, int key) &#123; HashNode *p; int index; int counter = 0; index = hash_mod(key); p = h-&gt;ChainHash[index].next; while(p) &#123; if(p-&gt;elem == key) return 1; else p = p-&gt;next; &#125; return 0; &#125; 性能分析 平均查找长度(ASL）用来度量散列表查找效率：成功、不成功 关键词的比价次数，取决于产生冲突的多少,影响产生冲突多少有以下三个因素： 1.散列函数是否均匀2.处理冲突的方法3.散列表的装填因子α 装填因子（Loading Factor）：设散列表空间大小为m，填入表中元素个数是n，则称α＝ n / m为散列表的装填因子 线性探测法的查找性能 当α= 0.5时， 插入操作和不成功查找的期望 ASLu = 0.5*(1+1/(1-0.5)2) = 2.5 次 成功查找的期望 ASLs = 0.5*(1+1/(1-0.5)） = 1.5次 平方探测法和双散列探测法的查找性能 当α= 0.5时， 插入操作和不成功查找的期望 ASLu = 1/(1-0.5) = 2 次 成功查找的期望 ASLs = -1/0.5 * ln(1-0.5) ≈ 1.39 次 分离链接法的查找性能所有地址链表的平均长度定义成装填因子α，α有可能超过1。不难证明：其期望探测次数 p为：当α = 1时， 插入操作和不成功查找的期望 ASLu = 1+e-1 = 1.37 次， 成功查找的期望 ASLs = 1+1/2 = 1.5 次。 👍选择合适的散列函数，散列法的查找效率期望是常数O(1),它几乎与关键字的空间大小n无关！也适合于关键字直接比较计算量大的问题👉它是以较小的α为前提。因此，散列方法是一个以空间换时间👎散列方法的存储对关键字是随机的，不便于顺序查找关键字，也不适合于范围查找，或最大值最小值查找 开放地址法和分离链法在性能对比的优劣开放地址法👍散列表是一个数组，存储效率高，随机查找👎散列表有“聚集”现象 分离链法👍关键字删除不需要“懒惰删除”法，从而没有存储“垃圾”👉散列表是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低👎太小的α可能导致空间浪费，大的α又将付出更多的时间代价。不均匀的链表长度导致时间效率的严重下降","categories":[],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://haojiaqiang.github.io/tags/Algorithms/"}]},{"title":"操作系统原理","slug":"操作系统原理","date":"2016-09-30T01:11:25.000Z","updated":"2020-11-19T08:46:06.552Z","comments":true,"path":"2016/09/30/操作系统原理/","link":"","permalink":"https://haojiaqiang.github.io/2016/09/30/操作系统原理/","excerpt":"","text":"简介 IntroductionI/O由对应的控制器负责，CPU一般不直接负责I/O控制器都有对应的缓冲区 &gt; 控制器发送中断信号 &gt; CPU根据中断信号执行对应的中断处理程序陷阱：由程序自身产生的特殊的中断 多级缓存数据一致性： 写通过 write-through 操作系统服务（Operation System Structure）操作系统亦可称为中断驱动系统 分类： 批处理 Batch:早期解决方案 》 提高资源利用率，但不支持实时交互 多道 Multiprocessor: 分时 Time-sharing:CPU的运行分时间片（一般1ms，&gt;上下文切换时间）,轮转时间片，最适合交互的通用型系统 实时系统 Real Time:及时性，独占性（如导弹控制机）专用性系统 关系 与硬件的关系 控制CPU工作访问存储器设备驱动、中断处理 与用户及其他软件的关系 控制管理提供方便的用户界面和优质服务 系统调用(System Call)操作系统提供给用户的程序接口。内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，并将处理结果返回给应用程序 存储管理存储保护通过基址寄存器base(起始值)&amp;&amp;界限 寄存器length等用作保护，判断目标区域是否在对应的内存访问区域base~base+length，如果不是，则越界访问中断 存储扩充提供虚拟存储技术，扩大逻辑主存 Processes概念进程是程序的一次运行过程。 进程控制块PCB(Process Control Block)是一个有结构的系统存储区间，用以保存进程执行过程中相关信息，描述进程与其他进程、系统资源的关系以及进程在各个不同时期所处的状态。每一被创建进程都有自己的PCB，系统通过PCB感知进程的存在，是进程存在的唯一标志 PCB: Process state Program Counter CPU registers CPU scheduling information Memory-management information Accounting information I/O status information 进程状态(Process State)进程执行过程中所处的状态。有就绪(Ready)、执行(Running)、等待(Waiting)等至少三个基本状态，实际操作系统中，进程状态设置有所不同 就绪(Ready)：进程已经获得了除cpu之外的全部资源，等待系统分配cpu，一旦获得cpu，进程就可以变为运行态 执行(Running)：正在cpu上执行的进程所处的状态。在单cpu系统中，任何时候最多只能有一个进程处于运行状态 等待/阻塞(Waiting/Blocked)：正在运行的进程因等待某个条件发生而不能运行时所处的状态。处于阻塞态的进程在逻辑上是不能运行的，即使cpu空闲，它也不能占用cpu 进程队列 Process Queue进程根据其状态处于不同的队列，并随着状态变化在各队列之间迁移 进程调度 Process Scheduling选择一个可用的进程（可能从多个可用进程集合中选择）到CPU上执行 短程调度（Short-term Scheduler,又称进程调度、CPU调度或低级调度）按照一定算法，从就绪队列选择满足条件的进程，分配CPU,进入运行状态。进程调度执行频率高 长程调度（Long-term Scheduler,又称作业调度或高级调度)按照一定算法，从磁盘后备队列中选择满足条件的作业，创建进程，入就绪队列。作业调度控制多道程序中的“道数”，执行频率较低 中程调度（Medium-term Scheduler,又称中级调度)按照一定算法或原则，将内存中部分进程换出（Swap Out)到磁盘交换区，或者将处于磁盘交换区的进程换入(Swap In）内存就绪队列 上下文 - 进程的运行环境 用户级上下文 进程的代码、数据、共享内存、用户栈 该进程虚拟地址空间 在请求页式系统中，该级上下文内容不必全部进入内存 寄存器上下文 程序计数器PC 处理机状态寄存器PS 栈指针SP 通用寄存器组：保存进程运行过程中所产生的中间结果 系统级上下文 每个进程的 进程user结构 进程区表表项、也表，用于从虚拟地址到无力地址的转换 进程核心栈 上下文切换（Context Switch)当进程调度选中某一进程执行时，需要保存（Save）当前进程执行相关状态，并装入（Load）被选中进程已经保存的相关状态，这个过程称之为上下文切换。上下文切换属于系统消耗（Overhead) 进程通讯(Inter-process Communication)进程间交换数据或信息保持协调的一种机制，一般分为消息通讯(Message Passing)与共享主存(Shared Memory)两种通讯方式 分类 消息传递(通过系统调用send() &amp;&amp; receive()，通过全权限的系统控制内存区域达到信息传递) 共享内存(对有公共内存访问的进程之间的通讯) 多道程序设计(Multi-programming)是在计算机内存中同时存放几道相互独立的程序，是它们在管理程序控制之下，相互穿插的运行。两个或两个以上程序在计算机系统中同处于开始和结束之间的状态，就称为多道程序技术 特点 多道 宏观上并行 微观上串行 程序的一些特性 顺序性(Sequential)：是指顺序程序所规定的每个动作都在上个动作结束后才开始的特性 封闭性(Closeness)：是指只有程序本身的动作才能改变程序的运行环境（并发无效） 可再现性(Reproducibility)：是指程序的执行结果与程序运行的速度无关（并发无效） 并发性(Concurrency)：又称为共行性是指能处理多个同时性活动的能力。 原语(Primitive )：指操作系统中实现一些具有特定功能的程序段，这些程序段的执行过程是不可分割的，即其执行过程不允许被中断。一般通过把操作的优先级设置为最高实现 生产者消费者问题busy waitting 线程（Thread）概念有时被称为轻量级进程（Lightweight Process,LWP),是程序执行流的最小单元。一个标准的线程由线程ID,当前指令指针（PC)，寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的代码段、数据段及其他操作系统全部资源。 分类 内核级线程（Kernel Threads）：内核支持的线程 用户级线程（User Threads):通过用户级线程库（User-level Threads Libtary)管理的线程。相关名词 线程库（Thread Library):为程序员提供创建和管理线程的API。 异步取消（Asynchronous Cancellation):一个线程立即终止目标线程。 延迟取消（Deferred Cancellation）：目标线程不断的检查它是否应终止，这允许目标线程有机会以有序方式来终止自己。 CPU调度（CPU Scheduling）批处理系统中采用的调度算法 FCFS(First come first service)非抢占式的先来先服务算法：按照进程就绪的先后顺序使用CPU 特点：公平，实现简单，但是长进程后面的短进程需要等待很长时间，不利于用户体验 SRTN(Shortest Remaining Time Next)最短剩余时间优先：SJF抢占版本，即当一个新就绪进程比当前运行进程具有更短完成时间时，系统抢占当前进程，选择新就绪的进程执行 SJF(Shortest Job First )最短作业优先调度算法特点：改善短作业的周转时间，但如果源源不断有短任务到来，可能使长的任务长时间得不到运行，产生饥饿现象。 HRRN（Highest Response Ratio Next）最高响应比优先算法:是一个综合算法，调度时，首先计算每个进程的响应比R,之后总是选择R最高的进程执行。 响应比R = (等待时间+处理时间）/处理时间 交互系统中采用的调度算法 时间片轮转调度算法：每个进程被分配一个时间片，允许该进程在该时间段运行，如果在时间片结束时该进程还在运行，则剥夺CPU并分配给另外一个进程，如果该进程在时间片结束前Waiting或结束，则CPU立即进行切换。 1.当时间选择片太长，其降级为FSFS算法，引起对短的交互请求响应时间长2.当时间片选择太短，会导致频繁的进程切换，浪费CPU时间3.通常选择为20ms~50ms4.对进程表中不同进程的大小差异较大的有利，而对进程都是相同大小的不利 虚拟轮转法：主要基于时间片轮转法进行改进，解决在CPU调度中对I/O密集型进程的不友好。其设置了一个辅助队列，对于I/O型进程执行完一个时间片之后，则进入辅助队列，CPU调度时总是先检查辅助队列是否为空，如果不为空总是优先调度辅助队列里的进程，直到为空，才调度就绪队列的进程 最高优先级调度算法：选择优先级最高的进程优先执行。 1.优先级可以静态不变，也可以动态调整2.优先数决定优先级3.就绪队列可以按照优先级组织4.实现简单，但不公平，可能导致优先级低的进程产生饥饿现象5.可能产生优先级反转问题（基于优先级的抢占式算法），即一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行 多级反馈队列调度算法 1.设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，依次递减优先级2.对于各个队列进程执行时间片的大小也不同，优先级越高的队列，分配到的时间片越少3.当第一级队列为空时，再第二级队列进行调度，依次类推，各级队列按照时间片轮转方式进行调度4.当一个新进程创建后，首先把它放入第一队列的末尾。按照FCFS原则排队等待调度。当轮到该进程执行时，如它在该时间片完成，便可准备撤离系统，如果它在一个时间片结束时尚未完成，则调度程序便将该进程转入第二队列的末尾，再同样的按照FCFS原则等待调度执行。依次类推。 各种调度算法比较 Process Synchronization进程同步原子操作：单核一般通过禁止中断(提高优先级)实现，多核可通过总线锁等方式实现 方式 软件：临界区【访问(互斥)临界资源的代码段】 硬件：特殊指令 信号量 临界区特点： 1.忙则等待(互斥)2.空闲让进3.有限等待(避免饥饿)4.让权(CPU)等待 Semaphore 信号量结构1234typedef struct &#123; int value; struct process *list;&#125; semaphore P/wait() 原语操作-1; V/signal() 源于操作+1; 解决busy waiting问题 &gt; 互斥锁效果定义semaphore为一个包含链表的结构，当一个task执行wait()操作发现信号量值不为正，将该task置为waiting状态等待，并将task.pcb加入到semaphore的list链表中。当semaphore执行signal()之后，通过list链表获取task并通过wakeup(task)切换到reading等待CPU调度 spinLock自旋锁执行单元轮询检查锁变量是否可用，该单元一直处于忙等状态 优点：线程在等待锁时不进行上下文切换，效率高（适用于占用锁时间短的场景，多处理器情况下可以可由非执行处理器进行busy waiting） 缺点：忙等状态浪费CPU资源 互斥锁执行单元当锁不可用时被置为waiting,当锁可用时被调度到reading 优点：锁不可用时不被调度，不浪费CPU资源 缺点：需要上下文切换 Monitors管程/监视器/秘书进程 概念：是一种程序结构，结构内的多个子程序(对象或模块)形成的多个工作线程互斥访问共享资源。 特点：封装了同步操作，对线程隐蔽了同步细节，简化了同步功能的调用 优势：解决信号量的PV操作由各线程自由控制，分散不易管理的问题。 1、把分散在各进程中的临界区集中起来进行管理；2、防止进程有意或无意的违法同步操作；3、便于用高级语言来书写程序，也便于程序正确性验证。 语法1234567891011121314151617monitor monitor name&#123; // shared variable declarations procedure P1(...) &#123; ... &#125; procedure P2(...) &#123; ... &#125; ... procedure Pn(...) &#123; ... &#125; initialization code (...) &#123; ... &#125;&#125; Turnstile十字转门一种数据抽象，用来封装休眠队列和互斥锁和读/写锁相关的优先级继承信息。用来解决休眠队列在处理其他资源等待时无法通过优先级继承处理优先级反转问题 transaction事务执行单个逻辑功能的一组指令或操作，是一个原子执行的程序单元。当多个事务重叠执行时，为保证串行化，常用以下并发控制方案： 加锁协议时间戳顺序协议 deadlock 死锁两个或两个以上的执行单元在执行过程中，因竞争资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进，此时系统所处的状态称为死锁。 四个必要条件 互斥：至少一个资源，一次只能被一个线程使用，不能共享 占有并等待：线程已经拥有部分资源，还需要等待正在被其他线程使用的资源 非抢占式资源：线程获得的资源，只能由自己主动释放，而不能被强行剥夺 环路等待：一组进程之间对资源的拥有与申请构成环路 死锁防止（Deadlock Prevention）要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态 死锁避免(DeadlockAvoidance)对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。就是说，在资源分配过程中若预测有发生死锁的可能性，则加以避免。这种方法的关键是确定资源分配的安全性 安全序列(Security Sequence)针对当前分配状态来说，系统至少能够按照某种次序为每个进程分配资源（直至最大需求），并且使他们依次成功地运行完毕，这种进程序列{p1,p2,…,pn}就是安全序列。 死锁避免算法资源分配图算法银行家算法 安全性算法 资源请求算法 死锁检测死锁恢复应用终止资源抢占内存管理空间分片 大小不等的区域 – 分区/分段存储管理 大小相等的片 – 页式存储管理 二者结合 – 段页式存储管理 几个概念 物理地址(绝对地址、实地址)物理地址是计算机主存单元的真实地址，又称为绝对地址或实地址 主存空间物理地址的集合所对应的空间组成了主存空间 逻辑地址(相对地址、虚地址)用户的程序地址（指令地址或操作数地址）均为逻辑地址 作业地址空间用户程序所有的逻辑地址集合对应的空间 主存管理功能 实现逻辑地址到物理地址的映射 主存分配 存储保护 主存扩充 地址映射 by 内存管理单元MMU逻辑地址 -&gt; 物理地址 地址映射的时机和类别 编程/编译时期 &gt; 绝对代码 load时期 &gt; 可重定位代码（静态地址映射） 运行时期 &gt; 每条指令和数据访问时才进行映射（动态地址映射） 主存分配 构造分配用的数据结构主存资源信息块：等待队列；空闲区队列；主存分配程序 制定策略 主存分配策略 - 在众多请求者中选择一个请求者的原则放置策略 - 在可用资源中，选择一个空闲区的原则调入策略 - 决定信息装入主存的时机(分预调策略和请调策略)牺牲策略 - 当主存已满，决定哪些信息从主存中移除 实时主存分配与回收 主存分配方式 连续分配 离散分配 分页 分段 段页式 主存扩充 可行性 局部性特征 实现方法 程序的代码和数据存放在辅存中将程序当前执行所涉及的那部分程序代码放入主存中程序执行时，当所需信息不在主存(Page fault缺页)，由操作系统和硬件相配合来完成主存从辅存中调入信息，程序继续执行 虚拟存储器由操作系统和硬件相配合来完成主存和辅存之间的信息的动态调度。这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器 虚拟存储器的核心 逻辑地址与物理地址的分离 存储空间与虚拟地址空间的分离 提供地址变换机构 实现虚拟存储器的物质基础 有相当容量的辅存 足以存放应用程序的虚拟地址空间 有一定容量的主存 存放进入主存的多进程的信息 地址变换机构 存储保护 什么是存储保护在多用户环境中，主存存储器按区分配给各用户程序使用。为了互不影响，必须由硬件（软件配合）保证各用户程序只能在给定的存储区域内活动，这种措施叫做存储保护 实现方法 界地址保护(常用的base + length) 存储键保护 内存分区分配算法 首次适应算法 1首次适应是从空闲链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止，然后按照作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍然留在空闲链中。若从头到尾都不能找到一个能满足空间要求的分区，则此次内存分配失败。该算法倾向优先使用内存中低地址部分的空闲分区，从而保留了高址部分的大空闲区，为后续到达的大作业分配大的内存空间创造了条件。那么相反，每次都从空闲链首开始查找，低地址部分不断的被划分就会导致产生许多难以利用的、很小的空闲分区，同时也会增加每次查找的开销 循环首次适应算法 1就是在首次适应算法的基础上添加了循环的功能，使用该算法为进程分配内存空间时，不再从头开始，而是从上次分配的位置为起点的下一个分区为起点开始查找，其余与首次适应算法相同。这样就解决了每次从头开始查找开销大的问题，但是这样在多次分配之后也会导致缺乏大的空闲分区 最佳适应算法 1最佳适应是在每次分配时将**能满足要求的最小的**空闲分区分配给作业，避免了大材小用。为了加速查找，该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链，这样，从该空闲分区链中查找到的第一块符合要求的空闲区必然是最佳的。但是最佳适应算法也是有缺点的，每次分配的是最佳，那么剩余的空闲将会是尽可能的小，就会导致小的空闲分区无法分配给作业，就会在存储器中留下许多难以利用的小空闲区 最坏适应算法 1与最佳适应算法正好相反，最坏适应算法是挑选一个最大的空闲分区给作业分配使用，其优点是可使剩余空间不至于太小，产生碎片的几率最小，对中、小作业有利。同时，该算法要求所有的空闲分区按其容量以从大到小的顺序形成空闲分区链，查找时只要看第一个分区能产生否满足要求即可。，那么它的缺点就对应是缺少大的空闲分区 快速适应算法 123又称为分类搜索法，是将空闲分区根据其容量按照大小进行分类，对每类相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，就会在系统中存在多个空闲分区链表，同时会在内存中设立一张管理索引表，该表的每一个表项对应一种空闲分区类型，并记录该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分，比如2k、4k、8k等，对于特殊大小的分区，如7k大小，即可放在特殊的分区中，也可放在8k分区的链表当中。该算法的优点是查找效率高，仅需要根据进程的长度，寻找到能容纳它的最小空间区链表，并取第一块进行分割即可。另外该算法在进行空闲分区分配时不会对任何分区产生分割，所以能保留大的分区，也不会产生内存碎片。缺点是在进行分区归还时算法复杂，系统开销大。 ps：1、2、3、4四种算法也称为顺序搜索法 碎片问题及碎片整理 碎片问题 在已分配区之间存在着的一些没有被充分利用的空闲区 碎片整理 移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲 内存分区分配常用的数据结构 空闲分区表 1在系统中设置一张空闲分区表，用于记录，每个空闲分区的情况，每个空闲分区占一个表目，表中包括分区序号，分区开始地址以及分区的大小等数据 空闲分区链 1这个数据结构是在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各个分区所用的前后指针，这样可以将所有的空闲分区链接成一个双向链，为了检索方便，在分区尾部重复设置状态位和分区大小表目，当分区已分配，则将状态位由0改为1，此时前后向指针失去作用 页式存储管理页面程序的地址空间被等分成大小相等的片，称为页面，又称为虚页 主存块主存被分成大小相等的片，称为主存块，又称为实页 页表概念为了实现从地址空间到物理主存的映像，系统建立的逻辑页与物理页帧之间对应关系的地址变换的机构称为页面映像表，简称页表 注意：页表包含在系统空间的PCB中 页表的组成 高速缓冲存储器 – 地址变化速度快，但成本较高 主存区域 – 地址变换速度比硬件慢，相对成本较低使用联想存储器加快页表查询速度 使用联想存储器 高速、小容量半导体存储部件，又称缓冲存储器 使用快表缓存 在缓冲存储器中存放正在运行的进程当前用到的页号和对应的块号，又称快表 缺页处理 抖动/颠簸导致系统效率急剧下降的主存和辅存之间的频繁页面置换现象 内存淘汰算法 LRU（Least Recently Used，最少最近使用算法）1计时法:给页表中的每一页增加一个域，专门用来存放计时标志，用来记录该页面自上次被访问以来所经历的时间。页面每被访问一次，计时清0。要装入新页时，从内存的页面中选出时间最长的一页，调出，同时把各页的计时标志全部清0，重新开始计时。 计时法可以稍作改变，成为计数法：页面被访问，计数标志清0，其余所有内存页面计数器加1；要装入新页时，选出计数最大的一页调出，同时所有计数器清0。 1链表法:操作系统为每个进程维护一条链表，链表的每个结点记录一张页面的地址。调用一次页面，则把该页面的结点从链中取出，放到链尾；要装入新页，则把链头的页面调出，同时生成调入页面的结点，放到链尾。链表法可看作简单计时/计数法的改良，维护一个链表，自然要比维护所有页面标志要简单和轻松。可是，这并没有在数量级上改变算法的时间复杂度，每调用一个页面，都要在链表中搜寻对应结点并放至链尾的工作量并不算小。 FIFO（先进先出算法） 12顾名思义，最先被置换进内存的页面最先出来，公正公平，大家都别抢，但是不一定合理，能者要多劳啊。最先进去的页面，比如一些初始化性质的页面，通常在整个程序运行期间都是需要，被置换出去非常不合理。 NRU（Not Recently Used，最近未使用算法，又称CLK算法） 123456781. 给每一帧关联一个附加位，称为使用位2. 当某一页首次装入主存时，该帧的使用位设置为13. 当该页随后再被访问到时，它的使用位也被置为14. 对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联5. 当某一页被替换时，该指针被设置成指向缓冲区中的下一帧6. 当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为07. 如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换8. 如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页 段式地址空间概念分段是程序中自然划分的一组逻辑意义完整的信息集合。* 代码分段 数据分段 栈段页 作业地址空间由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，它是一个连续的地址区 段式地址结构 段号 w 段内位移 s 段式地址步骤 取出程序地址(s, w） 用s检索段表 （Base + w)即为所需主存地址 如w&lt;0或w≥Length则主存越界 页式系统与段式系统的区别用户地址空间的区别 页式系统中用户地址空间 – 一维地址空间 段式系统中用户地址空间 – 二维地址空间 分段和页面的区别 分段 页面 信息的逻辑划分 信息的物理划分 段长是可变的 页的大小是固定的 用户可见 用户不可见 w字段的溢出将产生越界中断 w字段的溢出自动加入到页号中 段页式系统在段式存储管理中结合分页存储管理技术，在一个分段内划分页面，就形成了段页式存储管理 存储管理技术 Swap对换技术 在主存和交换设备之间传递整个进程映像，而不是进程的一个部分(早期采用) 请求调页技术 在主存和交换设备之间传递存储页，而不是整个进程的映像 文件管理文件系统用于支持数据在磁盘的存储、定位与检索，实现对磁盘的有效、便捷访问；文件系统提供了在线存储和访问计算机操作系统和所有用户的程序与数据的机制。包括2个组成部分：一组文件和目录结构 文件概念文件是记录在外存上的相关信息的具有名称的集合。根据其类型具有特定结构。 属性 名称：符号名称是唯一的、按照人们容易读取的形式保存 标识符：标识文件系统内文件的唯一标签，通常为数字；对用户而言这是不可读文件名称 类型：被支持不同类型的文件系统所使用 位置：该信息为指向设备和设备上文件位置的指针 大小：文件当前大小(以字节、字或块来统计)，该属性页可包括文件允许的最大容量值 保护：决定谁能读、写、执行等的访问控制信息 时间、日期和用户标识：文件创建、上次修改和上次访问的相关信息。这些数据用于保护、安全和使用追踪 操作 创建文件 写文件 读文件 在文件内重定位 删除文件 截短文件 文件系统实现分配方案 连续分配 链接分配 I/O输入系统成熟的中断处理特性： 在进行关键处理时，能够延迟中断处理特性 更为有效地将中断分发到合适的中断处理程序，而不是检查所有设备以决定哪个设备引起中断 需要中断优先级，这样操作系统能区分高优先级或低优先级的中断，能根据紧迫性的程度来响应 安全最小特权原则：它规定程序、用户，甚至包括操作系统仅拥有它们能够完成其任务的特权。","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://haojiaqiang.github.io/tags/OS/"}]},{"title":"Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法","slug":"Effective-Objective-C-2-0","date":"2016-09-08T02:41:16.000Z","updated":"2018-11-21T14:27:47.008Z","comments":true,"path":"2016/09/08/Effective-Objective-C-2-0/","link":"","permalink":"https://haojiaqiang.github.io/2016/09/08/Effective-Objective-C-2-0/","excerpt":"","text":"1.属性 属性 = 成员变量 + getter + setter； 成员变量 = 偏移量(表示该变量 距存放该变量的对象的起始地址有多远) 关键字@synthesize:合成成语成员变量、指定成员变量名称@dynamic:告诉编译器后面会有getter &amp; setter但不合成getter &amp; setter 2.对象等同性 objFun == objFoo,地址相等 isEqual:默认比较地址的方法 12345678910111213141516- (BOOL)isEqual:(id)object &#123; if ([self class]) == [object class]) &#123; return [self isEqualToFoo:object]; &#125; return [super isEqual:object];&#125;- (BOOL)isEqualToFoo:(Foo *)foo &#123; if (self == foo) return YES: if (! [_fun isEqualToString:foo.fun]) &#123; return NO; &#125; ... return YES;&#125; hash:被用做对象 collection中检索时的索引，hash相同的两个对象不一定相等，两个相等的对象一定hash相同，减少hash碰撞和hash性能但不可避免碰撞 标准写法123456- (NSInteger)hash &#123; NSInteger funHash = [_objFun hash]; NSInteger fooHash = [_objFoo hash]; NSInteger exampleHash = _example; return funHash ^ fooHash &amp; exampleHash;&#125; 3.关联对象(3个方法) set associated object(value可以是block,当value==nil即清空该关联object) 1void objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,id _Nullable value, objc_AssociationPolicy policy) get associated object 1id objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key) remove all associated object 1void objc_removeAssociatedObjects(id _Nonnull object) 4.objc_msgSend 原理：动态绑定12345678910111213141516void funFunc() &#123;&#125;void fooFunc() &#123;&#125;void doTheThing(int type) &#123; void (*func) (); if (type == 0) &#123; func = funFunc(); &#125; else &#123; func = fooFunc(); &#125; func(); return 0;&#125; 2.发送消息 1.主函数1void objc_msgSend(id self, SEL cmd,...); 2.消息转换成函数12345id returnValue = [someObject messageName:parameter];实际处理为：id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter); 3.edge case交由另外一些函数来处理123objc_msgSend_stret；//处理返回值为结构体的消息objc_msgSend_fpret；//处理返回值为浮点数的消息objc_msgSendSuper；//处理给超类发送的消息，如[super message:parameter] 消息缓存在method_list中查询到对应的method,objc_msgSend会将匹配结果缓存在“快速映射表(fast map)”里面，每个类都有这样一块缓存。objc_msgSend每次查找SEL对应的IMP会首先去cache里面查找，然后再是method_list，再然后super cache,super method_list 归纳1.消息由接受者、选择子及参数构成。给某对象“发送消息”(invoke a message)也就是相当于在该对象上“调用方法”(call a method)2.发给某对象的全部消息都要由“动态消息派发系统”（dynamic message dispatch system)来处理，该系统会查出对应的方法，并执行其代码 5.消息转发机制1.触发原因及默认实现 对象接收到无法解读的消息后，就会启动“消息转发(message forwarding)”机制，程序员可经由此过程告诉对象应该如何处理未知消息 如果没有处理异常，默认实现：消息转发给NSObject，@selctor(doesNotRecognizeSelector：) 2.message forwarding 2大阶段深入浅出Cocoa 消息转发 1. 动态方法解析 dynamic method resolution 原理：第一阶段先征询接受者所属的类，看其是否能动态添加方法，以处理当前这个unknown selector,叫做动态方法解析 方式：我们只要实现 +resolveInstanceMethod:/+resolveClassMethod: 方法，并在其中为指定的selector提供实现即可（通过调用运行时函数class_addMethod来添加）。这两个方法都是 NSObject 中的类方法，其原型为：12+ (BOOL)resolveInstanceMethod:(SEL)sel；&lt;br&gt;+ (BOOL)resolveClassMethod:(SEL)sel； 1BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) 参数sel是需要被动态决议的 selector；返回值文档中说是表示动态决议成功与否。但在上面的例子中（不涉及消息转发的情况下），如果在该函数内为指定的 selector 提供实现，无论返回 YES 还是 NO，编译运行都是正确的；但如果在该函数内并不真正为 selector 提供实现，无论返回 YES 还是 NO，运行都会 crash，道理很简单，selector 并没有对应的实现，而又没有实现消息转发。 下面我们用动态方法决议手段来修改上面的代码：1234567891011121314151617void dynamicMethodIMP(id self, SEL _cmd) &#123; // method implementation&#125;+ (BOOL)resolveInstanceMethod:(SEL)name&#123; if (name == @selector(MissMethod)) &#123; class_addMethod([self class], name, (IMP)dynamicMethodIMP, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:name];&#125;+ (BOOL)resolveClassMethod:(SEL)name&#123; return [super resolveClassMethod:name];&#125; 2. 备援接受者1234// 返回一个可以处理self不能响应的selector的对象，此特点可以模拟出“多重继承”- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return aCapableObject;&#125; 3. 完整的消息转发1234// 首先创建NSIvocation对象，把尚未处理的那条消息有关的细节全部封到其中,传递到此方法中- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; // do something with invocation&#125; 注意：接收者在每一步中均有机会处理消息。步骤越往后，处理消息的代价就会越大。最好能在第一步就完成，这样的话，运行期系统就可以将此方法缓存起来。如果这个类的实例后面还收到同名的选择子，那么根本就无须启动消息转发流程。若想在第三步把消息转发给备援接收者，还不如把转发操作提前到第二步。以为第三步只是修改了调用目标，这项改动放在第二步执行的话会更加简单，不然还得创建并处理完整的NSIvocation。 6.方法调换方法用函数指针的形式表示，这种指针叫做IMP,其原型如下1id (*IMP)(id, SEL,...) 123456789101112131415161718192021222324252627/// 交换方法函数- (void)exchangeImpMethod &#123; Method originalMethod = class_getInstanceMethod([self class], @selector(originMethod)); Method customSwappedMethod = class_getInstanceMethod([self class], @selector(customSwappedMethod)); method_exchangeImplementations(originalMethod, customSwappedMethod);&#125;/// 相关代码- (void)performExchangeImpMethod &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self exchangeImpMethod]; &#125;); [self originMethod];&#125;- (void)originMethod &#123; DLog(@&quot;&gt;&gt; call originMethod&quot;);&#125;- (void)customSwappedMethod &#123; DLog(@&quot;&gt;&gt; do something in swappedMethod&quot;); [self customSwappedMethod];// 非死循环&#125; 7.理解类对象12345678910111213141516171819202122232425262728293031323334353637383940414243// idtypedef struct objc_object &#123; Class isa;&#125; *id;// Classtypedef struct objc_class *Class;struct objc_class &#123; Class isa; // instance:类 &amp;&amp; class:元类 Class super_class; // 继承关系 const charchar *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct objc_cache *cache; struct objc_protocol_list *protocols; &#125; // NSObject@interface NSObject &lt;NSObject&gt; &#123; Class isa; &#125; ``` # 2. 接口与API设计## 1. 指定/全能初始化方法&gt; 1.在类中提供一个全能初始化方法，并于文档中说明。其他初始化方法均应调用此方法&lt;br&gt;&gt; 2.若全能初始化方法与super不同，则需覆写超类中的对应方法&lt;br&gt;&gt; 3.若super的初始化方法不适用于子类，则应该覆写这个super方法，并在其中抛出异常&lt;br&gt;&gt; 4.子类中的初始化方法应该先调用super的相关方法，然后再执行与本类有关的任务&lt;br&gt;## 2. 尽量不要对外暴露可变对象&gt;1.不把可变的collection作为属性对外暴露，而是对外暴露一个readonly的不可变collection，提供一个相关方法修改可变collection，返回一个不可变的copy## 3.异常&gt; 1.只有发生了重大的可致使整个app崩溃的严重错误时，才应使用异常&lt;br&gt;&gt; 2.在错误不那么严重时，可通过delegate来处理错误，也可以把错误信息放在NSError对象里，经由“输出参数”返回给调用者&lt;br&gt;## 4.异常安全代码的内存管理问题 @try { object…}@catch (…){ }@finally { // release object 但ARC无法手动调用内存管理语句}12345678910注意：&gt; 1.`ARC默认不对异常安全代码进行内存管理`（针对此种case ARC需要加入大量的样本代码，且严重影响性能），如果需要管理，可以通过`打开编译器标志：-fobjc-arc-exceptions实现`&lt;br&gt;&gt; 2.@try会保留对内部对象object的引用，需要释放&lt;br&gt;&gt; 3.如果编译器处理Objective-C++模式，因为C++处理异常的代码与ARC实现的附加代码类似，并且C++会频繁的使用异常，故而添加ARC附加异常处理代码性能损失不大，故Objective-C++模式下自动开启-fobjc-arc-exceptions## 5.自动释放池 autoReleasePool`自动释放池机制就像&quot;栈(stack)&quot;一样`。系统`创建好autoReleasePool后就将其推入栈中`。而`清空autoReleasePool`，则相当于`将其从栈中弹出`。`向对象发送一个autoRelease消息，就等于将其放入栈顶的autoReleasePool`注意⚠️：&lt;br&gt;**ARC不可用**&lt;br&gt; NSAutoreleasePool autorelease方法(NSObject)12**ARC可用** @autoreleasepool{ }; //用法for (int i = 0; i &lt; 10000; i++) { @autoreleasepool { NSNumber *number = [self creatNumberWithInt:i]; [number autorelease]; [arrM addObject:number]; }}1234567# 3. 内存管理## 1. Block1. Block可视为对象，实际上`block可以响应很多`OC对象可以响应的`selector`。最重要的一点，`block也有引用计数`2. 全局block，栈block,堆block&lt;br&gt;栈block拷贝成为堆block,堆block与OC对象一样，具备引用计数&lt;br&gt;3. 值捕获`block`捕获对象类型，`如果捕获_成员变量,那么`该成员变量`所属的对象也被捕获了` ^ (id data){ _data = data;// self被捕获了 } 123456789101112## 2. performSelectorperformSelector系列方法在内存管理方面容易有疏失。它无法确定将要执行的selector具体是什么，有无返回值等，因而ARC编译器无法插入适当的内存管理语句## 3.Foundation与Core Foundation的桥接### 1. 概念:桥接：在Foundation框架中的对象和Core Foundation框架中的变量之间进行类型转换&lt;br&gt;* Core Foundation比Foundation框架更加底层，是纯C语言的框架&lt;br* Foundation框架在Core Foundation框架的基础上进行封装，增加了面向对象的思想&lt;br&gt;### 2. Foundation 转 Core Foundation1. 不转移控制权 `__bridge targetType` stringC = (__bridge CFStringRef)stringOC; 123 只是把`stringOC`所指向对象的地址交给了`stringC`，原来对象的所有权属于`stringOC`，转换之后还是属于`stringOC`，原来是由`stringOC`管理的内存，现在还是由`stringOC`管理，在`ARC`环境下，`stringOC`可以自动释放2. 转移控制权 `__bridge_retain CF type`/`CFBridgingRetain` strC = (__bridge_retain CFStringRef)strOC1234567* 把`Foundation`框架的对象转换成`Core Foundation`框架的变量* 同时转让对象的所有权，把对象的所有权从`stringOC`转移给`stringC`，原来是由`stringOC`管理的内存，现在让`stringC`来管理，需要手动释放，调用`CFRelease`方法* `CFBridgingRetain`方法和它等价 ### 3. Core Foundation 转 Foundation 1. 不转移控制权 `__bridge targetType` stringOC = (__bridge NSString *)stringC; 123只是把`stringC`所指向变量的地址交给了`stringOC`，原来变量的所有权属于`stringC`，转换之后还是属于`stringC`，原来是由`stringC`管理的内存，现在还是由`stringC`管理，需要手动释放，调用`CFRelease`方法2. 转移控制权`__bridge_transfer Objective-C type`/`CFBridgingRelease` stringOC = (__bridge_transfer NSString*)stringC; 123456* 把`Core Foundation`框架的变量转换成`Foundation`框架的对象* 同时转让变量的所有权，把变量的所有权从`stingrC`转移给`stringOC`，原来是由`stringC`管理的内存，现在让`stringOC`来管理，在`ARC`环境下，`stringOC`可以自动释放* `CFBridgingRelease`方法和它等价### 4.归纳1. 桥接 __bridge//只做类型转换，但是不修改对象（内存）管理权; 1 __bridge_retain //（也可以使用CFBridgingRetain）将Objective-C的对象转换为Core Foundation的对象,同时将对象（内存）的管理权交给我们,后续需要手动使用CFRelease或者相关方法来释放对象; 1 __bridge_transfer//（也可以使用CFBridgingRelease）将Core Foundation的对象转换为Objective-C的对象,同时将对象（内存）的管理权交给ARC自动管理，无需手动释放 ` 4. 精简initialize与load的实现代码+ (void)load 调用时机程序启动时，载入类和分类文件就会调用此方法，会把所有类和分类的load方法全部调用，且仅调用一次，调用load方法是依次阻塞执行的，完成之后程序才进入可用状态 特别之处 load方法不遵循那套继承规则，如果某类没有实现load方法，那么不管其各类super是否实现此方法，系统都不会调用[super load] 分类和所属的类里都实现load方法，本类和分类的load方法都会调用，本类的实现比分类的实现先执行 + (void)initialize（推荐把load中的操作移动到initialize） 调用时机程序首次使用该类之前调用，懒加载，且只会调用一次。 特别之处 懒加载，且调用时机是程序处理正常状态时 线程安全的 遵守继承规则，如果本类没有override initialize，就会调用[super initialize] 可参考另一博客 Effective Objective-C 干货三步曲","categories":[],"tags":[{"name":"消息","slug":"消息","permalink":"https://haojiaqiang.github.io/tags/消息/"},{"name":"load","slug":"load","permalink":"https://haojiaqiang.github.io/tags/load/"}]},{"title":"SwiftGrammar","slug":"SwiftGrammar","date":"2016-08-03T06:00:26.000Z","updated":"2018-11-21T14:27:47.009Z","comments":true,"path":"2016/08/03/SwiftGrammar/","link":"","permalink":"https://haojiaqiang.github.io/2016/08/03/SwiftGrammar/","excerpt":"","text":"注意点 1.无隐式转换 Float(param) 通用关键字 注意: 不可以在一个实体中定义访问级别更低的实体 1.方法/属性 * internal: 在本模块(项目/bundle/target)中都可以访问,系统默认的方法/属性权限 * private: 只有在本类中才可以访问(extension亦不可访问,修饰方法是需要加@objc) * fileprivate: 在类所在文件中都可以访问 * open: 可以跨模块访问(系统类可访问的属性/方法均为open) internal/fileprivate/private(set) 改变set访问权限 * mutating: 修饰函数,表示该函数可以修改函数所属实例(属性) * subscript: 下标语法 * inout: 输入输出参数,表示传入的参数本身会在函数内被修改,需要是&amp;param指针类型,不能为let类型或者有默认值 *convenience: 便利构造器 @required: 必要的 required init(){ //构造器代码 } 2.类型 * 1.AnyObject &gt; 任意class类型 * 2.Any &gt; 任意类型,包括函数类型 * 3.as &gt; 类型转换 A as B (switch A to B) 3.文件级 SwiftCustomLogFunction 1234567func log&lt;T&gt;(message: T, file: String = #file, function: String = #function, line: Int = #line) &#123; // setting: buildPhases - Swift complier-Custom Flags - Other Swift Flags - Debug -+ -D DEBUG #if DEBUG let fileName = (#file as NSString).lastPathComponent.split(separator: &quot;.&quot;) print(&quot;&gt;&gt; \\(message) &lt;&lt; line:\\(line) \\(fileName) . \\(function)&quot;) #endif&#125; 逻辑语句 1.if &gt; Swift所有条件表达式无非0/nil即真的概念 2.guard &gt;== special if 12345678910guard 条件表达式1 else &#123; //条件1false 异常处理code return/break/continue/throw 关键字&#125; (条件1ture) 执行语句guard 条件表达式2 else &#123; //条件1true + 条件2false 异常处理 return/break/contine/throw 关键字&#125; (条件1true + 条件2true)执行语句 3.switch 123* 1.判断条件可以使:Int \\ Floaf \\ String \\ 区间范围* 2.关键字fallthrough (默认每个case 语句包含break)* 3.case 可以跟多个判断表达式 &gt; case : 条件1, 条件2 4.repeat while &gt;== do wile inOC 字符串 1.拼接 &gt; str1 + str2 2.和标识符拼接 &gt; \\(param) : “name is \\(name), age is \\(age)” 3.格式化 &gt; String(format: arguments:) : String(format: “%02d:%02d”, arguments:[min, second]); 4.as NSString用法 &gt; 常用于截取字符串场景: (urlString as NSString).substringToIndex(3) 数组 (泛型集合,一般不存放不同类型元素) initializer 12* 1. let array = [1, 2, 3, 4, 5]* 2. var arrayM = [String]() 拼接 &gt; array + array2(+ 仅限array1 与array2元素类型相同) 遍历 &gt; for param in array[0..&lt;2] { } 字典 1.initializer 12* 1. let dict = [&quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot;]* 2. var dictM = Dictionary&lt;String : anyObject&gt;() 2.增/改 删 查 123456dictM[key] = value (无key为增, 有key为改)dictM.removeValue(forKey: &quot;key&quot;) 删dictM[&quot;key&quot;]for (key, value) in dictM &#123; dictM[key] = value&#125; 元组 initializer123 * 1. let info = (name : &quot;why&quot;, age : 19, height : 1.88) &gt; info.name* 2. let info = (&quot;why&quot;, 18, 1.88) &gt; info.index &gt;= info.1* 3. let (name, age, height) = (&quot;why&quot;, 18, 1.89) &gt; name 可选类型 1.initializer 1234* 1. var name : String? = nil* 2. var name : Optional&lt;String&gt; = nil example: let errorInfo = (errorCode: 404, errorMessage: &quot;Not Found&quot;) 2.强制解包与可选绑定 1234561. optionalName! &gt; 注意:强制解包前一定要判断!= nil,否则崩溃2. if let optionalName = optionalName &#123; 执行optionalName用途 &#125; 相当于执行2步操作: 判断optionalName != nil, optionalName = optionalName! (当optionalName == nil,不执行&#123; &#125;代码) 函数 1.intializer 1234func 函数名(参数名: 参数类型, 参数名2: 参数类型) -&gt; 返回值类型 &#123; 函数代码块 return 返回值 &#125; 2.使用注意 12345678910111213141516171819202122232425262728* 1. 内部参数 &amp; 外部参数 (参数别名可见范围区分,默认第一个参数为内部参数,其余为外部参数) 参数1转换成外部参数 &gt; 在参数1前再+别名 * 2. 默认参数 func makeCoffee(coffeeName: String = &quot;雀巢&quot;) -&gt; String &#123;&#125; makeCoffee() * 3. 可变参数(参数数组) func calculator(params: Int...) -&gt; Int &#123; var result = 0 for param in params &#123; result += param &#125; return result &#125;* 4. 指针参数 func swapNum(inout m: Int, inout n: Int) &#123; let temp = m m = n n = temp &#125; swapNum(m: &amp;m, n: &amp;n)* 5. 函数嵌套 func nestFunc() &#123; func test() &#123; print(&quot;Test&quot;) &#125; print&quot;nestFunc&quot; test() &#125; #枚举1234567891011注意: Swift枚举值可以是Int,Float,character,String,并且不手动提供枚举值,系统不会默认指定,如果需要指定枚举值,则必须在枚举后指定枚举值类型定义* 1. enum CompassPoint &#123; case North case South case East case West &#125;* 2. enum Planet: Int &#123; // 可以枚举列举在一行 case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune &#125; 结构体 1.结构体是一个数据结构/值类型,在方法中是值传递, 类是指针传递 2.定义格式: struct 结构体名称 { // 属性和方法 }1234567891011121314151617181920212223 struct Location &#123; var x: Double var y: Double /// 构造函数必须确保素有成员变量都有被初始化,构造函数都不需要返回值 // 系统默认会创建此种构造函数 init(x: Double, y:Double) &#123; self.x = x self.y = y &#125; // 如果手动创建构造函数,就会覆盖默认构造函数,但可以手动再创建 init(xyString: String) &#123; let strs = xyString.components(separatedBy: &quot;,&quot;) self.x = Double(strs.first ?? &quot;0&quot;) ?? 0 self.y = Double(strs.last! ?? &quot;0&quot;) ?? 0 &#125; &#125; /// 枚举拓展 - 可以拓展系统定义的结构体extension Location &#123; mutating func move(x: Double, y: Double) &#123; // 结构体可以扩充方法,修改成员变量的方法必须+ mutating self.x += x self.x += y &#125; &#125; 类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Student : NSObject &#123; /***** 属性3种 *****/ // 初始化类的属性一般要赋值(值类型属性)或者指定可选类型(对象属性) /// 1.存储属性 var englishScore: Double = 0.0 var chineseScore: Double = 0.0 /// 2.计算属性 var averageScore: Double &#123; return (englishScore + chineseScore) * 0.5 &#125; /// 3.类属性 static var courseCount: Int = 0 /***** 构造函数 *****/ /// 1.重写构造函数 override init() &#123; super.init() // custom initCode &#125; /// 2.自定义构造函数 init(englishScore: Double, chineseScore: Double) &#123; super.init() // 可省略,init默认会调用super.init() self.englishScore = englishScore self.chineseScore = chineseScore &#125; /// 3.自定义构造函数withDictionary// init(dictT: [String : AnyObject]) &#123;// if let score = dictT[&quot;chineseScore&quot;] as? Double &#123;// chineseScore = score// &#125;// &#125; init(dict: [String : AnyObject]) &#123; super.init() setValuesForKeys(dict) &#125; override func setValue(_ value: Any?, forUndefinedKey key: String) &#123;&#125; // 必须重写防止崩溃 /***** 类方法 *****/ class func classFunc() &#123;&#125; /***** 属性监听器器 *****/ var targetValue: Int = 0 &#123; willSet &#123; /* newValue */ &#125; didSet &#123; /* oldValue */ &#125; &#125; /****** 下标语法 *****/ subscript (index: Int) -&gt; Int &#123; // 必须要有返回值 getter get &#123; return index * index; &#125; set &#123; // newValue &#125; &#125; /***** 销毁 *****/ deinit &#123; 相当于dealloc inOC &#125;&#125;Student.courseCount = 2let student = Student()student.englishScore = 78.0student.chineseScore = 80.0 可选链 1.从可选链中进行取值? &gt; 返回值是可选类型,其中任意可选为nil,则整个可选链结果为nil let toy = person.dog?.toy? 2.可选链获取目标进行赋值或调用方法 &gt; 可选链任一部分为nil,不执行后续代码\\方法 person.dog?.toy? = “Hello Kity” 协议 注意点 123450.协议作为类型,可以作为参数类型或返回值类型,集合元素类型1.协议协议遵守者可以是 class, enum, static2.代理类型的协议需要: class &gt; 这样可以用执行修饰class的weak修饰可选类型的delegate3.optional特性来自OC,需要定义optional func 需要在protocol 和该方法前 + @objc4.协议定义属性:要求协议遵守者提供协议定义的属性,使用var定义,且只定义属性的名称、类型、读写属性 用法 &amp; 把两个协议结合成一个临时局部协议 : A &amp; Bfunc wishHappyBirthday(to celebrator: NamedProtocol &amp; AgedProcotol) {print(“Happy birthday, (celebrator.name), you’re (celebrator.age)!”)} example 1234567891011121314151617@objc protocol SportProtocol &#123;//协议遵守者可以是 class, enum, static func playBasketball() @objc optional func playFootball()&#125;protocol purchaseDelegate: class &#123;// func buy()&#125;class person: SportProtocol &#123; weak var deletage: purchaseDelegate? func goForeign() &#123; deletage?.buy() &#125; // SportProtocol implementation func playBasketball() &#123; &#125;&#125; 扩展 extension 1.定义:为已有的类 结构体 枚举或者协议添加新功能 2.功能:(类似 分类 inObjc) 123451.添加计算型 类/实例属性2.定义 实例/类方法,包括构造器3.定义下标4.定义和使用新的嵌套类型5.使一个已有类型符合某个协议 3.注意 只能添加,不能重写已有功能 闭包 1.格式: 类型 (参数列表) -&gt; (返回值) 123456789闭包的写法: 类型:(形参列表)-&gt;(返回值) 技巧:初学者定义闭包类型,直接写()-&gt;().再填充参数和返回值 值: &#123; (形参) -&gt; 返回值类型 in // 执行代码 &#125; 2.闭包解决循环引用 1234567891011 方式1: == 简写方式2 tools.loadData&#123;[weak self] (jsonData) -&gt; () in &#123; self?.view.backgroundColor = UIColor.redColor &#125;&#125; 方式2: weak var weakSelf = self tools.loadData &#123; (jsonData) -&gt; () in &#123; weakSelf?.view.background = UIColor.redColor // 如果weakSelf != nil 执行语句 &#125; &#125; 3.尾随闭包 &gt; 当闭包是函数的最后一个参数,则该闭包为尾随闭包,尾随闭包函数可以将闭包提到()后,如果函数只有一个参数且为闭包,则可以省略参数列表外的() Error 1.定义 12345678910func 方法(参数) throws返回值 &#123; 条件语句 &#123;throw someError&#125; &#125; example: func age(age : Int) throws -&gt; String &#123; if age &lt; 0 &#123; throw AgeError.wrongAge // 错位定义成枚举类型, throw == return in 流程控制 &#125; return &quot;OK&quot; &#125; 2.处理 - 未被catch的error将层层传递 12345678910111213141516171. do catch do &#123; try throws类型的函数 &#125; catch 特定error &#123;// 特定error &#125; catch &#123;// 所有error &#125; example:do &#123; try student.age(age: -1)&#125; catch &#123; print(&quot;error&quot;)&#125;2. try try? &amp; try!(类似强制解包&gt;有崩溃风险)try? &gt; let str = stry? tudent.age(age: 10) 如果抛出错误,str = nil, 如果未抛出错误, str = 返回值 指定清理操作 defer 1. 用途 defer定义在即将离开当前代码块时执行的语句,离开当前代码块包括return , break, throw ERROR等 2.注意: defer语句中不能有流程控制转移,如break, return, throw ERROR等 3.顺序 多条fefer语句,反序执行,即最后的defer语句最先执行12345678910func processFile(filename: String) throws &#123; if exists(filename) &#123; let file = open(filename) defer &#123; close(file) &#125;while let line = try file.readline() &#123; // 处理文件。&#125;// close(file) 会在这里被调用，即作用域的最后。 &#125;&#125; 类型转换 1.判断字:is &gt; if (something) is (anotherThing) return true/false 2.关键字:as &gt; if let item = product as? Movie 元类型类、结构体、枚举类型的元类型: .Type / type(of: someInstance) &gt; example: SomeClass.Type协议的元类型: .Protocol &gt; example: SomeProtocal.Protocol","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://haojiaqiang.github.io/tags/Swift/"}]},{"title":"深入理解计算机系统","slug":"Computer-Systems-A-Programmer-s-Perspective","date":"2016-05-22T04:10:28.000Z","updated":"2018-11-21T14:27:47.008Z","comments":true,"path":"2016/05/22/Computer-Systems-A-Programmer-s-Perspective/","link":"","permalink":"https://haojiaqiang.github.io/2016/05/22/Computer-Systems-A-Programmer-s-Perspective/","excerpt":"","text":"1.计算机系统漫游1.编译器gcc -o hello hello.c 进程：操作系统对一个正在运行的程序的一种抽象 并发：CPU交错执行不同进程/线程的指令 线程：共享进程的所有信息 上下文：进程运行所需要的所有状态信息 内核：系统管理全部进程所用代码和数据结构的集合 2.信息的表示和处理 不同位编译器对数据类型的影响 12345int 在32和64位编译器都是4位long 在32和64位编译器都分别是4位和8位为了解决long在不同编译器下的不同表现，在ISO C99引入int32_t 在32和64位编译器都是4位int64_t 在32和64位编译器都是8位 大小端法 小端法：低位在前（与书写习惯相反，方便正负和大小比较）&lt; Andriod/iOS大端法：高位在前（方便运算和类型强转（高位可能被舍弃）） 例如：int32_t x = 0x01234567 地址1 地址2 地址3 地址4 地址 0x4000 8000(低地址) 0x4000 8001 0x4000 8002 0x4000 8003(高地址) 小端法 0x67 0x45 0x23 0x01 大端法 0x01 0x23 0x45 0x67 3.程序的机器级表示 汇编 gcc -Og -S foo.c-S 汇编-Og 告诉编译器生成符合C源码的优化等级-masm=intel 生成Intel格式的汇编语言 编译 gcc -Og -c foo.c-c 编译 反汇编 objdump -d bar.o 指令 0.程序计数器寄存器，指向当前执行的指令所在内存地址1.跳转指令jump 实现条件执行 控制转移：函数调用 1.原流水线指令地址压入程序栈中2.将参数存入寄存器和栈中，保存程序计数器地址（寄存器最多可存入6个整型/指针型参数 &amp; 8个浮点型参数，放不下的压入栈顶）3.上一指令上下文（被调用者保存寄存器.内容&lt;调用者保存寄存器由调用者决定如何处理&gt;）保存进栈（保存的寄存器内容：学术上属于被调用者的栈帧）4.call指令指明即将调用的函数入口地址,调用函数5.返回值存入寄存器中，加载程序栈中的上下文到被调用者保存寄存器，ret指令弹出存入栈中的指令地址 栈上的局部变量 运行时栈提供了一种简单的局部变量机制：在需要时分配、函数完成时释放局部变量会优先保存在寄存器上，（6个整型 + 8个浮点型） 寄存器存放不下 局部变量使用&amp;取地址 其他数据结构如数组/结构体等，必须能通过引用被访问 ·* 缓冲区 系统动态分配的栈区域缓冲区溢出，操作内存范围超出了系统给其分配的大小，可以影响到调用者栈帧，如程序计数器地址，当ret时jump到该非正常地址执行指令对抗缓冲区溢出的3种方法：1.ASLR 地址空间布局随机化；2.栈保护：金丝雀保护位；3.限制内存各部分的可执行与否 可变长栈帧：引入基指针概念，由寄存器%rbp保存。和栈指针一起确定栈帧的边界，分别由不同的寄存器保存，此时寻址以基指针为参考。 处理器流水线SEQ阶段 1.取指阶段 2.译码和写回阶段 3.执行阶段 4.访存阶段 5.更新PC阶段 4.优化程序性能 编译器优化：编译器会假设最糟的情况，安全优化。 分支预测和投机执行 运算开销 加法 &lt; 乘法 &lt; 除法 (浮点运算会增大开销) 2.在系统上运行程序1.链接 链接器处理的目标文件： 1.可重定位的（–静态链接器–》可执行目标文件）2.可执行的3.共享的目标文件/库（-运行时由动态链接器链接和加载/程序被加载和执行时调用dlopen库函数–》） 链接器的主要任务 1.符号解析（symbol resolution）：目标文件中的每个全局符号都绑定到一个唯一的定义（目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量。符号解析的目的是将每个符号引用正好和一个符号定义关联起来）。 2.重定位(relocation)：确定每个符号的最终内存地址，并修改对那些目标的引用（编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位）。 2.加载器加载器将可执行文件的内容映射到内存，并执行这个程序。 3.异常控制 4种异常 中断陷阱错误终止 非本地跳转区别于正常的调用/返回栈规则，直接从一个函数分支到另一个函数 4.虚拟内存（进程私有的是虚拟内存空间而不是物理内存空间） 虚拟地址–虚拟寻址–》return 物理地址 / （缺页 ？–磁盘copy到主存–&gt;return 物理地址） 作用： 1.简化链接2.简化加载3.简化内存分配（加入保护位，简化内存保护） 虚拟内存提供了一种机制：进程的物理内存地址可以不连续，由页表映射串联 页表（page table/PTE）：页表将虚拟页映射到物理页,由OS维护，地址翻译达成 （CPU页表基址寄存器） 虚拟页表状态 1.已分配&amp;缓存2.已分配未缓存3.未分配 页表其他许可标志位(如权限) 1.仅内核访问？ 2.读/写权限2.如果超权限处理，CPU会出发保护故障，将控制传递给内核的异常处理程序 内存区域（每个区域都是起止标志） 代码区 》 数据区 》堆区 》 共享库区 》 栈区 堆区：动态内存分配器维护的进程的内存区域称为堆。显示分配器 C：malloc/free; C++:new/delete隐式分配器 分配器检测已分配的块何时不被使用，使用垃圾回收自动释放 内存碎片 空闲链表–放置策略–》目标块 &gt;if no&gt;合并相邻空闲块 &gt; if no&gt;申请新堆区 垃圾回收 不需要程序员手动调用free类似的堆内存释放函数，垃圾回收器会自动回收 最经典的方法:可达图法（当存在任意一条从根节点出发并达到p的有向路径，则成p为reachable） 精确垃圾回收（Java) 保守垃圾回收（C/C++):C语言不会用类型信息来标记内存位置，因此对于已分配块的value,无法知晓value是指针类型还是与指针类型同大小的数据类型（如64为编译 int），故只能保守的当作指针处理，标记*value为可达块 管理和使用虚拟内存错误包括： 1.间接引用坏指针2.读取未初始化的内存3.允许栈缓冲溢出4.假设指针和它们指向的对象大小相同，引用指针而不是它们所指向的对象 ：p与&amp;p5.误解指针运算：p++6.引用不存在的变量：p(p为原栈区,内容已被替换)7.内存泄漏 5.网络编程 套接字 通讯连接的一个端点，连接的两端叫做套接字对套接字地址是由一个因特网地址和一个16位的整数端口组成，如128.2.2.202:443 6.并发编程 进程：操作系统对一个正在运行的程序的一种抽象，表示正在运行的一个程序的实例，由内核自动统一调度(有父子层级关系) 线程：运行在单一进程上下文中的逻辑流，由内核自动进行调度，为cpu实际执行的路径（无层级关系，地位对等，可以stop或等待其他线程） 每个线程都有它自己的线程上下文，包括一个唯一的整数线程ID(TID)、栈、栈指针、程序计数器、通用目的寄存器和条件码所有线程共享所在进程的整个虚拟地址空间 IPC（进程间通讯）机制 并行实现方式 1.多进程fork()2.基于I/O多路复用的事件驱动编程（优点：易于对程序的行为控制，缺点：编码复杂&amp;不能充分利用多核）3.多线程 多线程 多线程每个线程维护自己的运行时栈，对于共享变量需要考虑线程安全。 信号量： P操作：semaphore - 1,如果s == 0，就挂起这个线程 V操作：semaphore + 1,如果有任何线程阻塞在P操作等待s&gt;0,那么P操作会重启1个正在等待的线程（随机的线程)互斥锁：当semaphore初始化=1,则该信号量称为二元信号量，即为互斥锁。 4种线程不安全函数类 不保护共享变量的函数 保持跨越多个调用的状态的函数 返回指向静态变量的指针的函数 调用线程不安全函数的函数","categories":[],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"https://haojiaqiang.github.io/tags/计算机系统/"}]},{"title":"Object-C 高级编程 iOS和OS X多线程和内存管理","slug":"Pro-multithreading-and-memory-management-for-iOS-and-OS-X","date":"2016-04-22T06:32:12.000Z","updated":"2020-11-19T08:46:06.546Z","comments":true,"path":"2016/04/22/Pro-multithreading-and-memory-management-for-iOS-and-OS-X/","link":"","permalink":"https://haojiaqiang.github.io/2016/04/22/Pro-multithreading-and-memory-management-for-iOS-and-OS-X/","excerpt":"","text":"Block 定义：带有自动变量（成员变量）值的匿名函数（Block结构体声明的成员变量与自动变量类型完全相同，注：未使用的自动变量不会被捕获追加成成员变量） 写法与C函数的区别：（1）没有函数名（2）返回值前有^ 语法 ^ 返回值类型 参数列表 表达式 ^int (int x) {return x + 1;} ^ 参数列表 表达式 ^ (int x) {return x + 1;}省略返回值类型:如果表达式没有return，则返回值类型为void；如果表达式有return,则返回值类型为该返回值类型。如果有多个return，则所有return语句返回值必须一致。 ^ 表达式 ^ {print(&quot;Block\\n&quot;);}当参数为void时可以省略 block实现 结构体实例 &amp;&amp; 映射成对应函数名的函数 关键字__block ARC下 基本数据类型 变量foo包装成一个结构体 __Block_byref_foo_0 foo，内部有一个与原自动变量同名同类型的成员变量foo = 原自动变量foo的值，结构体内部有指针成员变量*__forwarding = &amp;__Block_byref_foo_0 foo。当Block被copy到堆上，其所使用的block修饰的自动变量所生成的结构体`Block_byref_foo_0 foo也被copy到堆上，且原栈上的结构体的forwarding和堆上副本结构体的forwarding均指向堆上副本的Block_byref_foo_0 foo。访问原自动变量的值foo.forwarding-&gt;foo`。 对象类型&gt; strong类型对象使用无区别：和`没有block修饰的均通过_Block_object_assign被Block强持有,_Block_object_dispose`释放对象 __weak类型对象使用无区别：均不会对对象的生命周期有影响 分类ps：内存分区：程序/代码区（.text区）、数据区(.data区)、堆区、栈区1.NSConcreteStackBlock 栈区2.NSConcreteGlobalBlock 数据区(.data区) 记述全局变量的地方有block语法时 Block语法的表达式中不使用应截获的自动变量时 3.NSConcreteMallocBlocl 堆 BLock作为函数返回值返回时 将Block赋值给附有__strong修饰符id类型的类或Block类型成员变量时 在方法名中含有usingBlock的Cocoa框架方法或GCD的API中传递Block时 调用Block的copy实例方法时（除上面3种会自动copy，为了保证block以及捕获的自动变量出作用域依旧有效，推荐手动调用[block copy]） 注意：block在ARC和MRC作用有很大区别（MRC的Block不会对 block object retain操作，而会对没有__block修饰的Object retain操作） 多线程 优点 正确使用可以提升响应性能 缺点 共享数据安全死锁消耗大量内存 GCD1.队列 Serial Dispatch Queue Concurrent Dispatch Queue 2.队列创建： 1.dispatch_queue_t dispatchQueueFoo = dispatch_queue_creat（&quot;com.hayato.gcd.queueNameFoo&quot;, DISPATCH_QUEUE_CONCURRENT/DISPATCH_QUEUE_SERIAL) 2.dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);// DISPATCH_QUEUE_PRIORITY_DEFAULT/DISPATCH_QUEUE_PRIORITY_LOW/DISPATCH_QUEUE_PRIORITY_BACKGROUND/ 3.dispatch_get_main_queue() * 持有队列dispatch_retain(dispatchQueueFoo)--> * 释放队列(ARC亦需要）dispatch_release(dispatchQueueFoo)--> * 注意：队列释放后Block中的任务会继续执行 3.dispatch_group123456789101112dispatch_group_t group = dispatch_group_create();dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_async(group, queue, ^&#123; // task1&#125;);dispatch_group_async(group, queue, ^&#123; // task2&#125;);dispatch_group_notify(group, queue, ^&#123; // task3&#125;);// 依次执行 task1 &gt; task2 &gt; task3 dispatch_group_enter(group)、dispatch_group_leave(group)显示指定任务的进入退出哨兵，手动管理任务截止。必须成对出现 4.dispatch_barrier_async(与conCurrent queue一起用)123456789101112131415161718192021222324dispatch_group_async(group, queue, ^&#123; // task1&#125;);dispatch_group_async(group, queue, ^&#123; // task2&#125;);dispatch_group_notify(group, queue, ^&#123; // task3&#125;);dispatch_barrier_async(queue, ^&#123; //task barrier&#125;);dispatch_group_async(group, queue, ^&#123; // task1&#125;);dispatch_group_async(group, queue, ^&#123; // task2&#125;);dispatch_group_notify(group, queue, ^&#123; // task3&#125;);// 执行顺序 task1/2/3并行task barrier执行在1&amp;2&amp;3全部执行结束后task 4/5/6在barrier执行后并发执行 5.dispatch_apply 重复添加指定次数的某个任务 》 没啥卵用 6.dispatch_supend(queue) &amp;&amp; dispatch_resume(queue) 挂起 &amp;&amp; 恢复 queue（注意：dispatch_supend挂起之后的任务不在执行，直到dispatch_resume继续执行后续任务，但是GCD不能cancel正在执行的任务） 7.dispatch semaphore:信号量 提供更细粒度的操作123dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);//V操作 -1dispatch_semaphore_signal(semaphore);// P操作 + 1 8.dispatch_once:即使多线程依旧报纸只执行一次 9.dispatch IO &amp;&amp; dispatch data：高速读取文件","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://haojiaqiang.github.io/tags/多线程/"},{"name":"内存管理","slug":"内存管理","permalink":"https://haojiaqiang.github.io/tags/内存管理/"}]},{"title":"Git","slug":"git","date":"2016-03-12T02:43:09.000Z","updated":"2020-11-19T08:46:06.550Z","comments":true,"path":"2016/03/12/git/","link":"","permalink":"https://haojiaqiang.github.io/2016/03/12/git/","excerpt":"","text":"常用Git命令新建代码库123456789101112131415161718// cd到你的项目目录cd fooProject path // 在当前目录新建一个Git代码库git init// add添加要提交的文件名，.是选中所有的意思，现在一般使用 git add -Agit add .git add [fileName1] [fileName2]...# 添加指定目录到暂存区，包括子目录git add [dir]// 提交更新，“”为本次提交描述git commit -m &quot;commit description&quot;// 关联远端分支与本地分支git branch --set-upstream-to=[远端仓库]/[远端分支] [本地分支] 远程仓库地址12345678910111213// 查看远程仓库信息git remote -v// 添加远程仓库(可以添加多个remote respository)git remote add [remoteName] [remoteURL]git remote add origin git://github.com/paulboone/ticgit.git// 更改远程仓库URLgit remote set-url origin fooUrl// fetch指定远程仓库 pull = fetch + mergegit fetch [remoteName] Tag1234567891011121314151617181920212223242526272829/// 1. 列出已有Tag git tag/// 2. 创建Tag// 创建简易taggit tag tagName // 创建带描述信息的taggit tag -a tagName -m &apos;tagMessage&apos; // 补打Tag到某一次提交记录git tag -a tagName [aCommit like 0d52aa]// 补打Tag-显示历史提交记录git log --pretty=oneline&quot;a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support0d52aaab4479697da7686c15f77a3d64d9165190 one more thing...&quot;/// 3. Push Tag// push指定tag到远程仓库git push origin [tagName]// push所有tag到远程仓库git push origin --tags/// 4. 删除Tag// 删除本地仓库Taggit tag -d v1.1.4 // 删除远程仓库Taggit push origin :refs/tags/[TagName] 递归删除子文件夹.git版本控制12345678// cd到目标cd fooProject path//删除所有子目录下.git文件find ./ -name &quot;.git&quot; | xargs rm -Rf// 删除对应目录下的git Cachegit rm -r --cached path 详细Git命令 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] Tag1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] Submodule1234567891011121314151617181920212223242526272829303132# 添加子仓库git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;# 添加成功后，在父仓库根目录增加了.gitmodule文件&lt;!--[submodule &quot;sub&quot;]--&gt;&lt;!-- path = lib--&gt;&lt;!-- url = ssh://git@10.2.237.56:23/dennis/sub.git--&gt; # 并且在父仓库的git 配置文件中加入了submodule段。cat .git/config// 加了submodule段[submodule &quot;sub&quot;] url = ssh://git@10.2.237.56:23/dennis/sub.git# 检出(checkout)克隆一个包含子仓库的仓库目录，并不会clone下子仓库的文件，只是会克隆下.gitmodule描述文件，需要进一步克隆子仓库文件。// 初始化本地配置文件git submodule init// 检出父仓库列出的commitgit submodule update// 或者使用组合指令。git submodule update --init --recursive# 删除子仓库,如果未按照下列步骤删除，可能残留在.git/modudles文件夹内。* 删除.gitsubmodule里相关部分* 删除.git/config 文件里相关字段* 删除子仓库目录。git rm --cached &lt;本地路径&gt; 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archive","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://haojiaqiang.github.io/tags/Git/"}]},{"title":"几种特殊指针的含义区别","slug":"special-kind-of-pointer","date":"2015-06-25T02:16:20.000Z","updated":"2018-11-21T14:27:47.010Z","comments":true,"path":"2015/06/25/special-kind-of-pointer/","link":"","permalink":"https://haojiaqiang.github.io/2015/06/25/special-kind-of-pointer/","excerpt":"","text":"id &amp;&amp; NSObject &amp;&amp; id &amp;&amp; void *id:一个指向对象的指针在实际编码中，我们经常看到第一个，在编译器眼中id仅仅意味着一个指向对象的指针，关于这个对象的信息，编译器需要等到runtime才能确定。因此，在程序中，不管对由id指向的对象发送任何消息，编译器都不会有任何报错，就像我们常见的id obj = [[Foo alloc] init]一样，由于Foo alloc返回的是id对象，因此对其调用init方法与对其调用 initWithbalbalbal 等方法都是可以的(当然，现在的编译器会只能地警告，之前没见过这个selector)。 NSObject 指针指向了一个NSObject及其子类的对象而id指向的对象并不全是NSObject的子类，当我们指定一个类为NSObject时，编译器就确切地知道了该类的所有信息，因此，当我们对该对象发送NSObject没有声明的方法时，编译器就会果断报错在别的语言中，声明一个类似NSObject的对象并进行操作是非常普遍的，因为NSObject意味着所有类的基类，但在objc这门动态语言中，过于严格的类型检查是不受欢迎的，在框架中，并不是所有类都继承自NSObject，比如说NSProxy，尽管它声明了大多数与NSObject同样的方法，但它的基类并不是NSObject,这时候id&lt;NSObject&gt;就发挥出作用了。 id 指针指向了一个实现了 NSObject 协议的方法的类的对象将一个对象声明为id&lt;NSObject&gt;，意味着编译器不对其作任何类型检查，但是这个对象所属的类默认实现名为 NSObject 的protrol。其实，在实际操作中，我们往往不会去关心一个对象的所属的类，而是这个对象会响应什么方法，id&lt;NSObject&gt;表明了foo3这个指针指向了一个实现了&lt;NSObject&gt;协议的方法的类的对象。 void * 指向一个非特定内容的内存地址void *：表示“引用一些随机块”，带有无类型/未知内容的内存的含义，常见和有效的使用是作为通过一些其他API传递的不透明数据引用id:表示“对任意对象类型的引用”id和void *是内容上没区别，在编译上有区别。编译器会对id在ARC上进行内存管理。void *需要自己管理相互转换：MRC直接相互转换，ARC需要用到桥接 nil、Nil、NULL、NSNull的区别 nil：指向一个OC对象的空指针 Nil：指向一个OC类的空指针 NULL：指向非OC类型的其他类型（如：基本类型、C类型）的空指针 NSNull：空值类型，通常用做集合中的占位空值(注意：OC集合无法插入nil或nil仅作为结束符) Example 1234567NSURL *url = nil;Class class = Nil;int *pointerInt = NULL;NSArray *array = [NSArray arrayWithObjects:[[NSObject alloc] init], [NSNull null], [[NSObject alloc] init], [[NSObject alloc] init], nil];","categories":[],"tags":[{"name":"pointer","slug":"pointer","permalink":"https://haojiaqiang.github.io/tags/pointer/"},{"name":"id","slug":"id","permalink":"https://haojiaqiang.github.io/tags/id/"},{"name":"NSObject","slug":"NSObject","permalink":"https://haojiaqiang.github.io/tags/NSObject/"},{"name":"id<NSObject>","slug":"id-NSObject","permalink":"https://haojiaqiang.github.io/tags/id-NSObject/"},{"name":"void *","slug":"void","permalink":"https://haojiaqiang.github.io/tags/void/"},{"name":"nil","slug":"nil","permalink":"https://haojiaqiang.github.io/tags/nil/"},{"name":"Nil","slug":"Nil","permalink":"https://haojiaqiang.github.io/tags/Nil/"},{"name":"NSNull","slug":"NSNull","permalink":"https://haojiaqiang.github.io/tags/NSNull/"}]},{"title":"部署Shadowsocks","slug":"InstallShadowsocks","date":"2015-05-08T02:05:36.000Z","updated":"2020-11-19T08:46:06.545Z","comments":true,"path":"2015/05/08/InstallShadowsocks/","link":"","permalink":"https://haojiaqiang.github.io/2015/05/08/InstallShadowsocks/","excerpt":"","text":"CentOS7部署ShadowsocksReference CentOS 7 开始默认使用Systemd作为开启启动脚本的管理工具，Shadowsocks则是当前比较受欢迎的科学上网工具，本文将介绍如何在 CentOS 下安装和配置 Shadowsocks 服务。 服务器基本操作123链接服务器：ssh root@xxxx.xxx.xxx.xxx -p XXXX &lt; xxx:ip，XXXX：port修改密码：passwd断开链接：close 安装 pippip是 python 的包管理工具。在本文中将使用 python 版本的 shadowsocks，此版本的 shadowsocks 已发布到 pip 上，因此我们需要通过 pip 命令来安装。 在控制台执行以下命令安装 pip： 12curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot;python get-pip.py 安装配置 shadowsocks在控制台执行以下命令安装 shadowsocks： 12pip install --upgrade pippip install shadowsocks 安装完成后，需要创建配置文件/etc/shadowsocks.json，内容如下： 123456789101112131415161718单账号：&#123; &quot;server&quot;: &quot;0.0.0.0&quot;, &quot;server_port&quot;: 8989, &quot;password&quot;: &quot;passwd8989&quot;, &quot;method&quot;: &quot;aes-256-cfb&quot;&#125;多账号：&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;haojiaqiang8989&quot;, &quot;8990&quot;:&quot;haojiaqiang8990&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;&#125; 说明： method为加密方法，可选aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table server_port为服务监听端口 password为密码，可使用密码生成工具生成一个随机密码 以上三项信息在配置 shadowsocks 客户端时需要配置一致，具体说明可查看 shadowsocks 的帮助文档。 配置自启动新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下： 123456789[Unit]Description=Shadowsocks[Service]TimeoutStartSec=0ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json[Install]WantedBy=multi-user.target 执行以下命令启动 shadowsocks 服务： 12systemctl enable shadowsockssystemctl start shadowsocks 为了检查 shadowsocks 服务是否已成功启动，可以执行以下命令查看服务的状态： 1systemctl status shadowsocks -l 如果服务启动成功，则控制台显示的信息可能类似这样： 123456789101112● shadowsocks.service - Shadowsocks Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled) Active: active (running) since Mon 2015-12-21 23:51:48 CST; 11min ago Main PID: 19334 (ssserver) CGroup: /system.slice/shadowsocks.service └─19334 /usr/bin/python /usr/bin/ssserver -c /etc/shadowsocks.jsonDec 21 23:51:48 morning.work systemd[1]: Started Shadowsocks.Dec 21 23:51:48 morning.work systemd[1]: Starting Shadowsocks...Dec 21 23:51:48 morning.work ssserver[19334]: INFO: loading config from /etc/shadowsocks.jsonDec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO loading libcrypto from libcrypto.so.10Dec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO starting server at 0.0.0.0:8388 设置服务器定时重启一般默认会安装Crontab，如果需要配置的话：123yum install vixie-cron crontabs # 安装chkconfig crond on # 设置开机启动service crond start # 启动服务 先列一下现有的Crontab看看：crontab -l如果没有提示为 no crontab for root 编辑命令：crontab –e 输入20 5 * * * root /sbin/reboot表示服务器会在所在时区每天05：20重启 生效：service crond restart ===== 傻瓜式一键安装脚本 =====新建文件install-shadowsocks.sh，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/bin/bash# Install Shadowsocks on CentOS 7echo &quot;Installing Shadowsocks...&quot;random-string()&#123; cat /dev/urandom | tr -dc &apos;a-zA-Z0-9&apos; | fold -w $&#123;1:-32&#125; | head -n 1&#125;CONFIG_FILE=/etc/shadowsocks.jsonSERVICE_FILE=/etc/systemd/system/shadowsocks.serviceSS_PASSWORD=$(random-string 32)SS_PORT=8989SS_METHOD=aes-256-cfbSS_IP=`ip route get 1 | awk &apos;&#123;print $NF;exit&#125;&apos;`GET_PIP_FILE=/tmp/get-pip.py# install pipcurl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;$&#123;GET_PIP_FILE&#125;&quot;python $&#123;GET_PIP_FILE&#125;# install shadowsockspip install --upgrade pippip install shadowsocks# create shadowsocls configcat &lt;&lt;EOF | sudo tee $&#123;CONFIG_FILE&#125;&#123; &quot;server&quot;: &quot;0.0.0.0&quot;, &quot;server_port&quot;: $&#123;SS_PORT&#125;, &quot;password&quot;: &quot;$&#123;SS_PASSWORD&#125;&quot;, &quot;method&quot;: &quot;$&#123;SS_METHOD&#125;&quot;&#125;EOF# create servicecat &lt;&lt;EOF | sudo tee $&#123;SERVICE_FILE&#125;[Unit]Description=Shadowsocks[Service]TimeoutStartSec=0ExecStart=/usr/bin/ssserver -c $&#123;CONFIG_FILE&#125;[Install]WantedBy=multi-user.targetEOF# start servicesystemctl enable shadowsockssystemctl start shadowsocks# view service statussleep 5systemctl status shadowsocks -lecho &quot;================================&quot;echo &quot;&quot;echo &quot;Congratulations! Shadowsocks has been installed on your system.&quot;echo &quot;You shadowsocks connection info:&quot;echo &quot;--------------------------------&quot;echo &quot;server: $&#123;SS_IP&#125;&quot;echo &quot;server_port: $&#123;SS_PORT&#125;&quot;echo &quot;password: $&#123;SS_PASSWORD&#125;&quot;echo &quot;method: $&#123;SS_METHOD&#125;&quot;echo &quot;--------------------------------&quot; 执行以下命令一键安装： 12chmod +x install-shadowsocks.sh./install-shadowsocks.sh 也可以直接执行以下命令从 GitHub 下载安装脚本并执行： 1bash &lt;(curl -s http://morning.work/examples/2015-12/install-shadowsocks.sh) 安装完成后会自动打印出 Shadowsocks 的连接配置信息。比如： 12345678Congratulations! Shadowsocks has been installed on your system.You shadowsocks connection info:--------------------------------server: 10.0.2.15server_port: 8989password: RaskAAcW0IQrVcA7n0QLCEphhng7K4Ycmethod: aes-256-cfb-------------------------------- 链接服务器报错123456789101112@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host isSHA256:mBd/txv711elA0SBOKfdIBVE+iTJ3Rn/FLrkRPEi1bQ.Please contact your system administrator.~/.ssh/known_hosts 删除对应ip描述 查看服务器运行情况1ss -tulnp | grep xxxx xxxx端口号，查看/etc/shadowsocks.json 扩展阅读 systemd 详解 Install pip How to Install Pip on CentOS 7 How To Create a systemd Service in Linux (CentOS 7) Getting Started with systemd How to I get the primary IP address of the local machine on Linux and OS X? Execute bash script from URL AWS部署ShadowsocksReference 启动虚拟机 这里，点击高级EC2启动实例向导进行个性化配置。 定制化服务器类型 选择Amazon 系统映像(AMI) 这里选择，Amazon Linux AMI、RedHat、Ubuntu都行。本文选择的是Ubuntu。 选择实例类型 标签实例 图中标出的3-4两步直接默认配置就行。 配置安全组 这里先配置所有流量和端口开放。 生成秘钥对 创建账单警报 登录服务器定制完成后，就可以远程登录了。在实例上右击，点击连接。 下面主要是通过Xshell连接到EC2，具体看教程。注意：用户名那里填写ubuntu，否则会出现 所选的用户密钥未在远程主机上注册 请再试一次。 安装Shadowsocks123456789101112131415# 获取root权限sudo -s# 更新apt-getapt-get update# 安装python包管理工具apt-get install python-setuptoolsapt-get install python-pip# 配置语言export LC_ALL=C# 安装shadowsockspip install shadowsocks 配置Shadowsocks创建配置文件 12mkdir /etc/shadowsocksvim /etc/shadowsocks/ss.json 配置文件内容： 1234567891011&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:443, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;xxxx&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false, &quot;workers&quot;: 1&#125; 或多端口配置：12345678910&#123; “server”:”0.0.0.0”,#或者为服务器ip地址 “port_password”: &#123; “端口1”: “连接密码1”, “端口2” : “连接密码2” &#125;, “timeout”:300, “method”:”aes-256-cfb”, “fast_open”: false&#125; 配置字段 说明 server 服务端监听地址(IPv4或IPv6) server_port 服务端端口，一般为443 local_address 本地监听地址，缺省为127.0.0.1 local_port 本地监听端口，一般为1080 password 用以加密的密匙 timeout 超时时间（秒） method 加密方法，默认为aes-256-cfb，更多请查阅Encryption fast_open 是否启用TCP-Fast-Open，true或者false workers worker数量 启动Shadowsocks启动：ssserver -c /etc/shadowsocks/ss.json -d start 停止：ssserver -c /etc/shadowsocks/ss.json -d stop 重启：ssserver -c /etc/shadowsocks/ss.json -d restart 设置SS为开机自启动1vi /etc/rc.local 加入：sudo ssserver -c /etc/shadowsocks/ss.json -d start 本地设备连接到Shadowsocks服务器到GitHub下载最新的客户端： Windows客户端下载地址 macOS客户端下载地址 Linux客户端下载地址 安装之后，添加服务器，地址为AWS的外网地址，登录AWS控制台，查看正在运行中的实例，找到公有ip。 端口号为刚才配置Shadowsocks服务器时的端口号，密码也是刚才配置的(当然密码可以自行设置)，设置完之后保存。 关于Windows下使用Shadowsocks的方法，还请自行搜索。 防止AWS到期或其他原因扣费为了防止流量超出或者此悲剧发生。 需要设置账单警报，前面已经介绍了。 还有就是在安全组下面设置入站和出站规则。 一言以蔽之，到期前把你账户下所有AWS实例关闭并销毁。 AWS Ubuntu启用root用户以SSH登录按照下面的步骤启用ssh作为AWS上的实例的Ubuntu root用户。您可以按照其他Linux相同的步骤像CentOS，RHEL，LinuxMint，Debian的AWS等实例 SSH到服务器- 登录与Ubuntu的用户你的服务器，然后切换到root用户使用sudo命令。1ssh -i server.pem ubuntu@remote-server.com 成功登录到Ubuntu帐户切换到root帐户后。1sudo su 编辑authorized_keys文件- 现在编辑/root/.ssh/authorized_keys提交你的私钥。 你会得到类似的代码与您的钥匙。12345678no-port-forwarding,no-agent-forwarding,no-X11-forwarding,command=&quot;echo &apos;Please login as the user &quot;ubuntu&quot; rather than the user &quot;root&quot;.&apos;;echo;sleep 10&quot; ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCPqJ2U4gidqek4FPQJABENkrUiLVP61LObdFAZXvs2EpCf/nBQCRg4ykMNg+8TC9lb7jC65zfIrTUcNcwongDb43k6miSKu1M8fdqXDpcb8CdDRaKpM2wP8l+hTaJ2aWycXmGJ7lZKQPiwNUOhbrOLNEtDmOI9eiVlz7See98LVLW+6AwfzNA8Cu4riDTvEMQr/WQ9NLrS3BZE1TAAswJi9lGDfTgEvfh4Ji+eI/xTXrjkkwjerkjk3jrkwejrkjwe9wASXob4rbV12TXjQIcMKaRGQAGrwOHu0nM2ibfTdgqjrTAG03CXKzQhF09LdxKlT7GpYe0oVU2R1kjkejwQp howtoing.com 从authorized_keys文件中删除加粗突出显示的文字和你的关键应该是这样的。有支持SSH-RSA文本之前没有空格。 123456ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCPqJ2U4gidqek4FPQJABENkrUiLVP61LObdFAZXvs2EpCf/nBQCRg4ykMNg+8TC9lb7jC65zfIrTUcNcwongDb43k6miSKu1M8fdqXDpcb8CdDRaKpM2wP8l+hTaJ2aWycXmGJ7lZKQPiwNUOhbrOLNEtDmOI9eiVlz7See98LVLW+6AwfzNA8Cu4riDTvEMQrWQ9NLrS3BZE1TAAswJi9lGDfTgEvfh4Ji+eIxTXrjkkwjerkjk3jrkwejrkjwe9wASXob4rbV12TXjQIcMKaRGQAGrwOHu0nM2ibfTdgqjrTAG03CXKzQhF09LdxKlT7GpYe0oVU2R1kjkejwQp howtoing.com 保存存档 - 上述后去除authorized_keys文件高亮显示的文本，保存并尝试用root帐号以SSH。 1ssh -i server.pem root@remote-server.com 你会发现，你已经成功登录到直接用root用户服务器。 Errorpip install shadowsocks错误提示：123456789# pip install shadowsocksTraceback (most recent call last): File &quot;/usr/bin/pip&quot;, line 11, in &lt;module&gt; sys.exit(main()) File &quot;/usr/lib/python2.7/dist-packages/pip/__init__.py&quot;, line 215, in main locale.setlocale(locale.LC_ALL, &apos;&apos;) File &quot;/usr/lib/python2.7/locale.py&quot;, line 581, in setlocale return _setlocale(category, locale)locale.Error: unsupported locale setting 原因：语言配置错误导致1234567891011121314# locale -alocale: Cannot set LC_CTYPE to default locale: No such file or directoryCC.UTF-8en_AGen_AG.utf8en_AU.utf8en_BW.utf8en_CA.utf8en_DK.utf8en_GB.utf8en_HK.utf8en_IE.utf8... 解决办法：1export LC_ALL=C","categories":[],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://haojiaqiang.github.io/tags/Shadowsocks/"},{"name":"CentOS","slug":"CentOS","permalink":"https://haojiaqiang.github.io/tags/CentOS/"},{"name":"AWS root","slug":"AWS-root","permalink":"https://haojiaqiang.github.io/tags/AWS-root/"}]},{"title":"SQL查询实现方式","slug":"SQL查询实现方式","date":"2015-03-30T06:07:06.000Z","updated":"2020-11-19T08:46:06.548Z","comments":true,"path":"2015/03/30/SQL查询实现方式/","link":"","permalink":"https://haojiaqiang.github.io/2015/03/30/SQL查询实现方式/","excerpt":"","text":"转载整理自：http://www.cnblogs.com/jackson0714/p/SQL_Query_Mechanism.html SQL Server组成部分 关系引擎：主要作用是优化和执行查询三大组件 1.命令解析器：检查语法和转换查询树。 2.查询优化器：优化查询。 3.查询执行器：负责执行查询。 存储引擎：管理所有数据及涉及的IO三大组件 1.事务管理器：通过锁来管理数据及维持事务的ACID属性。 2.数据访问方法：处理对行、索引、页、行版本、空间分配等的I/O请求。 3.缓冲区管理器：管理SQL Server的主要内存消耗组件Buffer Pool。 Buffer Pool包含SQL Server的所有缓存。如计划缓存和数据缓存。 事务日志记录事务的所有更改。保证事务ACID(原子性、一致性、隔离性、持久性)属性的重要组件。 数据文件数据库的物理存储文件。 SQL Server网络接口建立在客户端和服务器之间的网络连接的协议层 查询的底层原理 当客户端执行一条T-SQL语句给SQL Server服务器时，会首先到达服务器的网络接口，网络接口和客户端之间有协议层。 客户端和网络接口之间建立连接。使用称为“表格格式数据流”(TDS) 数据包的 Microsoft 通信格式来格式化通信数据。 客户端发送TDS包给协议层。协议层接收到TDS包后，解压并分析包里面包含了什么请求。 命令解析器解析T-SQL语句。命令解析器会做下面几件事情： （1）检查语法。发现有语法错误就返回给客户端。下面的步骤不执行。 （2）检查缓冲池（Buffer Pool）中是否存在一个对应该T-SQL语句的执行计划缓存。 （3）如果找到已缓存的执行计划，就从执行计划缓存中直接读取，并传输给查询执行器执行。 （4）如果未找到执行计划缓存，则在查询执行器中进行优化并产生执行计划，存放到Buffer Pool中。 查询优化器优化SQL语句 当Buffer Pool中没有该SQL语句的执行计划时，就需要将SQL传到查询优化器，通过一定的算法，分析SQL语句，产生一个或多个候选执行计划。选出开销最小的计划作为最终执行计划。然后将执行计划传给查询执行器。 查询执行器执行查询 查询执行器把执行计划通过OLE DB接口传给存储引擎的数据访问方法。 数据访问方法生成执行代码 数据访问方法将执行计划生成SQL Server可操作数据的代码，不会实际执行这些代码，传送给缓冲区管理器来执行。 缓冲区管理器读取数据。 先在缓冲池的数据缓存中检查是否存在这些数据，如果存在，就把结果返回给存储引擎的数据访问方法；如果不存在，则从磁盘（数据文件）中读出数据并放入数据缓存中，然后将读出的数据返回给存储引擎的数据访问方法。 对于读取数据，将会申请共享锁，事务管理器分配共享锁给读操作。 存储引擎的数据访问方法将查询到的结果返回关系引擎的查询执行器。 查询执行器将结果返回给协议层。 协议层将数据封装成TDS包，然后协议层将TDS包传给客户端。","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://haojiaqiang.github.io/tags/SQL/"}]},{"title":"SQL","slug":"SQL","date":"2015-03-11T07:23:06.000Z","updated":"2020-11-19T08:46:06.548Z","comments":true,"path":"2015/03/11/SQL/","link":"","permalink":"https://haojiaqiang.github.io/2015/03/11/SQL/","excerpt":"","text":"—————— SQL基础 ——————reference:W3CSCHOOL SQL教程 SQL介绍SQL 是用于访问和处理数据库的标准的计算机语言。关于SQL的具体介绍，我们通过回答如下三个问题来进行。 SQL 是什么 SQL，指结构化查询语言，全称是 Structured Query Language。 SQL 是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。 SQL 能做什么 SQL 面向数据库执行查询 SQL 可从数据库取回数据 SQL 可在数据库中插入新的记录 SQL 可更新数据库中的数据 SQL 可从数据库删除记录 SQL 可创建新数据库 SQL 可在数据库中创建新表 SQL 可在数据库中创建存储过程 SQL 可在数据库中创建视图 SQL 可以设置表、存储过程和视图的权限 虽然 SQL 是一门 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言，但是仍然存在着多种不同版本的 SQL 语言。然而，为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的命令（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等）。注释:除了 SQL 标准之外，大部分 SQL 数据库程序都拥有它们自己的专有扩展！ 在网站上如何使用 SQL?要创建一个显示数据库中数据的网站，需要： RDBMS 数据库程序（比如 MS Access、SQL Server、MySQL） 使用服务器端脚本语言，比如 PHP 或 ASP 使用 SQL 来获取您想要的数据 使用 HTML / CSS注释:RDBMS （Relational Database Management System）指关系型数据库管理系统。RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server、IBM DB2、Oracle、MySQL 以及 Microsoft Access。RDBMS 中的数据存储在被称为表的数据库对象中。表是相关的数据项的集合，它由列和行组成。 SQL语句在数据库上执行的大部分工作都由 SQL 语句完成。我们先介绍几个有关SQL的注意事项，为我们接下来详细介绍每一条SQL做一个基础。 SQL语句的大小写问题SQL 对大小写不敏感：SELECT 与 select 是相同的。 SQL 语句后面的分号问题某些数据库系统要求在每条 SQL 语句的末端使用分号。 分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。 一些重要的 SQL 命令： SELECT - 从数据库中提取数据 UPDATE - 更新数据库中的数据 DELETE - 从数据库中删除数据 INSERT INTO - 向数据库中插入新数据 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SQL SELECT语句SELECT 语句用于从数据库中选取数据，结果被存储在一个结果表中，称为结果集。 SQL SELECT 语法： 12SELECT column_name,column_nameFROM table_name; 与1SELECT * FROM table_name; 本文中，我们使用众所周知的 Northwind 样本数据库进行举例介绍。下面是选自 “Customers” 表的数据： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders ObereStr. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F.05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico 4 Around the Horn Thomas Hardy 120 Hanover Sq. London WA1 1DP UK 5 Berglunds snabbköp Christina Berglund Berguvsvägen 8 Luleå S-958 22 Sweden 下面的 SQL 语句从 “Customers” 表中选取 “CustomerName” 和 “City” 列：1SELECT CustomerName,City FROM Customers; 下面的 SQL 语句从 “Customers” 表中选取所有列：1SELECT * FROM Customers; 在表中，一个列可能会包含多个重复值，有时也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。SQL SELECT DISTINCT 语法：12SELECT DISTINCT column_name,column_nameFROM table_name; SQL WHERE语句WHERE 子句用于提取那些满足指定标准的记录。 SQL WHERE语法：123SELECT column_name,column_nameFROM table_nameWHERE column_name operator value; 下面的 SQL 语句从 “Customers” 表中选取国家为 “Mexico” 的所有客户：12SELECT * FROM CustomersWHERE Country=&apos;Mexico&apos;; SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值字段，请不要使用引号。12SELECT * FROM CustomersWHERE CustomerID=1; WHERE 子句中的运算符下面的运算符可以在 WHERE 子句中使用： 运算符 描述 = 等于 &lt;&gt; 不等于(注释:在SQL的一些版本中，该操作符可被写成 !=) &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 SQL AND与OR关键字AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。 下面的 SQL 语句从 “Customers” 表中选取国家为 “Germany” 且城市为 “Berlin” 的所有客户：123SELECT * FROM CustomersWHERE Country=&apos;Germany&apos;AND City=&apos;Berlin&apos;; 下面的 SQL 语句从 “Customers” 表中选取城市为 “Berlin” 或者 “München” 的所有客户：123SELECT * FROM CustomersWHERE City=&apos;Berlin&apos;OR City=&apos;München&apos;; 下面的 SQL 语句从 “Customers” 表中选取国家为 “Germany” 且城市为 “Berlin” 或者 “München” 的所有客户：123SELECT * FROM CustomersWHERE Country=&apos;Germany&apos;AND (City=&apos;Berlin&apos; OR City=&apos;München&apos;); SQL ORDER BY关键字ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。 ORDER BY语法：123SELECT column_name,column_nameFROM table_nameORDER BY column_name,column_name ASC|DESC; 下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 列升序排序：12SELECT * FROM CustomersORDER BY Country; 下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 列降序排序：12SELECT * FROM CustomersORDER BY Country DESC; 下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 和 “CustomerName” 列排序：12SELECT * FROM CustomersORDER BY Country,CustomerName; SQL INSERT INTO语句INSERT INTO 语句用于向表中插入新记录。 INSERT INTO 语句可以有两种编写形式。第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：12INSERT INTO table_nameVALUES (value1,value2,value3,...); 第二种形式需要指定列名及被插入的值：12INSERT INTO table_name (column1,column2,column3,...)VALUES (value1,value2,value3,...); 假如插入操作前的表如下所示： CustomerID CustomerName ContactName Address City PostalCode Country 87 Wartian-Herkku Pirkko-Koskitalo Torikatu-38 Oulu 90110 Finland 88 Wellington-Importadora Paula-Parente Rua-do-Mercado,12 Resende 08737-363 Brazil 89 White-Clover-Markets Karl-Jablonski 305-14th-Ave.S.Suite-3B Seattle 98128 USA 90 Wilman-Kala Matti-Karttunen Keskuskatu-45 Helsinki 21240 Finland 91 Wolski Zbyszek ul.Filtrowa-68 Walla 01-012 Poland 我们要向 “Customers” 表中插入一个新行。我们可以使用下面的 SQL 语句：12INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)VALUES (&apos;Cardinal&apos;,&apos;Tom B. Erichsen&apos;,&apos;Skagen 21&apos;,&apos;Stavanger&apos;,&apos;4006&apos;,&apos;Norway&apos;); 执行插入操作以后的表如下所示： CustomerID CustomerName ContactName Address City PostalCode Country 87 Wartian-Herkku Pirkko-Koskitalo Torikatu-38 Oulu 90110 Finland 88 Wellington-Importadora Paula-Parente Rua-do-Mercado,12 Resende 08737-363 Brazil 89 White-Clover-Markets Karl-Jablonski 305-14th-Ave.S.Suite-3B Seattle 98128 USA 90 Wilman-Kala Matti-Karttunen Keskuskatu-45 Helsinki 21240 Finland 92 Cardinal Tom-B.Erichsen Skagen-21 Stavanger 4006 Norway 注释：我们无需插入CustomerID列，它是自动更新的。 我们也可以在指定的列插入数据。下面的 SQL 语句将插入一个新行，但是只在 “CustomerName”、”City” 和 “Country” 列插入数据（CustomerID 字段会自动更新）：12INSERT INTO Customers (CustomerName, City, Country)VALUES (&apos;Cardinal&apos;, &apos;Stavanger&apos;, &apos;Norway&apos;); 插入后的表如下所示： CustomerID CustomerName ContactName Address City PostalCode Country 87 Wartian-Herkku Pirkko-Koskitalo Torikatu-38 Oulu 90110 Finland 88 Wellington-Importadora Paula-Parente Rua-do-Mercado,12 Resende 08737-363 Brazil 89 White-Clover-Markets Karl-Jablonski 305-14th-Ave.S.Suite-3B Seattle 98128 USA 90 Wilman-Kala Matti-Karttunen Keskuskatu-45 Helsinki 21240 Finland 91 Wolski Zbyszek ul.Filtrowa-68 Walla 01-012 Poland 92 Cardinal null null Stavanger null Norway 注释：没有复制的列被自动填充为null。 SQL DELETE语句DELETE 语句用于删除表中的行。 SQL DELETE 语法：12DELETE FROM table_nameWHERE some_column=some_value; 请注意 SQL DELETE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！ 假设我们要从 “Customers” 表中删除客户 “Alfreds Futterkiste”。我们使用下面的 SQL 语句：12DELETE FROM CustomersWHERE CustomerName=&apos;Alfreds Futterkiste&apos; AND ContactName=&apos;Maria Anders&apos;; 您可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：123DELETE FROM table_name;orDELETE * FROM table_name; 注释：在删除记录时要格外小心！因为不能重来！ SQL UPDATE语句UPDATE 语句用于更新表中已存在的记录。 SQL UPDATE语法：123UPDATE table_nameSET column1=value1,column2=value2,...WHERE some_column=some_value; 请注意 SQL UPDATE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE 子句，所有的记录都将被更新！ 假设我们要把客户 “Alfreds Futterkiste” 更新为一个新的联系人和城市。 CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds_Futterkiste Maria_Anders ObereStr.57 Berlin 12209 Germany 我们使用下面的 SQL 语句：123UPDATE CustomersSET ContactName=&apos;Alfred Schmidt&apos;, City=&apos;Hamburg&apos;WHERE CustomerName=&apos;Alfreds Futterkiste&apos;; 更新后结果： CustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds_Futterkiste Alfred_Schmidt ObereStr.57 Hamburg 12209 Germany —————— SQL高级 ——————SQL SELECT TOP, LIMIT, ROWNUM 子句 SELECT TOP 子句用于规定要返回的记录的数目。 SELECT TOP 子句对于拥有数千条记录的大型表来说，是非常有用的。注意：并非所有的数据库系统都支持 SELECT TOP 语句。 MySQL 支持 LIMIT 语句来选取指定的条数数据， Oracle 可以使用 ROWNUM 来选取。 SQL Server / MS Access 语法12SELECT TOP number|percent column_name(s)FROM table_name; MySQL 语法123SELECT column_name(s)FROM table_nameLIMIT number; 实例123SELECT *FROM PersonsLIMIT 5; Oracle 语法123SELECT column_name(s)FROM table_nameWHERE ROWNUM &lt;= number; 实例123SELECT *FROM PersonsWHERE ROWNUM &lt;=5; 演示数据库在本教程中，我们将使用 RUNOOB 样本数据库。 下面是选自 “Websites” 表的数据：1234567891011mysql&gt; SELECT * FROM Websites;+----+---------------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+---------------+---------------------------+-------+---------+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 5000 | USA || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA || 7 | stackoverflow | http://stackoverflow.com/ | 0 | IND |+----+---------------+---------------------------+-------+---------+ 下面是 “access_log” 网站访问记录表的数据：1234567891011121314mysql&gt; SELECT * FROM access_log;+-----+---------+-------+------------+| aid | site_id | count | date |+-----+---------+-------+------------+| 1 | 1 | 45 | 2016-05-10 || 2 | 3 | 100 | 2016-05-13 || 3 | 1 | 230 | 2016-05-14 || 4 | 2 | 10 | 2016-05-14 || 5 | 5 | 205 | 2016-05-14 || 6 | 4 | 13 | 2016-05-15 || 7 | 3 | 220 | 2016-05-15 || 8 | 5 | 545 | 2016-05-16 || 9 | 3 | 201 | 2016-05-17 |+-----+---------+-------+------------+ 下面是 “apps” APP 的数据：123456789mysql&gt; SELECT * FROM apps;+----+------------+-------------------------+---------+| id | app_name | url | country |+----+------------+-------------------------+---------+| 1 | QQ APP | http://im.qq.com/ | CN || 2 | 微博 APP | http://weibo.com/ | CN || 3 | 淘宝 APP | https://www.taobao.com/ | CN |+----+------------+-------------------------+---------+3 rows in set (0.00 sec) 请注意，”Websites” 表中的 “id” 列指向 “access_log” 表中的字段 “site_id”。上面这两个表是通过 “site_id” 列联系起来的。 MySQL SELECT LIMIT 实例下面的 SQL 语句从 “Websites” 表中选取头两条记录： 实例1SELECT * FROM Websites LIMIT 2; 执行以上 SQL，数据如下所示： SQL SELECT TOP PERCENT 实例在 Microsoft SQL Server 中还可以使用百分比作为参数。 下面的 SQL 语句从 websites 表中选取前面百分之 50 的记录： 实例以下操作在 Microsoft SQL Server 数据库中可执行。1SELECT TOP 50 PERCENT * FROM Websites; SQL LIKE 操作符LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。 LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。 SQL LIKE 语法123SELECT column_name(s)FROM table_nameWHERE column_name LIKE pattern; 实例下面的 SQL 语句选取 name 以字母 “G” 开始的所有客户：12SELECT * FROM WebsitesWHERE name LIKE &apos;G%&apos;; 执行输出结果： 下面的 SQL 语句选取 name 以字母 “k” 结尾的所有客户：12SELECT * FROM WebsitesWHERE name LIKE &apos;%k&apos;; 执行输出结果：下面的 SQL 语句选取 name 包含模式 “oo” 的所有客户：12SELECT * FROM WebsitesWHERE name LIKE &apos;%oo%&apos;; 执行输出结果： 通过使用 NOT 关键字，您可以选取不匹配模式的记录。下面的 SQL 语句选取 name 不包含模式 “oo” 的所有客户：12SELECT * FROM WebsitesWHERE name NOT LIKE &apos;%oo%&apos;; 执行输出结果： SQL 通配符通配符可用于替代字符串中的任何其他字符。 在 SQL 中，通配符与 SQL LIKE 操作符一起使用。SQL 通配符用于搜索表中的数据。在 SQL 中，可使用以下通配符： 通配符 描述 % 替代 0 个或多个字符 _ 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist]或[!charlist] 不在字符列中的任何单一字符 使用 SQL % 通配符下面的 SQL 语句选取 url 以字母 “https” 开始的所有网站：12SELECT * FROM WebsitesWHERE url LIKE &apos;https%&apos;; 执行输出结果：下面的 SQL 语句选取 url 包含模式 “oo” 的所有网站：12SELECT * FROM WebsitesWHERE url LIKE &apos;%oo%&apos;; 执行输出结果： 使用 SQL _ 通配符下面的 SQL 语句选取 name 以 “G” 开始，然后是一个任意字符，然后是 “o”，然后是一个任意字符，然后是 “le” 的所有网站：12SELECT * FROM WebsitesWHERE name LIKE &apos;G_o_le&apos;; 使用 SQL [charlist] 通配符MySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。 下面的 SQL 语句选取 name 以 A 到 H 字母开头的网站：12SELECT * FROM WebsitesWHERE name REGEXP &apos;^[A-H]&apos;; 下面的 SQL 语句选取 name 不以 A 到 H 字母开头的网站：12SELECT * FROM WebsitesWHERE name REGEXP &apos;^[^A-H]&apos;; SQL IN 操作符IN 操作符允许您在 WHERE 子句中规定多个值。 SQL IN 语法123SELECT column_name(s)FROM table_nameWHERE column_name IN (value1,value2,...); 实例下面的 SQL 语句选取 name 为 “Google” 或 “菜鸟教程” 的所有网站：12SELECT * FROM WebsitesWHERE name IN (&apos;Google&apos;,&apos;菜鸟教程&apos;); 执行输出结果： IN 与 = 的异同 相同点：均在WHERE中使用作为筛选条件之一、均是等于的含义 不同点：IN可以规定多个值，等于规定一个值123456789// INSELECT column_name(s)FROM table_nameWHERE column_name IN (value1,value2,...);// =SELECT column_name(s)FROM table_nameWHERE column_name=value1; SQL BETWEEN 操作符BETWEEN 操作符用于选取介于两个值之间的数据范围内的值。 BETWEEN 操作符选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。 SQL BETWEEN 语法123SELECT column_name(s)FROM table_nameWHERE column_name BETWEEN value1 AND value2; 实例下面的 SQL 语句选取 alexa 介于 1 和 20 之间的所有网站：12SELECT * FROM WebsitesWHERE alexa BETWEEN 1 AND 20; 执行输出结果： NOT BETWEEN 操作符实例如需显示不在上面实例范围内的网站，请使用 NOT BETWEEN：12SELECT * FROM WebsitesWHERE alexa NOT BETWEEN 1 AND 20; 执行输出结果： 带有 IN 的 BETWEEN 操作符实例下面的 SQL 语句选取alexa介于 1 和 20 之间但 country 不为 USA 和 IND 的所有网站：123SELECT * FROM WebsitesWHERE (alexa BETWEEN 1 AND 20)AND NOT country IN (&apos;USA&apos;, &apos;IND&apos;); 执行输出结果： 带有文本值的 BETWEEN 操作符实例下面的 SQL 语句选取 name 以介于 ‘A’ 和 ‘H’ 之间字母开始的所有网站：12SELECT * FROM WebsitesWHERE name BETWEEN &apos;A&apos; AND &apos;H&apos;; 执行输出结果： 带有文本值的 NOT BETWEEN 操作符实例下面的 SQL 语句选取 name 不介于 ‘A’ 和 ‘H’ 之间字母开始的所有网站：12SELECT * FROM WebsitesWHERE name NOT BETWEEN &apos;A&apos; AND &apos;H&apos;; 执行输出结果： 带有日期值的 BETWEEN 操作符实例下面的 SQL 语句选取 date 介于 ‘2016-05-10’ 和 ‘2016-05-14’ 之间的所有访问记录：12SELECT * FROM access_logWHERE date BETWEEN &apos;2016-05-10&apos; AND &apos;2016-05-14&apos;;//日期格式对应表date格式 执行输出结果： 请注意，在不同的数据库中，BETWEEN 操作符会产生不同的结果！ 在某些数据库中，BETWEEN 选取介于两个值之间但不包括两个测试值的字段。 在某些数据库中，BETWEEN 选取介于两个值之间且包括两个测试值的字段。 在某些数据库中，BETWEEN 选取介于两个值之间且包括第一个测试值但不包括最后一个测试值的字段。 因此，请检查您的数据库是如何处理 BETWEEN 操作符！ SQL 别名通过使用 SQL，可以为表名称或列名称指定别名。 通过使用 SQL，可以为表名称或列名称指定别名。 基本上，创建别名是为了让列名称的可读性更强。 列的 SQL 别名语法12SELECT column_name AS alias_nameFROM table_name; 表的 SQL 别名语法12SELECT column_name(s)FROM table_name AS alias_name; 实例下面的 SQL 语句指定了两个别名，一个是 name 列的别名，一个是 country 列的别名。提示：如果列名称包含空格，要求使用双引号或方括号： 12SELECT name AS n, country AS cFROM Websites; 在下面的 SQL 语句中，我们把三个列（url、alexa 和 country）结合在一起，并创建一个名为 “site_info” 的别名： 12SELECT name, CONCAT(url, &apos;, &apos;, alexa, &apos;, &apos;, country) AS site_infoFROM Websites; 表的别名实例下面的 SQL 语句选取 “菜鸟教程” 的所访问记录。我们使用 “Websites” 和 “access_log” 表，并分别为它们指定表别名 “w” 和 “a”（通过使用别名让 SQL 更简短）： 123SELECT w.name, w.url, a.count, a.date FROM Websites AS w, access_log AS a WHERE a.site_id=w.id and w.name=&quot;菜鸟教程&quot;; 不带别名的相同的 SQL 语句： 123SELECT Websites.name, Websites.url, access_log.count, access_log.date FROM Websites, access_log WHERE Websites.id=access_log.site_id and Websites.name=&quot;菜鸟教程&quot;; 在下面的情况下，使用别名很有用： 在查询中涉及超过一个表 在查询中使用了函数 列名称很长或者可读性差 需要把两个列或者多个列结合在一起 SQL 连接(JOIN)SQL join 用于把来自两个或多个表的行结合起来。 SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。 最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。 实例我们运行下面的 SQL 语句（包含 INNER JOIN）： 1234SELECT Websites.id, Websites.name, access_log.count, access_log.dateFROM WebsitesINNER JOIN access_logON Websites.id=access_log.site_id; 不同的 SQL JOIN在我们继续讲解实例之前，我们先列出您可以使用的不同的 SQL JOIN 类型： INNER JOIN:如果表中有至少一个匹配，则返回行 LEFT JOIN:即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 笔记首先，连接的结果可以在逻辑上看作是由SELECT语句指定的列组成的新表。 左连接与右连接的左右指的是以两张表中的哪一张为基准，它们都是外连接。 外连接就好像是为非基准表添加了一行全为空值的万能行，用来与基准表中找不到匹配的行进行匹配。假设两个没有空值的表进行左连接，左表是基准表，左表的所有行都出现在结果中，右表则可能因为无法与基准表匹配而出现是空值的字段。 这部分主要涉及的是表连接的逻辑问题，教程主讲语法的话这部分确实需要自己再去搜资料reference:来源：《数据库系统原理教程》，王珊，陈红编著，P86 得到的结果数： 123inner join &lt;= min(left join, right join)full join &gt;= max(left join, right join)当 inner join &lt; min(left join, right join) 时， full join &gt; max(left join, right join) SQL INNER JOININNER JOIN 关键字在表中存在至少一个匹配时返回行。 SQL INNER JOIN 语法1234SELECT column_name(s)FROM table1INNER JOIN table2ON table1.column_name=table2.column_name; 或： 1234SELECT column_name(s)FROM table1JOIN table2ON table1.column_name=table2.column_name; 注释：INNER JOIN 与 JOIN 是相同的。 实例下面的 SQL 语句将返回所有网站的访问记录： 12345SELECT Websites.name, access_log.count, access_log.dateFROM WebsitesINNER JOIN access_logON Websites.id=access_log.site_idORDER BY access_log.count; 注释：INNER JOIN 关键字在表中存在至少一个匹配时返回行。如果 “Websites” 表中的行在 “access_log” 中没有匹配，则不会列出这些行。 笔记在使用 left jion 时，on 和 where 条件的区别如下： on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。 where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。详细内容可以查看：SQL JOIN 中 on 与 where 的区别 SQL LEFT JOINLEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。 SQL LEFT JOIN 语法1234SELECT column_name(s)FROM table1LEFT JOIN table2ON table1.column_name=table2.column_name; 或1234SELECT column_name(s)FROM table1LEFT OUTER JOIN table2ON table1.column_name=table2.column_name; 注释：在某些数据库中，LEFT JOIN 称为 LEFT OUTER JOIN。 实例下面的 SQL 语句将返回所有网站及他们的访问量（如果有的话）。 以下实例中我们把 Websites 作为左表，access_log 作为右表： 12345SELECT Websites.name, access_log.count, access_log.dateFROM WebsitesLEFT JOIN access_logON Websites.id=access_log.site_idORDER BY access_log.count DESC; 注释：LEFT JOIN 关键字从左表（Websites）返回所有的行，即使右表（access_log）中没有匹配。 SQL RIGHT JOINRIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。 SQL RIGHT JOIN 语法1234SELECT column_name(s)FROM table1RIGHT JOIN table2ON table1.column_name=table2.column_name; 或 1234SELECT column_name(s)FROM table1RIGHT OUTER JOIN table2ON table1.column_name=table2.column_name; 注释：在某些数据库中，RIGHT JOIN 称为 RIGHT OUTER JOIN。 实例下面的 SQL 语句将返回网站的访问记录。 以下实例中我们把 access_log 作为左表，Websites 作为右表： 12345SELECT Websites.name, access_log.count, access_log.dateFROM access_logRIGHT JOIN WebsitesON access_log.site_id=Websites.idORDER BY access_log.count DESC; 注释：RIGHT JOIN 关键字从右表（Websites）返回所有的行，即使左表（access_log）中没有匹配。 FULL OUTER JOINFULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行. FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。 SQL FULL OUTER JOIN 语法1234SELECT column_name(s)FROM table1FULL OUTER JOIN table2ON table1.column_name=table2.column_name; 实例下面的 SQL 语句选取所有网站访问记录。 MySQL中不支持 FULL OUTER JOIN，你可以在 SQL Server 测试以下实例。 12345SELECT Websites.name, access_log.count, access_log.dateFROM WebsitesFULL OUTER JOIN access_logON Websites.id=access_log.site_idORDER BY access_log.count DESC; 注释：FULL OUTER JOIN 关键字返回左表（Websites）和右表（access_log）中所有的行。如果 “Websites” 表中的行在 “access_log” 中没有匹配或者 “access_log” 表中的行在 “Websites” 表中没有匹配，也会列出这些行。 UNION 操作符SQL UNION 操作符合并两个或多个 SELECT 语句的结果。 UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 SQL UNION 语法123SELECT column_name(s) FROM table1UNIONSELECT column_name(s) FROM table2; 注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 SQL UNION ALL 语法123SELECT column_name(s) FROM table1UNION ALLSELECT column_name(s) FROM table2; 注释：UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 SQL UNION 实例下面的 SQL 语句从 “Websites” 和 “apps” 表中选取所有不同的country（只有不同的值）： 1234SELECT country FROM WebsitesUNIONSELECT country FROM appsORDER BY country; 注释：UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！ SQL UNION ALL 实例下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的country（也有重复的值）： 1234SELECT country FROM WebsitesUNION ALLSELECT country FROM appsORDER BY country; 带有 WHERE 的 SQL UNION ALL下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的中国(CN)的数据（也有重复的值）：123456SELECT country, name FROM WebsitesWHERE country=&apos;CN&apos;UNION ALLSELECT country, app_name FROM appsWHERE country=&apos;CN&apos;ORDER BY country; 笔记12345678910111213select country from websites union select country from apps;--连接两个表的查询结果集，重复的不显示select country from websites union all select country from apps order by country;--连接俩个个表的查询结果集，显示重复select country,name from websites where country = &apos;CN&apos; union all select country,app_name from apps where country=&apos;CN&apos; order by name; --通过where条件查询的结果，连接连个表的结果集，并根据名字排序。 使用UNION命令时需要注意，只能在最后使用一个ORDER BY命令，是将两个查询结果合在一起之后，再进行排序！绝对不能写两个ORDER BY命令。 另外，在使用ORDER BY排序时，注意两个结果的别名保持一致，使用别名排序很方便。当然也可以使用列数。 SELECT INTO 语句通过 SQL，您可以从一个表复制信息到另一个表。 SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。 12345MySQL 数据库不支持 SELECT ... INTO 语句，但支持 INSERT INTO ... SELECT 。当然你可以使用以下语句来拷贝表结构及数据：CREATE TABLE 新表 SELECT * FROM 旧表 SQL SELECT INTO 语法我们可以复制所有的列插入到新表中： 123SELECT *INTO newtable [IN externaldb]FROM table1; 或者只复制希望的列插入到新表中： 123SELECT column_name(s)INTO newtable [IN externaldb]FROM table1; 提示：新表将会使用 SELECT 语句中定义的列名称和类型进行创建。您可以使用 AS 子句来应用新名称。 实例创建 Websites 的备份复件： 123SELECT *INTO WebsitesBackup2016FROM Websites; 只复制一些列插入到新表中： 123SELECT name, urlINTO WebsitesBackup2016FROM Websites; 只复制中国的网站插入到新表中： 1234SELECT *INTO WebsitesBackup2016FROM WebsitesWHERE country=&apos;CN&apos;; 复制多个表中的数据插入到新表中： 12345SELECT Websites.name, access_log.count, access_log.dateINTO WebsitesBackup2016FROM WebsitesLEFT JOIN access_logON Websites.id=access_log.site_id; 提示：SELECT INTO 语句可用于通过另一种模式创建一个新的空表。只需要添加促使查询没有数据返回的 WHERE 子句即可： 1234SELECT *INTO newtableFROM table1WHERE 1=0; INSERT INTO SELECT 语句通过 SQL，您可以从一个表复制信息到另一个表。 INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。 SQL INSERT INTO SELECT 语法我们可以从一个表中复制所有的列插入到另一个已存在的表中： 12INSERT INTO table2SELECT * FROM table1; 或者我们可以只复制希望的列插入到另一个已存在的表中： 1234INSERT INTO table2(column_name(s))SELECT column_name(s)FROM table1; 实例复制 “apps” 中的数据插入到 “Websites” 中： 12INSERT INTO Websites (name, country)SELECT app_name, country FROM apps; 只复 QQ 的 APP 到 “Websites” 中： 123INSERT INTO Websites (name, country)SELECT app_name, country FROM appsWHERE id=1; CREATE DATABASE 语句CREATE DATABASE 语句用于创建数据库。 SQL CREATE DATABASE 语法1CREATE DATABASE dbname; 实例下面的 SQL 语句创建一个名为 “my_db” 的数据库： 1CREATE DATABASE my_db; 数据库表可以通过 CREATE TABLE 语句来添加。 CREATE TABLE 语句CREATE TABLE 语句用于创建数据库中的表。 表由行和列组成，每个表都必须有个表名。 SQL CREATE TABLE 语法1234567CREATE TABLE table_name(column_name1 data_type(size),column_name2 data_type(size),column_name3 data_type(size),....); column_name 参数规定表中列的名称。 data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。 size 参数规定表中列的最大长度。提示：如需了解 MS Access、MySQL 和 SQL Server 中可用的数据类型，请访问数据类型参考手册 实例现在我们想要创建一个名为 “Persons” 的表，包含五列：PersonID、LastName、FirstName、Address 和 City。 我们使用下面的 CREATE TABLE 语句： 12345678CREATE TABLE Persons(PersonID int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255)); PersonID 列的数据类型是 int，包含整数。 LastName、FirstName、Address 和 City 列的数据类型是 varchar，包含字符，且这些字段的最大长度为 255 个字符。 空的 “Persons” 表如下所示： 提示：可使用 INSERT INTO 语句向空表写入数据。 约束（Constraints）SQL 约束用于规定表中的数据规则。 如果存在违反约束的数据行为，行为会被约束终止。 约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。 SQL CREATE TABLE + CONSTRAINT 语法1234567CREATE TABLE table_name(column_name1 data_type(size) constraint_name,column_name2 data_type(size) constraint_name,column_name3 data_type(size) constraint_name,....); 在 SQL 中，我们有如下约束： NOT NULL - 指示某列不能存储 NULL 值。 UNIQUE - 保证某列的每行必须有唯一的值。 PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK - 保证列中的值符合指定的条件。 DEFAULT - 规定没有给列赋值时的默认值。 NOT NULL 约束在默认的情况下，表的列接受 NULL 值。 SQL NOT NULL 约束NOT NULL 约束强制列不接受 NULL 值。 NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。 下面的 SQL 强制 “P_Id” 列和 “LastName” 列不接受 NULL 值： 12345678CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) UNIQUE 约束UNIQUE 约束唯一标识数据库表中的每条记录。 UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。 PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。 请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。 CREATE TABLE 时的 SQL UNIQUE 约束下面的 SQL 在 “Persons” 表创建时在 “P_Id” 列上创建 UNIQUE 约束：MySQL：123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),UNIQUE (P_Id)) SQL Server / Oracle / MS Access：12345678CREATE TABLE Persons(P_Id int NOT NULL UNIQUE,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) 如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：MySQL / SQL Server / Oracle / MS Access：123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)) ALTER TABLE 时的 SQL UNIQUE 约束当表已被创建时，如需在 “P_Id” 列创建 UNIQUE 约束，请使用下面的 SQL：MySQL / SQL Server / Oracle / MS Access：12ALTER TABLE PersonsADD UNIQUE (P_Id) 如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：MySQL / SQL Server / Oracle / MS Access：12ALTER TABLE PersonsADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName) 撤销 UNIQUE 约束如需撤销 UNIQUE 约束，请使用下面的 SQL：MySQL：12ALTER TABLE PersonsDROP INDEX uc_PersonID SQL Server / Oracle / MS Access：12ALTER TABLE PersonsDROP CONSTRAINT uc_PersonID 笔记123456789101112131415161718192021222324252627282930313233343536373839404142create table tb2( tb2_id int unique, tb2_name varchar(20), tb2_age int, unique(tb2_name));select * from tb2;insert into tb2(tb2_id,tb2_name,tb2_age) values (1,&apos;张三&apos;,20);--违反唯一约束insert into tb2 values(2,&apos;张三&apos;,25);--建表时，创建约束，有约束名create table tb3( tb3_id int , tb3_name varchar(20), tb3_age int, constraint no_id unique (tb3_id));insert into tb3 values (1,&apos;张三&apos;,20);insert into tb3(tb3_id,tb3_age) values(2,24);select * from tb3;--已经有了tb3_id为1的行记录，再次插入，违反唯一约束insert into tb3(tb3_id,tb3_name,tb3_age) values(1,&apos;李四&apos;,25);--给tb3表添加主键约束，主键名为：pk_idalter table tb3 add constraint pk_id primary key (tb3_id);--给tb3_name添加唯一约束alter table tb3 add constraint un_name unique (tb3_name);--已存在姓名为张三的记录，违反唯一约束insert into tb3 values (3,&apos;张三&apos;,26);--mysql 删除约束的语句，使用index，oracle SqlServer等使用constraintalter table tb3 drop index un_name;--删除约束后，允许存在多个tb3_name为张三的记录insert into tb3 values (3,&apos;张三&apos;,26); PRIMARY KEY 约束PRIMARY KEY 约束唯一标识数据库表中的每条记录。 主键必须包含唯一的值。 主键列不能包含 NULL 值。 每个表都应该有一个主键，并且每个表只能有一个主键。 CREATE TABLE 时的 SQL PRIMARY KEY 约束下面的 SQL 在 “Persons” 表创建时在 “P_Id” 列上创建 PRIMARY KEY 约束： MySQL123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),PRIMARY KEY (P_Id)) SQL Server / Oracle / MS Access：12345678CREATE TABLE Persons(P_Id int NOT NULL PRIMARY KEY,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),MySQLCity varchar(255)) 如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法：MySQL / SQL Server / Oracle / MS Access：123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)) 注释：在上面的实例中，只有一个主键 PRIMARY KEY（pk_PersonID）。然而，pk_PersonID 的值是由两个列（P_Id 和 LastName）组成的。 ALTER TABLE 时的 SQL PRIMARY KEY 约束当表已被创建时，如需在 “P_Id” 列创建 PRIMARY KEY 约束，请使用下面的 SQL： MySQL / SQL Server / Oracle / MS Access12ALTER TABLE PersonsADD PRIMARY KEY (P_Id) 如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法：MySQL / SQL Server / Oracle / MS Access：12ALTER TABLE PersonsADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName) 注释：如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。 撤销 PRIMARY KEY 约束如需撤销 PRIMARY KEY 约束，请使用下面的 SQL：MySQL12ALTER TABLE PersonsDROP PRIMARY KEY SQL Server / Oracle / MS Access：12ALTER TABLE PersonsDROP CONSTRAINT pk_PersonID 笔记撤销PRIMARY KEY约束时，不论约束条件为一列还是多列，对于MySQL，由于PRIMARY KEY唯一性，MYSQL处理办法简单,撤销都是12ALTER TABLE PersonsDROP PRIMARY KEY 但对于 SQL Server / Oracle / MS Access， 一个列12ALTER TABLE PersonsDROP CONSTRAINT P_Id 若起约束名，也可如下多个列12ALTER TABLE PersonsDROP CONSTRAINT pk_PersonID FOREIGN KEY 约束SQL FOREIGN KEY 约束一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。 让我们通过一个实例来解释外键。请看下面两个表： “Persons” 表： “Orders” 表： 请注意，”Orders” 表中的 “P_Id” 列指向 “Persons” 表中的 “P_Id” 列。 “Persons” 表中的 “P_Id” 列是 “Persons” 表中的 PRIMARY KEY。 “Orders” 表中的 “P_Id” 列是 “Orders” 表中的 FOREIGN KEY。 FOREIGN KEY 约束用于预防破坏表之间连接的行为。 FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 CREATE TABLE 时的 SQL FOREIGN KEY 约束下面的 SQL 在 “Orders” 表创建时在 “P_Id” 列上创建 FOREIGN KEY 约束： MySQL 12345678CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,PRIMARY KEY (O_Id),FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)) SQL Server / Oracle / MS Access： 123456CREATE TABLE Orders(O_Id int NOT NULL PRIMARY KEY,OrderNo int NOT NULL,P_Id int FOREIGN KEY REFERENCES Persons(P_Id)) 如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法： MySQL / SQL Server / Oracle / MS Access：123456789CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,PRIMARY KEY (O_Id),CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id)REFERENCES Persons(P_Id)) ALTER TABLE 时的 SQL FOREIGN KEY 约束当 “Orders” 表已被创建时，如需在 “P_Id” 列创建 FOREIGN KEY 约束，请使用下面的 SQL：MySQL / SQL Server / Oracle / MS Access：123ALTER TABLE OrdersADD FOREIGN KEY (P_Id)REFERENCES Persons(P_Id) 如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法： MySQL / SQL Server / Oracle / MS Access：1234ALTER TABLE OrdersADD CONSTRAINT fk_PerOrdersFOREIGN KEY (P_Id)REFERENCES Persons(P_Id) 撤销 FOREIGN KEY 约束如需撤销 FOREIGN KEY 约束，请使用下面的 SQL：MySQL： 12ALTER TABLE OrdersDROP FOREIGN KEY fk_PerOrders SQL Server / Oracle / MS Access：12ALTER TABLE OrdersDROP CONSTRAINT fk_PerOrders CHECK 约束CHECK 约束用于限制列中的值的范围。 如果对单个列定义 CHECK 约束，那么该列只允许特定的值。 如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。 CREATE TABLE 时的 SQL CHECK 约束下面的 SQL 在 “Persons” 表创建时在 “P_Id” 列上创建 CHECK 约束。CHECK 约束规定 “P_Id” 列必须只包含大于 0 的整数。MySQL：123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CHECK (P_Id&gt;0)) SQL Server / Oracle / MS Access：12345678CREATE TABLE Persons(P_Id int NOT NULL CHECK (P_Id&gt;0),LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) 如需命名 CHECK 约束，并定义多个列的 CHECK 约束，请使用下面的 SQL 语法：MySQL / SQL Server / Oracle / MS Access：123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City=&apos;Sandnes&apos;)) ALTER TABLE 时的 SQL CHECK 约束当表已被创建时，如需在 “P_Id” 列创建 CHECK 约束，请使用下面的 SQL：MySQL / SQL Server / Oracle / MS Access:12ALTER TABLE PersonsADD CHECK (P_Id&gt;0) 如需命名 CHECK 约束，并定义多个列的 CHECK 约束，请使用下面的 SQL 语法：MySQL / SQL Server / Oracle / MS Access：12ALTER TABLE PersonsADD CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City=&apos;Sandnes&apos;) 撤销 CHECK 约束如需撤销 CHECK 约束，请使用下面的 SQL：SQL Server / Oracle / MS Access：12ALTER TABLE PersonsDROP CONSTRAINT chk_Person MySQL：12ALTER TABLE PersonsDROP CHECK chk_Person DEFAULT 约束DEFAULT 约束用于向列中插入默认值。 如果没有规定其他的值，那么会将默认值添加到所有的新记录。 CREATE TABLE 时的 SQL DEFAULT 约束下面的 SQL 在 “Persons” 表创建时在 “City” 列上创建 DEFAULT 约束：My SQL / SQL Server / Oracle / MS Access：12345678CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255) DEFAULT &apos;Sandnes&apos;) 通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值：1234567CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,OrderDate date DEFAULT GETDATE()) ALTER TABLE 时的 SQL DEFAULT 约束当表已被创建时，如需在 “City” 列创建 DEFAULT 约束，请使用下面的 SQL：MySQL：12ALTER TABLE PersonsALTER City SET DEFAULT &apos;SANDNES&apos; SQL Server / MS Access：12ALTER TABLE PersonsALTER COLUMN City SET DEFAULT &apos;SANDNES&apos; Oracle：12ALTER TABLE PersonsMODIFY City DEFAULT &apos;SANDNES&apos; 撤销 DEFAULT 约束如需撤销 DEFAULT 约束，请使用下面的 SQL：MySQL：12ALTER TABLE PersonsALTER City DROP DEFAULT SQL Server / Oracle / MS Access：12ALTER TABLE PersonsALTER COLUMN City DROP DEFAULT CREATE INDEX 语句CREATE INDEX 语句用于在表中创建索引。 在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。 索引您可以在表中创建索引，以便更加快速高效地查询数据。 用户无法看到索引，它们只能被用来加速搜索/查询。 注释：更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。 SQL CREATE INDEX 语法在表上创建一个简单的索引。允许使用重复的值：12CREATE INDEX index_nameON table_name (column_name) SQL CREATE UNIQUE INDEX 语法在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着两个行不能拥有相同的索引值。Creates a unique index on a table. Duplicate values are not allowed:12CREATE UNIQUE INDEX index_nameON table_name (column_name) 注释：用于创建索引的语法在不同的数据库中不一样。因此，检查您的数据库中创建索引的语法。 CREATE INDEX 实例下面的 SQL 语句在 “Persons” 表的 “LastName” 列上创建一个名为 “PIndex” 的索引：12CREATE INDEX PIndexON Persons (LastName) 如果您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：12CREATE INDEX PIndexON Persons (LastName, FirstName) 撤销索引、撤销表以及撤销数据库通过使用 DROP 语句，可以轻松地删除索引、表和数据库。 DROP INDEX 语句DROP INDEX 语句用于删除表中的索引。 用于 MS Access 的 DROP INDEX 语法：1DROP INDEX index_name ON table_name 用于 MS SQL Server 的 DROP INDEX 语法：1DROP INDEX table_name.index_name 用于 DB2/Oracle 的 DROP INDEX 语法：1DROP INDEX index_name 用于 MySQL 的 DROP INDEX 语法：1ALTER TABLE table_name DROP INDEX index_name DROP TABLE 语句DROP TABLE 语句用于删除表。1DROP TABLE table_name DROP DATABASE 语句DROP DATABASE 语句用于删除数据库。1DROP DATABASE database_name TRUNCATE TABLE 语句如果我们仅仅需要删除表内的数据，但并不删除表本身，那么我们该如何做呢？ 请使用 TRUNCATE TABLE 语句：1TRUNCATE TABLE table_name ALTER TABLE 语句ALTER TABLE 语句用于在已有的表中添加、删除或修改列。 SQL ALTER TABLE 语法如需在表中添加列，请使用下面的语法:12ALTER TABLE table_nameADD column_name datatype 如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：12ALTER TABLE table_nameDROP COLUMN column_name 要改变表中列的数据类型，请使用下面的语法： SQL Server / MS Access：12ALTER TABLE table_nameALTER COLUMN column_name datatype My SQL / Oracle：12ALTER TABLE table_nameMODIFY COLUMN column_name datatype Oracle 10G 之后版本:12ALTER TABLE table_nameMODIFY column_name datatype; SQL ALTER TABLE 实例请看 “Persons” 表： P_Id LastName FirstName Address City 1 Hansen Ola Timoteivn 10 Sandnes 2 Svendson Tove Borgvn 23 Sandnes 3 Pettersen Kari Storgt 20 Stavanger 现在，我们想在 “Persons” 表中添加一个名为 “DateOfBirth” 的列。 我们使用下面的 SQL 语句：12ALTER TABLE PersonsADD DateOfBirth date 请注意，新列 “DateOfBirth” 的类型是 date，可以存放日期。数据类型规定列中可以存放的数据的类型。现在，”Persons” 表将如下所示： P_Id LastName FirstName Address City DateOfBirth 1 Hansen Ola Timoteivn 10 Sandnes 2 Svendson Tove Borgvn 23 Sandnes 3 Pettersen Kari Storgt 20 Stavanger 改变数据类型实例现在，我们想要改变 “Persons” 表中 “DateOfBirth” 列的数据类型。 我们使用下面的 SQL 语句：12ALTER TABLE PersonsALTER COLUMN DateOfBirth year 请注意，现在 “DateOfBirth” 列的类型是 year，可以存放 2 位或 4 位格式的年份。 DROP COLUMN 实例接下来，我们想要删除 “Person” 表中的 “DateOfBirth” 列。12ALTER TABLE PersonsDROP COLUMN DateOfBirth 现在，”Persons” 表将如下所示： P_Id LastName FirstName Address City 1 Hansen Ola Timoteivn 10 Sandnes 2 Svendson Tove Borgvn 23 Sandnes 3 Pettersen Kari Storgt 20 Stavanger AUTO INCREMENT 字段Auto-increment 会在新记录插入表中时生成一个唯一的数字。 我们通常希望在每次插入新记录时，自动地创建主键字段的值。 我们可以在表中创建一个 auto-increment 字段。 用于 MySQL 的语法下面的 SQL 语句把 “Persons” 表中的 “ID” 列定义为 auto-increment 主键字段：123456789CREATE TABLE Persons(ID int NOT NULL AUTO_INCREMENT,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),PRIMARY KEY (ID)) MySQL 使用 AUTO_INCREMENT 关键字来执行 auto-increment 任务。 默认地，AUTO_INCREMENT 的开始值是 1，每条新记录递增 1。 要让 AUTO_INCREMENT 序列以其他的值起始，请使用下面的 SQL 语法：1ALTER TABLE Persons AUTO_INCREMENT=100 要在 “Persons” 表中插入新记录，我们不必为 “ID” 列规定值（会自动添加一个唯一的值）：12INSERT INTO Persons (FirstName,LastName)VALUES (&apos;Lars&apos;,&apos;Monsen&apos;) 上面的 SQL 语句会在 “Persons” 表中插入一条新记录。”ID” 列会被赋予一个唯一的值。”FirstName” 列会被设置为 “Lars”，”LastName” 列会被设置为 “Monsen”。 用于 SQL Server 的语法下面的 SQL 语句把 “Persons” 表中的 “ID” 列定义为 auto-increment 主键字段：12345678CREATE TABLE Persons(ID int IDENTITY(1,1) PRIMARY KEY,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) MS SQL Server 使用 IDENTITY 关键字来执行 auto-increment 任务。 在上面的实例中，IDENTITY 的开始值是 1，每条新记录递增 1。 提示：要规定 “ID” 列以 10 起始且递增 5，请把 identity 改为 IDENTITY(10,5)。 要在 “Persons” 表中插入新记录，我们不必为 “ID” 列规定值（会自动添加一个唯一的值）：12INSERT INTO Persons (FirstName,LastName)VALUES (&apos;Lars&apos;,&apos;Monsen&apos;) 上面的 SQL 语句会在 “Persons” 表中插入一条新记录。”ID” 列会被赋予一个唯一的值。”FirstName” 列会被设置为 “Lars”，”LastName” 列会被设置为 “Monsen”。 用于 Access 的语法下面的 SQL 语句把 “Persons” 表中的 “ID” 列定义为 auto-increment 主键字段：12345678CREATE TABLE Persons(ID Integer PRIMARY KEY AUTOINCREMENT,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) MS Access 使用 AUTOINCREMENT 关键字来执行 auto-increment 任务。 默认地，AUTOINCREMENT 的开始值是 1，每条新记录递增 1。 提示：要规定 “ID” 列以 10 起始且递增 5，请把 autoincrement 改为 AUTOINCREMENT(10,5)。 要在 “Persons” 表中插入新记录，我们不必为 “ID” 列规定值（会自动添加一个唯一的值）：12INSERT INTO Persons (FirstName,LastName)VALUES (&apos;Lars&apos;,&apos;Monsen&apos;) 上面的 SQL 语句会在 “Persons” 表中插入一条新记录。”ID” 列会被赋予一个唯一的值。”FirstName” 列会被设置为 “Lars”，”LastName” 列会被设置为 “Monsen”。 语法 for Oracle在 Oracle 中，代码稍微复杂一点。 您必须通过 sequence 对象（该对象生成数字序列）创建 auto-increment 字段。 请使用下面的 CREATE SEQUENCE 语法：12345CREATE SEQUENCE seq_personMINVALUE 1START WITH 1INCREMENT BY 1CACHE 10 上面的代码创建一个名为 seq_person 的 sequence 对象，它以 1 起始且以 1 递增。该对象缓存 10 个值以提高性能。cache 选项规定了为了提高访问速度要存储多少个序列值。 要在 “Persons” 表中插入新记录，我们必须使用 nextval 函数（该函数从 seq_person 序列中取回下一个值）：12INSERT INTO Persons (ID,FirstName,LastName)VALUES (seq_person.nextval,&apos;Lars&apos;,&apos;Monsen&apos;) 上面的 SQL 语句会在 “Persons” 表中插入一条新记录。”ID” 列会被赋值为来自 seq_person 序列的下一个数字。”FirstName”列 会被设置为 “Lars”，”LastName” 列会被设置为 “Monsen”。 笔记给已经存在的colume添加自增语法：1ALTER TABLE table_name CHANGE column_name column_name data_type(size) constraint_name AUTO_INCREMENT; 比如1ALTER TABLE student CHANGE id id INT( 11 ) NOT NULL AUTO_INCREMENT; SQL 视图（Views）视图是可视化的表。本章讲解如何创建、更新和删除视图。 SQL CREATE VIEW 语句在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。 视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。 您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。 SQL CREATE VIEW 语法1234CREATE VIEW view_name ASSELECT column_name(s)FROM table_nameWHERE condition 注释：视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。 SQL CREATE VIEW 实例样本数据库 Northwind 拥有一些被默认安装的视图。视图 “Current Product List” 会从 “Products” 表列出所有正在使用的产品（未停产的产品）。这个视图使用下面的 SQL 创建：1234CREATE VIEW [Current Product List] ASSELECT ProductID,ProductNameFROM ProductsWHERE Discontinued=No 我们可以像这样查询上面这个视图：1SELECT * FROM [Current Product List] Northwind 样本数据库的另一个视图会选取 “Products” 表中所有单位价格高于平均单位价格的产品：1234CREATE VIEW [Products Above Average Price] ASSELECT ProductName,UnitPriceFROM ProductsWHERE UnitPrice&gt;(SELECT AVG(UnitPrice) FROM Products) 我们可以像这样查询上面这个视图：1SELECT * FROM [Products Above Average Price] Northwind 样本数据库的另一个视图会计算在 1997 年每个种类的销售总数。请注意，这个视图会从另一个名为 “Product Sales for 1997” 的视图那里选取数据：1234CREATE VIEW [Category Sales For 1997] ASSELECT DISTINCT CategoryName,Sum(ProductSales) AS CategorySalesFROM [Product Sales for 1997]GROUP BY CategoryName 我们可以像这样查询上面这个视图：1SELECT * FROM [Category Sales For 1997] 我们也可以向查询添加条件。现在，我们仅仅需要查看 “Beverages” 类的销售总数：12SELECT * FROM [Category Sales For 1997]WHERE CategoryName=&apos;Beverages&apos; SQL 更新视图您可以使用下面的语法来更新视图： SQL CREATE OR REPLACE VIEW 语法1234CREATE OR REPLACE VIEW view_name ASSELECT column_name(s)FROM table_nameWHERE condition 现在，我们希望向 “Current Product List” 视图添加 “Category” 列。我们将通过下列 SQL 更新视图：1234CREATE VIEW [Current Product List] ASSELECT ProductID,ProductName,CategoryFROM ProductsWHERE Discontinued=No SQL Server1234567891011ALTER VIEW [ schema_name . ] view_name [ ( column [ ,...n ] ) ] [ WITH &lt;view_attribute&gt; [ ,...n ] ] AS select_statement [ WITH CHECK OPTION ] [ ; ]&lt;view_attribute&gt; ::= &#123; [ ENCRYPTION ] [ SCHEMABINDING ] [ VIEW_METADATA ] &#125; schema_name: 视图所属架构的名称。 view_name: 要更改的视图。 column: 将成为指定视图的一部分的一个或多个列的名称（以逗号分隔）。 SQL 撤销视图您可以通过 DROP VIEW 命令来删除视图。 SQL DROP VIEW 语法1DROP VIEW view_name Date 函数SQL 日期（Dates）当我们处理日期时，最难的任务恐怕是确保所插入的日期的格式，与数据库中日期列的格式相匹配。只要您的数据包含的只是日期部分，运行查询就不会出问题。但是，如果涉及时间部分，情况就有点复杂了。在讨论日期查询的复杂性之前，我们先来看看最重要的内建日期处理函数。 MySQL Date 函数下面的表格列出了 MySQL 中最重要的内建日期函数： 函数 描述 NOW() 返回当前的日期和时间 CURDATE() 返回当前的日期 CURTIME() 返回当前的时间 DATE() 提取日期或日期/时间表达式的日期部分 EXTRACT() 返回日期/时间的单独部分 DATE_ADD() 向日期添加指定的时间间隔 DATE_SUB() 从日期减去指定的时间间隔 DATEDIFF() 返回两个日期之间的天数 DATE_FORMAT() 用不同的格式显示日期/时间 SQL Server Date 函数下面的表格列出了 SQL Server 中最重要的内建日期函数： 函数 描述 GETDATE() 返回当前的日期和时间 DATEPART() 返回日期/时间的单独部分 DATEADD() 在日期中添加或减去指定的时间间隔 DATEDIFF() 返回两个日期之间的时间 CONVERT() 用不同的格式显示日期/时间 SQL Date 数据类型MySQL 使用下列数据类型在数据库中存储日期或日期/时间值： DATE - 格式：YYYY-MM-DD DATETIME - 格式：YYYY-MM-DD HH:MM:SS TIMESTAMP - 格式：YYYY-MM-DD HH:MM:SS YEAR - 格式：YYYY 或 YYSQL Server 使用下列数据类型在数据库中存储日期或日期/时间值： DATE - 格式：YYYY-MM-DD DATETIME - 格式：YYYY-MM-DD HH:MM:SS SMALLDATETIME - 格式：YYYY-MM-DD HH:MM:SS TIMESTAMP - 格式：唯一的数字##SQL 日期处理如果不涉及时间部分，那么我们可以轻松地比较两个日期！假设我们有如下的 “Orders” 表： OrderId ProductName OrderDate 1 Geitost 2008-11-11 2 Camembert Pierrot 2008-11-09 3 Mozzarella di Giovanni 2008-11-11 4 Mascarpone Fabioli 2008-10-29 现在，我们希望从上表中选取 OrderDate 为 “2008-11-11” 的记录。 我们使用下面的 SELECT 语句：1SELECT * FROM Orders WHERE OrderDate=&apos;2008-11-11&apos; 结果集如下所示： OrderId ProductName OrderDate 1 Geitost 2008-11-11 3 Mozzarella di Giovanni 2008-11-11 现在，假设 “Orders” 表如下所示（请注意 “OrderDate” 列中的时间部分）： OrderId ProductName OrderDate 1 Geitost 2008-11-11 13:23:44 2 Camembert Pierrot 2008-11-09 15:45:21 3 Mozzarella di Giovanni 2008-11-11 11:12:01 4 Mascarpone Fabioli 2008-10-29 14:56:59 如果我们使用和上面一样的 SELECT 语句：123SELECT * FROM Orders WHERE OrderDate=&apos;2008-11-11&apos;或SELECT * FROM Orders WHERE OrderDate=&apos;2008-11-11 00：00：00&apos; 那么我们将得不到结果！因为表中没有”2008-11-11 00:00:00”日期。如果没有时间部分，默认时间为 00:00:00。 提示：如果您希望使查询简单且更易维护，那么请不要在日期中使用时间部分！ NULL 值NULL 值代表遗漏的未知数据。 默认地，表的列可以存放 NULL 值。 本章讲解 IS NULL 和 IS NOT NULL 操作符。 SQL NULL 值如果表中的某个列是可选的，那么我们可以在不向该列添加值的情况下插入新记录或更新已有的记录。这意味着该字段将以 NULL 值保存。 NULL 值的处理方式与其他值不同。 NULL 用作未知的或不适用的值的占位符。 注释:无法比较 NULL 和 0；它们是不等价的。 SQL 的 NULL 值处理请看下面的 “Persons” 表： P_Id LastName FirstName Address City 1 Hansen Ola Sandnes 2 Svendson Tove Borgvn 23 Sandnes 3 Pettersen Kari Stavanger 假如 “Persons” 表中的 “Address” 列是可选的。这意味着如果在 “Address” 列插入一条不带值的记录，”Address” 列会使用 NULL 值保存。 那么我们如何测试 NULL 值呢？ 无法使用比较运算符来测试 NULL 值，比如 =、&lt; 或 &lt;&gt;。 我们必须使用 IS NULL 和 IS NOT NULL 操作符。 SQL IS NULL我们如何仅仅选取在 “Address” 列中带有 NULL 值的记录呢？ 我们必须使用 IS NULL 操作符：12SELECT LastName,FirstName,Address FROM PersonsWHERE Address IS NULL 结果集如下所示： LastName FirstName Address City Hansen Ola Sandnes Pettersen Kari Stavanger 提示：请始终使用 IS NULL 来查找 NULL 值。 SQL IS NOT NULL我们如何仅仅选取在 “Address” 列中不带有 NULL 值的记录呢？ 我们必须使用 IS NOT NULL 操作符：12SELECT LastName,FirstName,Address FROM PersonsWHERE Address IS NOT NULL 结果集如下所示： LastName FirstName Address City Svendson Tove Borgvn 23 Sandnes NULL 函数SQL ISNULL()、NVL()、IFNULL() 和 COALESCE() 函数请看下面的 “Products” 表： P_Id ProductName UnitPrice UnitsInStock UnitsOnOrder 1 Jarlsberg 10.45 16 15 2 Mascarpone 32.56 23 3 Gorgonzola 15.67 9 20 假如 “UnitsOnOrder” 是可选的，而且可以包含 NULL 值。 我们使用下面的 SELECT 语句：12SELECT ProductName,UnitPrice*(UnitsInStock+UnitsOnOrder)FROM Products 在上面的实例中，如果有 “UnitsOnOrder” 值是 NULL，那么结果是 NULL。 微软的 ISNULL() 函数用于规定如何处理 NULL 值。 NVL()、IFNULL() 和 COALESCE() 函数也可以达到相同的结果。 在这里，我们希望 NULL 值为 0。 下面，如果 “UnitsOnOrder” 是 NULL，则不会影响计算，因为如果值是 NULL 则 ISNULL() 返回 0： SQL Server / MS Access 12SELECT ProductName,UnitPrice*(UnitsInStock+ISNULL(UnitsOnOrder,0))FROM Products OracleOracle 没有 ISNULL() 函数。不过，我们可以使用 NVL() 函数达到相同的结果： 12SELECT ProductName,UnitPrice*(UnitsInStock+NVL(UnitsOnOrder,0))FROM Products MySQLMySQL 也拥有类似 ISNULL() 的函数。不过它的工作方式与微软的 ISNULL() 函数有点不同。 在 MySQL 中，我们可以使用 IFNULL() 函数，如下所示： 12SELECT ProductName,UnitPrice*(UnitsInStock+IFNULL(UnitsOnOrder,0))FROM Products 或者我们可以使用 COALESCE() 函数，如下所示： 12SELECT ProductName,UnitPrice*(UnitsInStock+COALESCE(UnitsOnOrder,0))FROM Products 笔记123--如果alexa列为null值，则赋予0，否则，取原值select id,name,url,ifnull(alexa,0)from websites;select id,name,url,COALESCE(alexa,0) from websites; 通用数据类型数据类型定义列中存放的值的种类。 SQL 通用数据类型数据库表中的每个列都要求有名称和数据类型。Each column in a database table is required to have a name and a data type. SQL 开发人员必须在创建 SQL 表时决定表中的每个列将要存储的数据的类型。数据类型是一个标签，是便于 SQL 了解每个列期望存储什么类型的数据的指南，它也标识了 SQL 如何与存储的数据进行交互。 下面的表格列出了 SQL 中通用的数据类型： 数据类型 描述 CHARACTER(n) 字符/字符串。固定长度 n。 VARCHAR(n) 或CHARACTER VARYING(n) 字符/字符串。可变长度。最大长度 n。 BINARY(n) 二进制串。固定长度 n。 BOOLEAN 存储 TRUE 或 FALSE 值 VARBINARY(n)或BINARY VARYING(n) 二进制串。可变长度。最大长度 n。 INTEGER(p) 整数值（没有小数点）。精度 p。 SMALLINT 整数值（没有小数点）。精度 5。 INTEGER 整数值（没有小数点）。精度 10。 BIGINT 整数值（没有小数点）。精度 19。 DECIMAL(p,s) 精确数值，精度 p，小数点后位数 s。例如：decimal(5,2) 是一个小数点前有 3 位数小数点后有 2 位数的数字。 NUMERIC(p,s) 精确数值，精度 p，小数点后位数 s。（与 DECIMAL 相同） FLOAT(p) 近似数值，尾数精度 p。一个采用以 10 为基数的指数计数法的浮点数。该类型的 size 参数由一个指定最小精度的单一数字组成。 REAL 近似数值，尾数精度 7。 FLOAT 近似数值，尾数精度 16。 DOUBLE PRECISION 近似数值，尾数精度 16。 DATE 存储年、月、日的值。 TIME 存储小时、分、秒的值。 TIMESTAMP 存储年、月、日、小时、分、秒的值。 INTERVAL 由一些整数字段组成，代表一段时间，取决于区间的类型。 ARRAY 元素的固定长度的有序集合 MULTISET 元素的可变长度的无序集合 XML 存储 XML 数据 SQL 数据类型快速参考手册然而，不同的数据库对数据类型定义提供不同的选择。 下面的表格显示了各种不同的数据库平台上一些数据类型的通用名称： 数据类型 Access SQLServer Oracle MySQL PostgreSQL boolean Yes/No Bit Byte N/A Boolean integer Number (integer) Int Number IntInteger IntInteger float Number (single) FloatReal Number Float Numeric currency Currency Money N/A N/A Money string (fixed) N/A Char Char Char Char string (variable) Text (&lt;256)Memo (65k+) Varchar VarcharVarchar2 Varchar Varchar binary object OLE Object Memo Binary (fixed up to 8K)Varbinary (&lt;8K)Image (&lt;2GB) LongRaw BlobText BinaryVarbinary 注释：在不同的数据库中，同一种数据类型可能有不同的名称。即使名称相同，尺寸和其他细节也可能不同！ 请总是检查文档！ 用于各种数据库的数据类型Microsoft Access、MySQL 和 SQL Server 所使用的数据类型和范围。 Microsoft Access 数据类型 数据类型 描述 存储 Text 用于文本或文本与数字的组合。最多 255 个字符。 Memo Memo 用于更大数量的文本。最多存储 65,536 个字符。注释：无法对 memo 字段进行排序。不过它们是可搜索的。 Byte 允许 0 到 255 的数字。 1 字节 Integer 允许介于 -32,768 与 32,767 之间的全部数字。 2 字节 Long 允许介于 -2,147,483,648 与 2,147,483,647 之间的全部数字。 4 字节 Single 单精度浮点。处理大多数小数。 4 字节 Double 双精度浮点。处理大多数小数。 8 字节 Currency 用于货币。支持 15 位的元，外加 4 位小数。提示：您可以选择使用哪个国家的货币。 8 字节 AutoNumber AutoNumber 字段自动为每条记录分配数字，通常从 1 开始。 4 字节 Date/Time 用于日期和时间 8 字节 Yes/No 逻辑字段，可以显示为 Yes/No、True/False 或 On/Off。在代码中，使用常量 True 和 False （等价于 1 和 0）。注释：Yes/No 字段中不允许 Null 值 1 比特 Ole Object 可以存储图片、音频、视频或其他 BLOBs（Binary Large OBjects）。 最多 1GB Hyperlink 包含指向其他文件的链接，包括网页。 Lookup Wizard 允许您创建一个可从下拉列表中进行选择的选项列表。 4 字节 MySQL 数据类型在 MySQL 中，有三种主要的类型：Text（文本）、Number（数字）和 Date/Time（日期/时间）类型。Text 类型： 数据类型 描述 CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。 TINYTEXT 存放最大长度为 255 个字符的字符串。 TEXT 存放最大长度为 65,535 个字符的字符串。 BLOB 用于 BLOBs（Binary Large OBjects）。存放最多 65,535 字节的数据。 MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。 MEDIUMBLOB 用于 BLOBs（Binary Large OBjects）。存放最多 16,777,215 字节的数据。 LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。 LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 ENUM(x,y,z,etc.) 允许您输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照您输入的顺序排序的。可以按照此格式输入可能的值： ENUM(‘X’,’Y’,’Z’) SET 与 ENUM 类似，不同的是，SET 最多只能包含 64 个列表项且 SET 可存储一个以上的选择。 Number 类型： 数据类型 描述 TINYINT(size) 带符号-128到127 ，无符号0到255。 SMALLINT(size) 带符号范围-32768到32767，无符号0到65535, size 默认为 6。 MEDIUMINT(size) 带符号范围-8388608到8388607，无符号的范围是0到16777215。 size 默认为9 INT(size) 带符号范围-2147483648到2147483647，无符号的范围是0到4294967295。 size 默认为 11 BIGINT(size) 带符号的范围是-9223372036854775808到9223372036854775807，无符号的范围是0到18446744073709551615。size 默认为 20 FLOAT(size,d) 带有浮动小数点的小数字。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 DOUBLE(size,d) 带有浮动小数点的大数字。在 size 参数中规显示定最大位数。在 d 参数中规定小数点右侧的最大位数。 DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 1234567891011注意：以上的 size 代表的并不是存储在数据库中的具体的长度，如 int(4) 并不是只能存储4个长度的数字。实际上int(size)所占多少存储空间并无任何关系。int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。就是在显示给用户的方式有点不同外，int(M) 跟 int 数据类型是相同的。例如：1、int的值为10 （指定zerofill）int（9）显示结果为000000010int（3）显示结果为010就是显示的长度不一样而已 都是占用四个字节的空间 Date 类型： 数据类型 描述 DATE() 日期。格式：YYYY-MM-DD注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’ DATETIME() *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ TIMESTAMP() *时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的秒数来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC TIME() 时间。格式：HH:MM:SS注释：支持的范围是从 ‘-838:59:59’ 到 ‘838:59:59’ YEAR() 2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。 SQL Server 数据类型String 类型： 数据类型 描述 存储 char(n) 固定长度的字符串。最多 8,000 个字符。 Defined width varchar(n) 可变长度的字符串。最多 8,000 个字符。 2 bytes + number of chars varchar(max) 可变长度的字符串。最多 1,073,741,824 个字符。 2 bytes + number of chars text 可变长度的字符串。最多 2GB 文本数据。 4 bytes + number of chars nchar 固定长度的 Unicode 字符串。最多 4,000 个字符。 Defined width x 2 nvarchar 可变长度的 Unicode 字符串。最多 4,000 个字符。 nvarchar(max) 可变长度的 Unicode 字符串。最多 536,870,912 个字符。 ntext 可变长度的 Unicode 字符串。最多 2GB 文本数据。 bit 允许 0、1 或 NULL binary(n) 固定长度的二进制字符串。最多 8,000 字节。 varbinary 可变长度的二进制字符串。最多 8,000 字节。 varbinary(max) 可变长度的二进制字符串。最多 2GB。 image 可变长度的二进制字符串。最多 2GB。 Number 类型： 数据类型 描述 存储 tinyint 允许从 0 到 255 的所有数字。 1 字节 smallint 允许介于 -32,768 与 32,767 的所有数字。 2 字节 int 允许介于 -2,147,483,648 与 2,147,483,647 的所有数字。 4 字节 bigint 允许介于 -9,223,372,036,854,775,808 与 9,223,372,036,854,775,807 之间的所有数字。 8 字节 decimal(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 numeric(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 smallmoney 介于 -214,748.3648 与 214,748.3647 之间的货币数据。 4 字节 money 介于 -922,337,203,685,477.5808 与 922,337,203,685,477.5807 之间的货币数据。 8 字节 float(n) 从 -1.79E + 308 到 1.79E + 308 的浮动精度数字数据。n 参数指示该字段保存 4 字节还是 8 字节。float(24) 保存 4 字节，而 float(53) 保存 8 字节。n 的默认值是 53。 4 或 8 字节 real 从 -3.40E + 38 到 3.40E + 38 的浮动精度数字数据。 4 字节 Date 类型： 数据类型 描述 存储 datetime 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 3.33 毫秒。 8 字节 datetime2 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 100 纳秒。 6-8 字节 smalldatetime 从 1900 年 1 月 1 日 到 2079 年 6 月 6 日，精度为 1 分钟。 4 字节 date 仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。 3 bytes time 仅存储时间。精度为 100 纳秒。 3-5 字节 datetimeoffset 与 datetime2 相同，外加时区偏移。 8-10 字节 timestamp 存储唯一的数字，每当创建或修改某行时，该数字会更新。timestamp 值基于内部时钟，不对应真实时间。每个表只能有一个 timestamp 变量。 其他数据类型： 数据类型 描述 sql_variant 存储最多 8,000 字节不同数据类型的数据，除了 text、ntext 以及 timestamp。 uniqueidentifier 存储全局唯一标识符 (GUID)。 xml 存储 XML 格式化数据。最多 2GB。 cursor 存储对用于数据库操作的指针的引用。 table 存储结果集，供稍后处理。 —————— SQL函数 ——————SQL 函数SQL 拥有很多可用于计数和计算的内建函数。 Aggregate 函数SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。 有用的 Aggregate 函数： AVG() - 返回平均值 COUNT() - 返回行数 FIRST() - 返回第一个记录的值 LAST() - 返回最后一个记录的值 MAX() - 返回最大值 MIN() - 返回最小值 SUM() - 返回总和 Scalar 函数SQL Scalar 函数基于输入值，返回一个单一的值。 有用的 Scalar 函数： UCASE() - 将某个字段转换为大写 LCASE() - 将某个字段转换为小写 MID() - 从某个文本字段提取字符，MySql 中使用 SubString(字段，1，end) - 从某个文本字段提取字符 LEN() - 返回某个文本字段的长度 ROUND() - 对某个数值字段进行指定小数位数的四舍五入 NOW() - 返回当前的系统日期和时间 FORMAT() - 格式化某个字段的显示方式 演示数据库在本教程中，我们将使用 RUNOOB 样本数据库。 下面是选自 “access_log” 表的数据：12345678910111213+-----+---------+-------+------------+| aid | site_id | count | date |+-----+---------+-------+------------+| 1 | 1 | 45 | 2016-05-10 || 2 | 3 | 100 | 2016-05-13 || 3 | 1 | 230 | 2016-05-14 || 4 | 2 | 10 | 2016-05-14 || 5 | 5 | 205 | 2016-05-14 || 6 | 4 | 13 | 2016-05-15 || 7 | 3 | 220 | 2016-05-15 || 8 | 5 | 545 | 2016-05-16 || 9 | 3 | 201 | 2016-05-17 |+-----+---------+-------+------------+ AVG() 函数AVG() 函数返回数值列的平均值。 SQL AVG() 语法1SELECT AVG(column_name) FROM table_name 实例下面的 SQL 语句从 “access_log” 表的 “count” 列获取平均值：1SELECT AVG(count) AS CountAverage FROM access_log; 执行以上 SQL 输出结果如下：下面的 SQL 语句选择访问量高于平均访问量的 “site_id” 和 “count”：12SELECT site_id, count FROM access_logWHERE count &gt; (SELECT AVG(count) FROM access_log); 执行以上 SQL 输出结果如下： COUNT() 函数COUNT() 函数返回匹配指定条件的行数。 SQL COUNT(column_name) 语法COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）：1SELECT COUNT(column_name) FROM table_name; SQL COUNT(*) 语法1SELECT COUNT(*) FROM table_name; SQL COUNT(DISTINCT column_name) 语法COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目：1SELECT COUNT(DISTINCT column_name) FROM table_name; 注释：COUNT(DISTINCT) 适用于 ORACLE 和 Microsoft SQL Server，但是无法用于 Microsoft Access。 SQL COUNT(column_name) 实例下面的 SQL 语句计算 “access_log” 表中 “site_id”=3 的总访问量：12SELECT COUNT(count) AS nums FROM access_logWHERE site_id=3; SQL COUNT(*) 实例下面的 SQL 语句计算 “access_log” 表中总记录数：1SELECT COUNT(*) AS nums FROM access_log; SQL COUNT(DISTINCT column_name) 实例下面的 SQL 语句计算 “access_log” 表中不同 site_id 的记录数：1SELECT COUNT(DISTINCT site_id) AS nums FROM access_log; 笔记12345678-- 查询所有记录的条数select count(*) from access_log;-- 查询websites 表中 alexa列中不为空的记录的条数select count(alexa) from websites;-- 查询websites表中 country列中不重复的记录条数select count(distinct country) from websites; FIRST() 函数FIRST() 函数返回指定的列中第一个记录的值。 SQL FIRST() 语法1SELECT FIRST(column_name) FROM table_name; 注释：只有 MS Access 支持 FIRST() 函数。 SQL Server、MySQL 和 Oracle 中的 SQL FIRST() 工作区SQL Server 语法12SELECT TOP 1 column_name FROM table_nameORDER BY column_name ASC; 实例12SELECT TOP 1 name FROM WebsitesORDER BY id ASC; MySQL 语法123SELECT column_name FROM table_nameORDER BY column_name ASCLIMIT 1; 实例123SELECT name FROM WebsitesORDER BY id ASCLIMIT 1; Oracle 语法123SELECT column_name FROM table_nameORDER BY column_name ASCWHERE ROWNUM &lt;=1; 实例123SELECT name FROM WebsitesORDER BY id ASCWHERE ROWNUM &lt;=1; SQL FIRST() 实例下面的 SQL 语句选取 “Websites” 表的 “name” 列中第一个记录的值：1SELECT name AS FirstSite FROM Websites LIMIT 1; 执行以上 SQL 结果如下所示： LAST() 函数LAST() 函数返回指定的列中最后一个记录的值。 SQL LAST() 语法1SELECT LAST(column_name) FROM table_name; 注释：只有 MS Access 支持 LAST() 函数。 SQL Server、MySQL 和 Oracle 中的 SQL LAST() 工作区SQL Server 语法12SELECT TOP 1 column_name FROM table_nameORDER BY column_name DESC; 实例12SELECT TOP 1 name FROM Websites ORDER BY id DESC; MySQL 语法123SELECT column_name FROM table_nameORDER BY column_name DESCLIMIT 1; 实例123SELECT name FROM WebsitesORDER BY id DESCLIMIT 1; Oracle 语法123SELECT column_name FROM table_nameORDER BY column_name DESCWHERE ROWNUM &lt;=1; 实例123SELECT name FROM WebsitesORDER BY id DESCWHERE ROWNUM &lt;=1; SQL LAST() 实例下面的 SQL 语句选取 “Websites” 表的 “name” 列中最后一个记录的值：123SELECT name FROM WebsitesORDER BY id DESCLIMIT 1; 执行以上 SQL 结果如下所示： MAX() 函数MAX() 函数返回指定列的最大值。 SQL MAX() 语法1SELECT MAX(column_name) FROM table_name; SQL MAX() 实例下面的 SQL 语句从 “Websites” 表的 “alexa” 列获取最大值：1SELECT MAX(alexa) AS max_alexa FROM Websites; 执行以上 SQL 结果如下所示： MIN() FunctionMIN() 函数返回指定列的最小值。 SQL MIN() 语法1SELECT MIN(column_name) FROM table_name; SQL MIN() 实例下面的 SQL 语句从 “Websites” 表的 “alexa” 列获取最小值：1SELECT MIN(alexa) AS min_alexa FROM Websites; SUM() 函数SUM() 函数返回数值列的总数。 SQL SUM() 语法1SELECT SUM(column_name) FROM table_name; SQL SUM() 实例下面的 SQL 语句查找 “access_log” 表的 “count” 字段的总数：1SELECT SUM(count) AS nums FROM access_log; GROUP BY 语句GROUP BY 语句可结合一些聚合函数来使用，用于结合聚合函数，根据一个或多个列对结果集进行分组。 SQL GROUP BY 语法1234SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; GROUP BY 简单应用统计 access_log 各个 site_id 的访问量：12SELECT site_id, SUM(access_log.count) AS numsFROM access_log GROUP BY site_id; SQL GROUP BY 多表连接现在我们想要查找每个送货员配送的订单数目。 下面的 SQL 语句统计所有网站的访问的记录数：1234SELECT Websites.name,COUNT(access_log.aid) AS nums FROM access_logLEFT JOIN WebsitesON access_log.site_id=Websites.idGROUP BY Websites.name; HAVING 子句在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。 HAVING 子句可以让我们筛选分组后的各组数据。 SQL HAVING 语法12345SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_nameHAVING aggregate_function(column_name) operator value; SQL HAVING 实例现在我们想要查找总访问量大于 200 的网站。 我们使用下面的 SQL 语句：12345SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_logINNER JOIN WebsitesON access_log.site_id=Websites.id)GROUP BY Websites.nameHAVING SUM(access_log.count) &gt; 200; SQL HAVING 实例现在我们想要查找总访问量大于 200 的网站。 我们使用下面的 SQL 语句：12345SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_logINNER JOIN WebsitesON access_log.site_id=Websites.id)GROUP BY Websites.nameHAVING SUM(access_log.count) &gt; 200; 现在我们想要查找总访问量大于 200 的网站，并且 alexa 排名小于 200。 我们在 SQL 语句中增加一个普通的 WHERE 子句：123456SELECT Websites.name, SUM(access_log.count) AS nums FROM WebsitesINNER JOIN access_logON Websites.id=access_log.site_idWHERE Websites.alexa &lt; 200 GROUP BY Websites.nameHAVING SUM(access_log.count) &gt; 200; UCASE() 函数UCASE() 函数把字段的值转换为大写。 SQL UCASE() 语法1SELECT UCASE(column_name) FROM table_name; 用于 SQL Server 的语法1SELECT UPPER(column_name) FROM table_name; SQL UCASE() 实例下面的 SQL 语句从 “Websites” 表中选取 “name” 和 “url” 列，并把 “name” 列的值转换为大写：12SELECT UCASE(name) AS site_title, urlFROM Websites; 执行以上 SQL 输出结果如下： LCASE() 函数LCASE() 函数把字段的值转换为小写。 SQL LCASE() 语法1SELECT LCASE(column_name) FROM table_name; 用于 SQL Server 的语法1SELECT LOWER(column_name) FROM table_name; SQL LCASE() 实例下面的 SQL 语句从 “Websites” 表中选取 “name” 和 “url” 列，并把 “name” 列的值转换为小写：12SELECT LCASE(name) AS site_title, urlFROM Websites; 执行以上 SQL 输出结果如下： MID() 函数MID() 函数用于从文本字段中提取字符。 SQL MID() 语法1SELECT MID(column_name,start[,length]) FROM table_name; 参数 描述 column_name 必需。要提取字符的字段。 start 必需。规定开始位置（起始值是 1）。 length 可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。 SQL MID() 实例下面的 SQL 语句从 “Websites” 表的 “name” 列中提取前 4 个字符：12SELECT MID(name,1,4) AS ShortTitleFROM Websites; 执行以上 SQL 输出结果如下： LEN() 函数LEN() 函数返回文本字段中值的长度。 SQL LEN() 语法1SELECT LEN(column_name) FROM table_name; MySQL 中函数为 LENGTH():1SELECT LENGTH(column_name) FROM table_name; SQL LEN() 实例下面的 SQL 语句从 “Websites” 表中选取 “name” 和 “url” 列中值的长度：12SELECT name, LENGTH(url) as LengthOfURLFROM Websites; ROUND() 函数ROUND() 函数用于把数值字段舍入为指定的小数位数。 SQL ROUND() 语法1SELECT ROUND(column_name,decimals) FROM table_name; 参数 描述 column_name 必需。要舍入的字段。 decimals 必需。规定要返回的小数位数。 SQL ROUND() 实例ROUND(X)： 返回参数X的四舍五入的一个整数。123456mysql&gt; select ROUND(-1.23); -&gt; -1mysql&gt; select ROUND(-1.58); -&gt; -2mysql&gt; select ROUND(1.58); -&gt; 2 ROUND(X,D)： 返回参数X的四舍五入的有 D 位小数的一个数字。如果D为0，结果将没有小数点或小数部分。1234mysql&gt; select ROUND(1.298, 1); -&gt; 1.3mysql&gt; select ROUND(1.298, 0); -&gt; 1 注意：ROUND 返回值被变换为一个BIGINT! NOW() 函数NOW() 函数返回当前系统的日期和时间。 SQL NOW() 语法1SELECT NOW() FROM table_name; SQL NOW() 实例下面的 SQL 语句从 “Websites” 表中选取 name，url，及当天日期：12SELECT name, url, Now() AS dateFROM Websites; FORMAT() 函数FORMAT() 函数用于对字段的显示进行格式化。 SQL FORMAT() 语法1SELECT FORMAT(column_name,format) FROM table_name; 参数 描述 column_name 必需。要格式化的字段。 format 必需。规定格式。 SQL FORMAT() 实例下面的 SQL 语句从 “Websites” 表中选取 name, url 以及格式化为 YYYY-MM-DD 的日期：12SELECT name, url, DATE_FORMAT(Now(),&apos;%Y-%m-%d&apos;) AS dateFROM Websites; 快速参考 SQL 语句 语法 AND / OR SELECT column_name(s)FROM table_nameWHERE conditionAND OR condition ALTER TABLE ALTER TABLE table_name ADD column_name datatypeorALTER TABLE table_name DROP COLUMN column_name AS (alias) SELECT column_name AS column_aliasFROM table_nameorSELECT column_nameFROM table_name AS table_alias BETWEEN SELECT column_name(s)FROM table_nameWHERE column_nameBETWEEN value1 AND value2 CREATE DATABASE CREATE DATABASE database_name CREATE TABLE CREATE TABLE table_name(column_name1 data_type,column_name2 data_type,column_name2 data_type,…) CREATE INDEX CREATE INDEX index_nameON table_name (column_name)orCREATE UNIQUE INDEX index_nameON table_name (column_name) CREATE VIEW CREATE VIEW view_name ASSELECT column_name(s)FROM table_nameWHERE condition DELETE DELETE FROM table_nameWHERE some_column=some_valueorDELETE FROM table_name (Note: Deletes the entire table!!)DELETE * FROM table_name (Note: Deletes the entire table!!) DROP DATABASE DROP DATABASE database_name DROP INDEX DROP INDEX table_name.index_name (SQL Server)DROP INDEX index_name ON table_name (MS Access)DROP INDEX index_name (DB2/Oracle)ALTER TABLE table_nameDROP INDEX index_name (MySQL) DROP TABLE DROP TABLE table_name GROUP BY SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name HAVING SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_nameHAVING aggregate_function(column_name) operator value IN SELECT column_name(s)FROM table_nameWHERE column_nameIN (value1,value2,..) INSERT INTO INSERT INTO table_nameVALUES (value1, value2, value3,….)orINSERT INTO table_name(column1, column2, column3,…)VALUES (value1, value2, value3,….) INNER JOIN SELECT column_name(s)FROM table_name1INNER JOIN table_name2 ON table_name1.column_name=table_name2.column_name LEFT JOIN SELECT column_name(s)FROM table_name1LEFT JOIN table_name2 ON table_name1.column_name=table_name2.column_name RIGHT JOIN SELECT column_name(s)FROM table_name1RIGHT JOIN table_name2 ON table_name1.column_name=table_name2.column_name FULL JOIN SELECT column_name(s)FROM table_name1FULL JOIN table_name2 ON table_name1.column_name=table_name2.column_name LIKE SELECT column_name(s)FROM table_nameWHERE column_name LIKE pattern ORDER BY SELECT column_name(s)FROM table_nameORDER BY column_name [ASC/DESC] SELECT SELECT column_name(s)FROM table_name SELECT * SELECT *FROM table_name SELECT DISTINCT SELECT DISTINCT column_name(s)FROM table_name SELECT INTO SELECT *INTO new_table_name [IN externaldatabase]FROM old_table_nameorSELECT column_name(s)INTO new_table_name [IN externaldatabase]FROM old_table_name SELECT TOP SELECT TOP number/percent column_name(s)FROM table_name TRUNCATE TABLE TRUNCATE TABLE table_name UNION SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2 UNION ALL SELECT column_name(s) FROM table_name1UNION ALLSELECT column_name(s) FROM table_name2 UPDATE UPDATE table_nameSET column1=value, column2=value,…WHERE some_column=some_value WHERE SELECT column_name(s)FROM table_nameWHERE column_name operator value SQL 主机如果您想要您的网站存储数据在数据库并从数据库显示数据，您的 Web 服务器必须能使用 SQL 语言访问数据库系统。 如果您的 Web 服务器托管在互联网服务提供商（ISP，全称 Internet Service Provider），您必须寻找 SQL 主机计划。 最常见的 SQL 主机数据库是 MySQL、MS SQL Server 和 MS Access。 您可以在 Windows 和 Linux/UNIX 操作系统上运行 SQL 主机数据库。 下面是操作系统上对应运行的数据库系统的概览。MS SQL Server在 Windows 和 Linux 操作系统上运行。MySQL在 Windows, Mac OS X 和 Linux/UNIX 操作系统上运行。MS Access（只建议用于小型网站）只在 Windows OS 上运行。如需学习有关 Web 主机的知识，请访主机教程 SQL 总结本 SQL 教程已经向您讲解了用来访问和处理数据库系统的标准计算机语言。 我们已经学习了如何使用 SQL 在数据库中执行查询、获取数据、插入新的记录、删除记录以及更新记录。 我们已经学习了如何通过 SQL 创建数据库、表、索引，以及如何撤销它们。 我们已经学习了 SQL 中最重要的 Aggregate 函数。 SQL 是一种与数据库系统协同工作的标准语言，这些数据库系统包括 MS SQL Server、IBM DB2、Oracle、MySQL 和 MS Access 等等。","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://haojiaqiang.github.io/tags/SQL/"}]},{"title":"程序是怎样跑起来的","slug":"How-does-the-program-run","date":"2015-01-01T00:18:08.000Z","updated":"2018-11-21T14:27:47.008Z","comments":true,"path":"2015/01/01/How-does-the-program-run/","link":"","permalink":"https://haojiaqiang.github.io/2015/01/01/How-does-the-program-run/","excerpt":"","text":"1.CPU内部结构解析 结构组成:寄存器(多个),控制器,运算器,时钟 语言分类: 机器语言: CPU可以解释和运行的语言 010110汇编语言: 使用助记符单词的编程语言(汇编,反汇编)高级语言: 类似人类语言的语法句子来编写(C、C++…)(机器语言 &lt;编译器&gt;高级语言) CPU能处理的指令类型和功能 2.二进制运算 逻辑运算:对二进制数各数字为的0和1分别进行处理的运算,逻辑非、逻辑与、逻辑或、逻辑异或（逻辑异） 算术运算:加减乘除四则运算表示范围 首位符号位负数表示: 相等绝对正正数取补数+1,(补数:01取反) 123456788位表示5 = 000001015的补数 = 11111010- 5 = 补数 + 1 = 11111011(x + x的补数) + 1 =&gt; (所有位都为1) + 1 == 0(高位溢出一位被忽略)(x的补数 + 1) + x == 0- x == x的补数 + 1 首位不表示符号位n位类型的数据,可以表示2的n次方个数首位不表示符号位,其表示范围为0~(2的n次方-1)首位表示符号位,其表示范围为-(2的n-1次方)~(2的n-1次方-1) short类型和unsigned short(16位,都表示2的16次幂个数,但范围不同)short表示范围:-32768~32767unsigned short表示范围:0~65535 左移和右移 逻辑左移和算术左移(乘法运算),都只需在空出来的低位补0即可,表示乘以2的n次方 逻辑右移,在空出的高位补0(图形模式时)算术右移,在空出的高位都补充位移前符号位的值(表示数值时),表示除以2的n次方 符号扩充(16位转32位,数值不变)将需要补充的高位全部替换成原符号位的值例如:1111 &gt; 11111111 3.内存使用 数组:物理逻辑双连续 &gt; 连续的统一数据类型的数据,增删操作会对该元素物理地址之后的所有元素重新移动生成,性能损耗大 链表:逻辑连续 &gt; 每个元素的数据结构为Value + nextPointer,逻辑顺序的数据不需要存储在连续的物理地址上,链式结构由每个元素的nextPointer串联形成.故而对增删操作,只需改变对应上一元素的nextIndex即可,无需对其他元素重新排列,无性能损耗 链表优势:无需预先知道数据大小,充分利用计算机内存空间，实现灵活的内存动态管理链表劣势:没有数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。 二叉树:链表发展而来,每个元素的数据结构为Value + leftPointer + rightPointer(枝叶是在leftPointer/rightPointer由逻辑对比关系区分,比如说大小,整个树的左右分叉规则一致),这样在知道逻辑关系的情况下,就可以只搜索分叉的一边,提高效率 4.压缩文件 文件中的字节数据都是连续存储的 RLE算法:AAAAABBCDDD = A5B2C1D3 &gt; 针对连续相同的数据效果好 哈夫曼算法(二叉树) &gt; 频率高德用短链表示,频率低的用长链表示 5.运行环境 = 操作系统 + 硬件 AT兼容机:硬件兼容,兼容IBM开发的PC/AT 源代码(程序员的代码,一般是高级语言) &gt;编译器(不同CPU亦不同)&gt; 本地代码(机器语言) 早期都是I/O直接调用硬件,造成程序只能在特定硬件上运行.后来I/O不直接作用于硬件而是通过API调用OS,由OS作用于硬件,此时需要适配硬件的工作由OS做 虚拟机:OS2App &gt; OS2 &gt; 虚拟机 &gt; OS1 Java虚拟机环境:Java源代码(.java) &gt;Java编译器&gt; 字节代码(.class) &gt;Java虚拟机(根据不用CPU对应生成)&gt; 本地代码 6.可执行文件 编译器:运行前对所有源代码进行解释处理,翻译成机器语言,一般默认编译成编译器所运行的CPU的机器语言,当然也可以指定其他 解释器:运行时对源代码的内容一行一行的进行解释处理 链接器:把多个目标文件(机器语言文件),生成一个可执行文件处理的程序 可执行文件:机器码 + OS配置描述该程序相关文件 动态库:程序运行时才调用的库,无需链接进可执行文件。好处：库中的函数可以被多个程序公用，节约内存和磁盘。此外，对动态库的函数进行修改时，不需要重新链接使用这个函数的程序。 源文件 &gt;编译器&gt; 目标文件(机器语言) &gt; 链接器(静态库/动态库) &gt; 可执行文件 可执行文件中,变量&amp;函数变成连续排列的组（变量组+函数组）），而且为变量&amp;函数分配了虚拟的内存地址 &gt; 程序运行,获得再配置信息 &gt; 变量&amp;函数获得相对地址 &gt; 基点地址(程序运行分配的)+相对地址(偏移量) &gt; 变量&amp;函数绝对地址 堆区内存:程序运行时申请分配,用来存储任意数据和对象 栈区内存:程序运行时申请分配,用来存储函数内部临时变量(局部变量)+函数参数 &gt; 不需要程序员管理(编译器自动生成管理代码) 7.操作系统和应用的关系 机器语言 &lt;反汇编&gt; 汇编语言(完整) 机器语言 &lt;反编译&gt; 高级语言(无法完全还原) 编译器不仅可以编译获得机器语言,一般也提供转换成汇编语言的功能汇编语言的语法:操作码+操作数 函数的参数是通过栈来传递的 函数的返回值是通过CPU寄存器来返回的 局部函数可以存储在栈或者寄存器中 锁:通过锁定,在特定范围内的处理完成之前,处理不会被切换到其他函数(线程)中 8.硬件控制方法 I/O控制器:交换主机同外围设备之间电流特性的IC,内部有用于临时保存输入输出数据的内存,这个内存就是端口. IRQ中断请求:CPU接收到来自中断控制器的中断请求后,会把当前正在运行的主程序中断,并切换到中断处理程序.中断处理程序的第一步,就是把CPU所有寄存器额数值保存到内存的栈中,在中断处理程序完成外围设备的输入输出后,把栈中保存的数据还原到CPU寄存器中,再继续进行对主程序的处理. DMA:Direct Memory Access不通过CPU的情况下,外围设备直接和主内存进行数据传达,比如硬盘","categories":[],"tags":[{"name":"app","slug":"app","permalink":"https://haojiaqiang.github.io/tags/app/"}]}]}