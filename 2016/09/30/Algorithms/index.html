<!DOCTYPE html>
<html>
    <!-- title -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Hayato">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Hayato">
    <meta name="keywords" content="Hayato's Studio | Hayato">
    <meta name="description" content="">
    <meta name="Cache-Control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>Algorithms · Hayato&#39;s Studio</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s 1;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= /css/style.css?v=20180709 as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= /css/mobile.css?v=20180709 media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Hayato&#39;s Studio.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Algorithms</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Hayato's Studio.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style=








height:50vh;

>
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Algorithms
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Algorithms">Algorithms</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count">20,115</span> / Reading time: <span class="post-count">86 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2016/09/30</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="部分算法实现动态效果"><a href="#部分算法实现动态效果" class="headerlink" title="部分算法实现动态效果"></a>部分算法实现动态效果</h1><p><a href="https://visualgo.net/en" target="_blank" rel="noopener">animation展示数据结构与算法实现</a></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>有序数组 &gt; 取value[mid]比较获知目标值的位置在low区还是high区 &gt; 每次查找的数组范围都是上次的1/2</p>
<h2 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>一组值和一组对这些值的操作的集合</p>
<h4 id="背包、队列和栈"><a href="#背包、队列和栈" class="headerlink" title="背包、队列和栈"></a>背包、队列和栈</h4><p> 背包：无序，只能添加不能移除</p>
<h4 id="加减乘除-括号的最基本算法实现"><a href="#加减乘除-括号的最基本算法实现" class="headerlink" title="加减乘除+括号的最基本算法实现"></a>加减乘除+括号的最基本算法实现</h4><p> 用两个栈（操作数栈和运算符栈）</p>
<ul>
<li>将<code>操作数</code>压入操作数栈</li>
<li>将<code>运算符</code>压入运算符栈</li>
<li>忽略<code>左括号</code></li>
<li>当遇到<code>右括号</code>时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p> 定义：链表是一种递归的数据结构，它或者为空（null)，或者指向一个节点(node）的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用（最后一个 next == null）</p>
<h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>JAVA中，字符串对象会使用40字节（16字节表示对象，三个int类型的实例变量各需4字节，加上字符数组引用的8字节（64位）和4个填充字节），这是除字符数组之外字符串所需的内存空间，所有字符所需的内存需要另计，因此字符串的char数组常常实在多个字符串对象之间共享的，这种设计能个在多个对象都含有相同的value[]数组时节省内存。</p>
<h4 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h4><p>由原字符串通过subString方法创建的字符串，仍然重用原字符串中的字符串数组value[],只需要改变对应的偏移量和长度域即可</p>
<h4 id="算法增长数量级表"><a href="#算法增长数量级表" class="headerlink" title="算法增长数量级表"></a>算法增长数量级表</h4><table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:center">增长的数量级</th>
<th style="text-align:left">典型的代码</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">常数级别</td>
<td style="text-align:center">1</td>
<td style="text-align:left">a = b + c</td>
<td style="text-align:left">普通语句</td>
<td style="text-align:left">将两个数相加</td>
</tr>
<tr>
<td style="text-align:left">对数级别</td>
<td style="text-align:center">log <em>N</em></td>
<td style="text-align:left">二分查找</td>
<td style="text-align:left">二分策略</td>
<td style="text-align:left">二分查找</td>
</tr>
<tr>
<td style="text-align:left">线性级别</td>
<td style="text-align:center">N</td>
<td style="text-align:left">double max = a[0];<br>for (int i = 1; i &lt; N; i++)<br> if (a[i] &gt; max) max = a[i];</td>
<td style="text-align:left">循环</td>
<td style="text-align:left">找出最大元素</td>
</tr>
<tr>
<td style="text-align:left">线性对书级别</td>
<td style="text-align:center"><em>N</em> log <em>N</em></td>
<td style="text-align:left"></td>
<td style="text-align:left">分治</td>
<td style="text-align:left">归并排序</td>
</tr>
<tr>
<td style="text-align:left">平方级别</td>
<td style="text-align:center">N²</td>
<td style="text-align:left">for (int i =0; i &lt; N; i ++)<br>for (int j = i+1; j &lt; N; j++)<br>if (a[i] + a[j] == 0)<br>cnt++;</td>
<td style="text-align:left">双层循环</td>
<td style="text-align:left">检查所有元素对</td>
</tr>
<tr>
<td style="text-align:left">立方级别</td>
<td style="text-align:center">N³</td>
<td style="text-align:left"></td>
<td style="text-align:left">三层循环</td>
<td style="text-align:left">检查所有三元组</td>
</tr>
<tr>
<td style="text-align:left">指数级别</td>
<td style="text-align:center">2^N</td>
<td style="text-align:left"></td>
<td style="text-align:left">穷举查找</td>
<td style="text-align:left">检查所有子集</td>
</tr>
</tbody>
</table>
<h4 id="不成熟的优化时所有罪恶之源-–-快速排序发明人Knuth"><a href="#不成熟的优化时所有罪恶之源-–-快速排序发明人Knuth" class="headerlink" title="不成熟的优化时所有罪恶之源 – 快速排序发明人Knuth"></a>不成熟的优化时所有罪恶之源 – 快速排序发明人Knuth</h4><p>代码要清晰正确，之后再考虑应用场景和频率做性能优化（优化经常会产生复杂而难以理解的代码）</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>定义</strong><br>一棵<code>树的大小</code>是它的节点的数量。树中的一个<code>节点的深度</code>是它到根节点的路径上的连接数。<code>树的高度</code>是它的所有节点中的最大深度。</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><a href="https://visualgo.net/en" target="_blank" rel="noopener">Gif power by visualgo.net</a></p>
<h2 id="各种排序方式的对比"><a href="#各种排序方式的对比" class="headerlink" title="各种排序方式的对比"></a>各种排序方式的对比</h2><p><img src="http://qiniu.hayato.tech/markdownimages/Algrothms-Sort-Comparison.jpg" alt=""></p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为O(1),因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引)</p>
<p>快速排序空间复杂度为logn(因为递归调用了) ,归并排序空间复杂是O(n),需要一个大小为n的临时数组.</p>
<p>基数排序的空间复杂是O(n),桶排序的空间复杂度不确定</p>
<h3 id="最快的排序算法是桶排序"><a href="#最快的排序算法是桶排序" class="headerlink" title="最快的排序算法是桶排序"></a>最快的排序算法是桶排序</h3><p>所有排序算法中最快的应该是桶排序(很多人误以为是快速排序,实际上不是.不过实际应用中快速排序用的多)但桶排序一般用的不多,因为有几个比较大的缺陷:</p>
<ul>
<li>待排序的元素不能是负数,小数.</li>
<li>空间复杂度不确定,要看待排序元素中最大值是多少</li>
</ul>
<p>所需要的辅助数组大小即为最大元素的值</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重複上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<p><img src="http://qiniu.hayato.tech/markdownimages/algorithms-bubbleSort1.gif" alt=""></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>时间复杂度：O(n) ～ O(n²) 性能非常差</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><figcaption><span>C</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/** 冒泡排序 */</span><br><span class="line">NSArray *bubbleSort(NSArray *unSortedArray) &#123;</span><br><span class="line">    // please check array if has uncomparable value first</span><br><span class="line">    NSComparisonResult order = NSOrderedAscending;</span><br><span class="line">    NSMutableArray *processArrayM = [unSortedArray mutableCopy];</span><br><span class="line">    NSInteger arrayCount = processArrayM.count;</span><br><span class="line">    for (NSInteger lastIndex = 0; lastIndex &lt; arrayCount; lastIndex++) &#123;</span><br><span class="line">        for (NSInteger j = 0; j &lt; arrayCount - lastIndex - 1; j++) &#123;</span><br><span class="line">            if ([processArrayM[j +1]  compare:processArrayM[j]] == order) &#123; // 将整个队列中相邻的元素做比较，将较小的元素和较大的元素交换位置</span><br><span class="line">                id temp = processArrayM[j];</span><br><span class="line">                processArrayM[j] = processArrayM[j + 1];</span><br><span class="line">                processArrayM[j +1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [processArrayM copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序-在剩下的元素中找到最小的元素"><a href="#选择排序-在剩下的元素中找到最小的元素" class="headerlink" title="选择排序(在剩下的元素中找到最小的元素)"></a>选择排序(在剩下的元素中找到最小的元素)</h2><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p><img src="http://qiniu.hayato.tech/markdownimages/algorithms-selectSort1.gif" alt=""></p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>运行时间和输入无关 (N-1)+(N-2)+…+2+1=N(N-1)/2 ~ N²次比较</li>
<li>数据移动是最少的 每次只会改变2个元素的值，依次选择排序用了N次交换——交换次数和数组的大小是线性关系</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/** 选择排序 */</span><br><span class="line">- (NSArray *)selectSortArray:(NSArray *)unSortedArray &#123;</span><br><span class="line">    NSComparisonResult order = NSOrderedAscending;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *precessArrayM = [NSMutableArray arrayWithArray:unSortedArray];</span><br><span class="line">    NSInteger arrayCount = precessArrayM.count;</span><br><span class="line">    // indicator</span><br><span class="line">    BOOL showIndicator = YES;</span><br><span class="line">    NSInteger compareTimes = 0, exchangeTimes = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; arrayCount - 1; i++) &#123;</span><br><span class="line">        for (int j = i + 1;  j &lt; arrayCount; j++) &#123;</span><br><span class="line">            id value = precessArrayM[i];</span><br><span class="line">            id nextValue = precessArrayM[j];</span><br><span class="line">            // check value </span><br><span class="line">            NSAssert([value respondsToSelector:@selector(compare:)] &amp;&amp; [nextValue respondsToSelector:@selector(compare:)], @&quot;array with uncomparable value&quot;);</span><br><span class="line">            if (showIndicator) compareTimes++;</span><br><span class="line">            </span><br><span class="line">            NSComparisonResult comparisonResult = [nextValue compare:value];//考虑same情况反向对比可稍微提高性能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (comparisonResult == order) &#123;</span><br><span class="line">                id temp = precessArrayM[i];</span><br><span class="line">                precessArrayM[i] = precessArrayM[j];</span><br><span class="line">                precessArrayM[j] = temp;</span><br><span class="line">                if (showIndicator) exchangeTimes++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (showIndicator)     NSLog(@&quot;%s arrayCount = %ld, compareTimes = %ld, exchangeTimes = %ld&quot;, __func__,  arrayCount, compareTimes, exchangeTimes);</span><br><span class="line">    return [NSArray arrayWithArray:precessArrayM];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ul>
<p>注：如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。</p>
<p><img src="http://qiniu.hayato.tech/markdownimages/algorithms-insertSort1.gif" alt=""></p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>所需时间取决于输入中元素的起始顺序，对于一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行的排序要快的多</li>
<li>插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小-1；平均需要～N² /4次比较和～N² /4次交换。最坏情况下需要～N² /2次比较和～N² /2次交换，最好情况下需要N-1次比较和0次交换<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/** 插入排序 */</span><br><span class="line">- (NSArray *)insertSortArray:(NSArray *)unSortedArray &#123;</span><br><span class="line">    NSComparisonResult order = NSOrderedAscending;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *processArrayM = [NSMutableArray arrayWithArray:unSortedArray];</span><br><span class="line">    NSInteger arrayCount = processArrayM.count;</span><br><span class="line">    // check array if has uncomparable value</span><br><span class="line">    </span><br><span class="line">    for (NSInteger i = 1; i &lt; arrayCount; i++) &#123;</span><br><span class="line">        id preValue = processArrayM[i -1];</span><br><span class="line">        id value = processArrayM[i];</span><br><span class="line">        NSComparisonResult comparisonResult = [value compare:preValue];//考虑same情况反向对比可稍微提高性能</span><br><span class="line">        if (comparisonResult == order) &#123;</span><br><span class="line">            NSInteger insertIndex = i;</span><br><span class="line">            while (insertIndex &gt; 0 &amp;&amp; [value compare:processArrayM[insertIndex - 1]] == order) &#123;// 将从起始位置start，i为end的已排序部分从高位开始依次往后移动一位,直到正好插入i元素的index</span><br><span class="line">                processArrayM[insertIndex] = processArrayM[insertIndex - 1];// 整体右移已排序部分</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            processArrayM[insertIndex] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [NSArray arrayWithArray:processArrayM];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul>
<li>希尔排序的实质就是分组插入排序，该方法又称缩小增量排序；是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</li>
<li>时间复杂度：其最坏时间复杂度依然为O(n²)<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-ShellSort1.png" alt="algorithms"><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void shellSort(int array[], int arrayLength) &#123;</span><br><span class="line">    int gap = 0, i  = 0, j = 0, temp = 0;</span><br><span class="line">    for (gap = arrayLength &gt;&gt; 1; gap &gt; 0; gap &gt;&gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        for (i = gap; i &lt; arrayLength; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            for (j = i - gap; j &gt;= 0 &amp;&amp; array[j] &gt; temp; j -= gap)</span><br><span class="line">            &#123;</span><br><span class="line">                array[j + gap] = array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer)的一个非常典型的应用。<br><br>递<strong>归</strong>分解数组（until子数组只有一个数据时，即可将该子数组视作有序），再（依次）合<strong>并</strong>(all有序的子)数组就完成了<strong>归并</strong>排序</p>
<h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="递归法（Top-down）"><a href="#递归法（Top-down）" class="headerlink" title="递归法（Top-down）"></a>递归法（Top-down）</h4><ul>
<li>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>4.重复步骤3直到某一指针到达序列尾</li>
<li>5.将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>
<h4 id="迭代法（Bottom-up）"><a href="#迭代法（Bottom-up）" class="headerlink" title="迭代法（Bottom-up）"></a>迭代法（Bottom-up）</h4><ul>
<li>1.将序列每相邻两个数字进行归并操作，形成 <code>ceil(n/2)</code>个序列（数组共有n个元素），排序后每个序列包含两/一个元素</li>
<li>2.若此时序列数不是1个则将上述序列再次归并，形成<code>ceil(n/4)</code> 个序列，每个序列包含四/三个元素</li>
<li>3.重复步骤2，直到所有元素排序完毕，即序列数为1</li>
</ul>
<p><img src="http://qiniu.hayato.tech/markdownimages/algorithms-mergeSort1.gif" alt=""></p>
<h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul>
<li>时间复杂度：O(<em>N</em>log<em>N</em>)</li>
<li>主要缺点：所需的额外空间和N成正比</li>
</ul>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void merge_sort(int array[], const int length) &#123;</span><br><span class="line">	int processArray[length];</span><br><span class="line">	merge_sort_recursive(array, processArray, 0, length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge_sort_recursive(int array[], int processArray[], int start, int end) &#123;</span><br><span class="line">	if (start &gt;= end) return;</span><br><span class="line">	int length = end - start, mid = (length &gt;&gt; 1) + start;</span><br><span class="line">	int start1 = start, end1 = mid;</span><br><span class="line">	int start2 = mid + 1, end2 = end;</span><br><span class="line">	merge_sort_recursive(array, processArray, start1, end1);</span><br><span class="line">	merge_sort_recursive(array, processArray, start2, end2);</span><br><span class="line"></span><br><span class="line">	// 合并有序子数组</span><br><span class="line">	int k = start;</span><br><span class="line">	while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) </span><br><span class="line">	&#123;</span><br><span class="line">		processArray[k++] = array[start1] &lt; array[start2] ? array[start1++] : array[start2++];</span><br><span class="line">	&#125;</span><br><span class="line">	while (start1 &lt;= end1)</span><br><span class="line">	&#123;</span><br><span class="line">		processArray[k++] = array[start1++];</span><br><span class="line">	&#125;</span><br><span class="line">	while (start2 &lt;= end2)</span><br><span class="line">	&#123;</span><br><span class="line">		processArray[k++] = array[start2++];</span><br><span class="line">	&#125;</span><br><span class="line">	for (k = start; k &lt;= end; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		array[k] = processArray[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序-划分交换排序"><a href="#快速排序-划分交换排序" class="headerlink" title="快速排序(划分交换排序)"></a>快速排序(划分交换排序)</h2><h3 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li>从数列中挑出一个元素，称为”基准值”（pivot），</li>
<li>重新排序数列（避免选到最边缘值），所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p><img src="http://qiniu.hayato.tech/markdownimages/algorithms-fastSort1.gif" alt=""></p>
<h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><ul>
<li>时间复杂度：O(<em>n</em>log<em>n</em>) ~ O(n²)，但最坏情况并不常见,通常明显比其他算法块，因为它内部循环在大部分架构上很有效率的达成</li>
<li>工程角度有较大优化空间：</li>
</ul>
<blockquote>
<p>1.对于小数组，快速排序比插入排序慢（多数&lt;15个元素）<br>2.三取样切分<br>3.熵最优排序</p>
</blockquote>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort(int array[], int length) &#123;</span><br><span class="line">    quick_sort_recursive(array, 0, length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quick_sort_recursive(int array[], int start, int end) &#123;</span><br><span class="line">    if (start &gt;= end)   return;// 递归出口</span><br><span class="line">    int standardValue = array[end]; // 对比参考值</span><br><span class="line">    int left = start, right = end - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (array[left] &lt; standardValue &amp;&amp; left &lt; right)// 依次找出左分组中&gt;对比值的index left</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (array[right] &gt;= standardValue &amp;&amp; left &lt; right)// 依次找出右分组中&lt;=对比值的index right</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;array[left], &amp;array[right]);// 对调当前左右分组中不符合项的一对value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (array[left] &gt;= array[end]) // left &amp;&amp; right游动index汇合处</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;array[left], &amp;array[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (left)</span><br><span class="line">    &#123;</span><br><span class="line">        quick_sort_recursive(array, start, left - 1);// 左分组递归分组并归类</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort_recursive(array, left + 1, end);// 右分组递归分组并归类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int *x, int *y) &#123;</span><br><span class="line">    int t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li>时间复杂度 O(<em>N</em>log<em>N</em>)</li>
</ul>
<p><img src="http://qiniu.hayato.tech/markdownimages/algorithms-heapSort1.gif" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//堆排序主要算法</span><br><span class="line">void HeapSort(int array[], int length)</span><br><span class="line">&#123;</span><br><span class="line">    //1.构建大顶堆</span><br><span class="line">    for (int i = length/2-1;i &gt;= 0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        //put the value in the final position</span><br><span class="line">        adjustHeap(array, i, length);</span><br><span class="line">    &#125;</span><br><span class="line">    //2.调整堆结构+交换堆顶元素与末尾元素</span><br><span class="line">    for (int j = length-1;j &gt; 0;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        //堆顶元素和末尾元素进行交换</span><br><span class="line">        int temp = array[0];</span><br><span class="line">        array[0] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">        </span><br><span class="line">        adjustHeap(array, 0, j);//重新对堆进行调整</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//大根堆进行调整</span><br><span class="line">void adjustHeap(int array[], int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    int temp = array[start];</span><br><span class="line">    for (int k = start * 2 + 1;k &lt; end;k = k * 2 + 1)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果右边值大于左边值，指向右边</span><br><span class="line">        if (k + 1 &lt; end &amp;&amp; array[k]&lt; array[k + 1])</span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子节点大于父节点，将子节点值赋给父节点,并以新的子节点作为父节点（不用进行交换）</span><br><span class="line">        if (array[k] &gt; temp)</span><br><span class="line">        &#123;</span><br><span class="line">            array[start] = array[k];</span><br><span class="line">            start = k;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //put the value in the final position</span><br><span class="line">    array[start] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>优先队列是<strong>基于堆的完全二叉树</strong>，它和队列的概念无关。（它并不是队列，而是树）<br><br>优先队列最重要的操作就是： <strong>删除最大元素</strong>和<strong>插入元素</strong></p>
<h2 id="表排序"><a href="#表排序" class="headerlink" title="表排序"></a>表排序</h2><p>定义一个指针数组做为表。排序的时候，数组位置上的数值不变，改变的是指针的指向。</p>
<p><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-sort-tableSort.png" alt=""></p>
<p>如该图，初始数值：f d c a g b h e   开始时，比较f&gt;d，则指针0指向d，指针1指向f。之后比较f&gt;c，d&gt;c，则指针0指向c,指针1指向d，指针2指向f。以此类推，最终指针0指向a的位置(即table[0]=3，A[3]那个位置)</p>
<p>时间复杂度：<br> T = O( m N ) ，m 是每个A元素的复制时间。</p>
<h2 id="桶排序-Bucket-sort"><a href="#桶排序-Bucket-sort" class="headerlink" title="桶排序(Bucket sort)"></a>桶排序(Bucket sort)</h2><p>桶排序或所谓的箱排序的原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来</p>
<p><img src="http://qiniu.hayato.tech/markdownimages/Algrothms-Sort-BucketSort.gif" alt=""></p>
<p>排序过程：</p>
<ul>
<li>假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶</li>
<li>将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序</li>
<li>将各个桶中的数据有序的合并起来</li>
</ul>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基本思想：比如十进制数字排序，先按个位数大小排，再按十位数大小排，依次。举例如下：</p>
<p><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-sort-radices.png" alt=""></p>
<p>基数排序可以用来进行多关键字排序。如扑克牌：花色和数字大小两种关键字。</p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p>
<h3 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h3><ul>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个<code>不相交</code>的子树；</li>
<li>一棵N个结点的树有N-1条边。</li>
<li>对于任一二叉树，有关系N<sub>0</sub> = N<sub>2</sub> + 1(其中N<sub>0</sub>为叶结点树，N<sub>2</sub>为度为2的结点树)<h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3></li>
<li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li>
<li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<blockquote>
<p>二叉树：每个节点最多含有两个子树的树称为二叉树；</p>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。即从根到倒数第二层为完美二叉树，只有叶结点可能缺失，而且缺失的仅仅是右侧连续的叶结点，左侧叶结点连续不中断；</p>
<blockquote>
<p>完美/满二叉树：所有叶节点都在最底层的完全二叉树。即不缺任何结点，表示为深度为d则有2<sup>d-1</sup> - 1个结点；</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；<br><br>排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树；</p>
</blockquote>
</blockquote>
<blockquote>
<p>哈夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</p>
</blockquote>
<blockquote>
<p>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。</p>
</blockquote>
<p><img src="http://qiniu.hayato.tech/markdownimages/algorithms-tree.png" alt=""></p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><ol>
<li>序号：根起始为1，按从上到下、从左到右依次+1；</li>
</ol>
<ol start="2">
<li>对于有n个结点的完全二叉树的结点父子关系：<blockquote>
<ol>
<li>非根结点(i&gt;1)的父结点的序号是i/2；</li>
<li>结点(序号为i)的左孩子结点的序号是2i(若2i&lt;=n,否则没有左孩子);</li>
<li>结点(序号为i)的右孩子结点的序号是2i+1(若2i+1&lt;=n,否则没有右孩子)；</li>
</ol>
</blockquote>
</li>
</ol>
<p><img src="http://qiniu.hayato.tech/markdownimages/algorithms-CompleteBinaryTreeIndex.png" alt=""><br><img src="http://qiniu.hayato.tech/markdownimages/algorithms-CompleteBinaryTreeIndexArray.png" alt=""></p>
<h4 id="父节点表示法"><a href="#父节点表示法" class="headerlink" title="父节点表示法"></a>父节点表示法</h4><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 树节点的定义 */</span><br><span class="line">#define MAX_TREE_SIZE 100</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  TElemType data;</span><br><span class="line">  int parent; /* 父节点位置域 */</span><br><span class="line">&#125; PTNode;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">  int n; /* 节点数 */</span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><p>设已有链队列类型LinkQueue的定义及基本操作（参见队列）</p>
<h5 id="构造空树"><a href="#构造空树" class="headerlink" title="构造空树"></a>构造空树</h5><p>清空或销毁一个树也是同样的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void ClearTree(PTree *T)&#123;</span><br><span class="line">    T-&gt;n = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="构造树"><a href="#构造树" class="headerlink" title="构造树"></a>构造树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void CreateTree(PTree *T)&#123;</span><br><span class="line">    LinkQueue q;</span><br><span class="line">    QElemType p,qq;</span><br><span class="line">    int i=1,j,l;</span><br><span class="line">    char c[MAX_TREE_SIZE]; /* 临时存放孩子节点数组 */ </span><br><span class="line">    InitQueue(&amp;q); /* 初始化队列 */</span><br><span class="line">    printf(&quot;请输入根节点(字符型，空格为空): &quot;);</span><br><span class="line">    scanf(&quot;%c%*c&quot;,&amp;T-&gt;nodes[0].data); /* 根节点序号为0，%*c吃掉回车符 */</span><br><span class="line">    if(T-&gt;nodes[0].data!=Nil) /* 非空树 */  &#123;</span><br><span class="line">        T-&gt;nodes[0].parent=-1; /* 根节点无父节点 */</span><br><span class="line">        qq.name=T-&gt;nodes[0].data; </span><br><span class="line">        qq.num=0;</span><br><span class="line">        EnQueue(&amp;q,qq); /* 入队此节点 */</span><br><span class="line">        while(i&lt;MAX_TREE_SIZE&amp;&amp;!QueueEmpty(q)) /* 数组未满且队不空 */    &#123;</span><br><span class="line">            DeQueue(&amp;q,&amp;qq); /* 节点加入队列 */</span><br><span class="line">            printf(&quot;请按长幼顺序输入节点%c的所有孩子: &quot;,qq.name);</span><br><span class="line">            gets(c);</span><br><span class="line">            l=strlen(c);</span><br><span class="line">            for(j=0;j&lt;l;j++)&#123;</span><br><span class="line">                T-&gt;nodes[i].data=c[j];</span><br><span class="line">                T-&gt;nodes[i].parent=qq.num;</span><br><span class="line">                p.name=c[j]; </span><br><span class="line">                p.num=i;</span><br><span class="line">                EnQueue(&amp;q,p); /* 入队此节点 */</span><br><span class="line">                i++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if(i&gt;MAX_TREE_SIZE)&#123;</span><br><span class="line">              printf(&quot;节点数超过数组容量\n&quot;);</span><br><span class="line">              exit(OVERFLOW);</span><br><span class="line">          &#125;</span><br><span class="line">          T-&gt;n=i;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">          T-&gt;n=0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断树是否为空"><a href="#判断树是否为空" class="headerlink" title="判断树是否为空"></a>判断树是否为空</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status TreeEmpty(PTree *T)&#123;</span><br><span class="line">    /* 初始条件：树T存在。操作结果：若T为空树，则返回TRUE，否则返回FALSE */  </span><br><span class="line">    return T-&gt;n==0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取树的深度"><a href="#获取树的深度" class="headerlink" title="获取树的深度"></a>获取树的深度</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int TreeDepth(PTree *T)&#123;</span><br><span class="line">    /* 初始条件：树T存在。操作结果：返回T的深度 */</span><br><span class="line">    int k,m,def,max=0;</span><br><span class="line">    for(k=0;k&lt;T-&gt;n;++k)&#123;</span><br><span class="line">        def=1; /* 初始化本节点的深度 */</span><br><span class="line">        m=T-&gt;nodes[k].parent;</span><br><span class="line">        while(m!=-1)&#123;</span><br><span class="line">            m=T-&gt;nodes[m].parent;</span><br><span class="line">            def++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(max&lt;def)</span><br><span class="line">            max=def;</span><br><span class="line">    &#125;</span><br><span class="line">    return max; /* 最大深度 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取根节点"><a href="#获取根节点" class="headerlink" title="获取根节点"></a>获取根节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TElemType Root(PTree *T)&#123;</span><br><span class="line">    /* 初始条件：树T存在。操作结果：返回T的根 */</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;T-&gt;n;i++)</span><br><span class="line">      if(T-&gt;nodes[i].parent&lt;0)</span><br><span class="line">        return T-&gt;nodes[i].data;</span><br><span class="line">    return Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取第i个节点的值"><a href="#获取第i个节点的值" class="headerlink" title="获取第i个节点的值"></a>获取第i个节点的值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TElemType Value(PTree *T,int i)&#123;</span><br><span class="line">    /* 初始条件：树T存在，i是树T中节点的序号。操作结果：返回第i个节点的值 */</span><br><span class="line">    if(i&lt;T-&gt;n)</span><br><span class="line">        return T-&gt;nodes[i].data;</span><br><span class="line">    else</span><br><span class="line">        return Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="改变节点的值"><a href="#改变节点的值" class="headerlink" title="改变节点的值"></a>改变节点的值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status Assign(PTree *T,TElemType cur_e,TElemType value)</span><br><span class="line">&#123; /* 初始条件：树T存在，cur_e是树T中节点的值。操作结果：改cur_e为value */</span><br><span class="line">  int j;</span><br><span class="line">  for(j=0;j&lt;T-&gt;n;j++)</span><br><span class="line">  &#123;</span><br><span class="line">    if(T-&gt;nodes[j].data==cur_e)</span><br><span class="line">    &#123;</span><br><span class="line">      T-&gt;nodes[j].data=value;</span><br><span class="line">      return OK;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取节点的父节点"><a href="#获取节点的父节点" class="headerlink" title="获取节点的父节点"></a>获取节点的父节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TElemType Parent(PTree *T,TElemType cur_e)</span><br><span class="line">&#123; /* 初始条件：树T存在，cur_e是T中某个节点 */</span><br><span class="line">  /* 操作结果：若cur_e是T的非根节点，则返回它的父节点，否则函数值为＂空＂*/</span><br><span class="line">  int j;</span><br><span class="line">  for(j=1;j&lt;T-&gt;n;j++) /* 根节点序号为0 */</span><br><span class="line">    if(T-&gt;nodes[j].data==cur_e)</span><br><span class="line">      return T-&gt;nodes[T-&gt;nodes[j].parent].data;</span><br><span class="line">  return Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取节点的最左孩子节点"><a href="#获取节点的最左孩子节点" class="headerlink" title="获取节点的最左孩子节点"></a>获取节点的最左孩子节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TElemType LeftChild(PTree *T,TElemType cur_e)</span><br><span class="line">&#123; /* 初始条件：树T存在，cur_e是T中某个节点 */</span><br><span class="line">  /* 操作结果：若cur_e是T的非叶子节点，则返回它的最左孩子，否则返回＂空＂*/</span><br><span class="line">  int i,j;</span><br><span class="line">  for(i=0;i&lt;T-&gt;n;i++)</span><br><span class="line">    if(T-&gt;nodes[i].data==cur_e) /* 找到cur_e，其序号为i */</span><br><span class="line">      break;</span><br><span class="line">  for(j=i+1;j&lt;T-&gt;n;j++) /* 根据树的构造函数，孩子的序号＞其父节点的序号 */</span><br><span class="line">    if(T-&gt;nodes[j].parent==i) /* 根据树的构造函数，最左孩子(长子)的序号＜其它孩子的序号 */</span><br><span class="line">      return T-&gt;nodes[j].data;</span><br><span class="line">  return Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取节点的右兄弟节点"><a href="#获取节点的右兄弟节点" class="headerlink" title="获取节点的右兄弟节点"></a>获取节点的右兄弟节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TElemType RightSibling(PTree *T,TElemType cur_e)</span><br><span class="line">&#123; /* 初始条件：树T存在，cur_e是T中某个节点 */</span><br><span class="line">  /* 操作结果：若cur_e有右(下一个)兄弟，则返回它的右兄弟，否则返回＂空＂*/</span><br><span class="line">  int i;</span><br><span class="line">  for(i=0;i&lt;T-&gt;n;i++)</span><br><span class="line">    if(T-&gt;nodes[i].data==cur_e) /* 找到cur_e，其序号为i */</span><br><span class="line">      break;</span><br><span class="line">  if(T-&gt;nodes[i+1].parent==T-&gt;nodes[i].parent)</span><br><span class="line">  /* 根据树的构造函数，若cur_e有右兄弟的话则右兄弟紧接其后 */</span><br><span class="line">    return T-&gt;nodes[i+1].data;</span><br><span class="line">  return Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="输出树"><a href="#输出树" class="headerlink" title="输出树"></a>输出树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Print(PTree *T)</span><br><span class="line">&#123; /* 输出树T。加 */</span><br><span class="line">  int i;</span><br><span class="line">  printf(&quot;节点个数=%d\n&quot;,T-&gt;n);</span><br><span class="line">  printf(&quot; 节点 父节点\n&quot;);</span><br><span class="line">  for(i=0;i&lt;T-&gt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;    %c&quot;,Value(T,i)); /* 节点 */</span><br><span class="line">    if(T-&gt;nodes[i].parent&gt;=0) /* 有父节点 */</span><br><span class="line">      printf(&quot;    %c&quot;,Value(T,T-&gt;nodes[i].parent)); /* 父节点 */</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="向树中插入另一棵树"><a href="#向树中插入另一棵树" class="headerlink" title="向树中插入另一棵树"></a>向树中插入另一棵树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Status InsertChild(PTree *T,TElemType p,int i,PTree c)</span><br><span class="line">&#123; /* 初始条件：树T存在，p是T中某个节点，1≤i≤p所指节点的度+1，非空树c与T不相交 */</span><br><span class="line">  /* 操作结果：插入c为T中p节点的第i棵子树 */</span><br><span class="line">  int j,k,l,f=1,n=0; /* 设交换标志f的初值为1，p的孩子数n的初值为0 */</span><br><span class="line">  PTNode t;</span><br><span class="line">  if(!TreeEmpty(T)) /* T不空 */</span><br><span class="line">  &#123;</span><br><span class="line">    for(j=0;j&lt;T-&gt;n;j++) /* 在T中找p的序号 */</span><br><span class="line">      if(T-&gt;nodes[j].data==p) /* p的序号为j */</span><br><span class="line">        break;</span><br><span class="line">    l=j+1; /* 如果c是p的第1棵子树，则插在j+1处 */</span><br><span class="line">    if(i&gt;1) /* c不是p的第1棵子树 */</span><br><span class="line">    &#123;</span><br><span class="line">      for(k=j+1;k&lt;T-&gt;n;k++) /* 从j+1开始找p的前i-1个孩子 */</span><br><span class="line">        if(T-&gt;nodes[k].parent==j) /* 当前节点是p的孩子 */</span><br><span class="line">        &#123;</span><br><span class="line">          n++; /* 孩子数加1 */</span><br><span class="line">          if(n==i-1) /* 找到p的第i-1个孩子，其序号为k1 */</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">      l=k+1; /* c插在k+1处 */</span><br><span class="line">    &#125; /* p的序号为j，c插在l处 */</span><br><span class="line">    if(l&lt;T-&gt;n) /* 插入点l不在最后 */</span><br><span class="line">      for(k=T-&gt;n-1;k&gt;=l;k--) /* 依次将序号l以后的节点向后移c.n个位置 */</span><br><span class="line">      &#123;</span><br><span class="line">        T-&gt;nodes[k+c.n]=T-&gt;nodes[k];</span><br><span class="line">        if(T-&gt;nodes[k].parent&gt;=l)</span><br><span class="line">          T-&gt;nodes[k+c.n].parent+=c.n;</span><br><span class="line">      &#125;</span><br><span class="line">    for(k=0;k&lt;c.n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">      T-&gt;nodes[l+k].data=c.nodes[k].data; /* 依次将树c的所有节点插于此处 */</span><br><span class="line">      T-&gt;nodes[l+k].parent=c.nodes[k].parent+l;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;nodes[l].parent=j; /* 树c的根节点的父节点为p */</span><br><span class="line">    T-&gt;n+=c.n; /* 树T的节点数加c.n个 */</span><br><span class="line">    while(f)</span><br><span class="line">    &#123; /* 从插入点之后，将节点仍按层序排列 */</span><br><span class="line">      f=0; /* 交换标志置0 */</span><br><span class="line">      for(j=l;j&lt;T-&gt;n-1;j++)</span><br><span class="line">        if(T-&gt;nodes[j].parent&gt;T-&gt;nodes[j+1].parent)</span><br><span class="line">        &#123;/* 如果节点j的父节点排在节点j+1的父节点之后（树没有按层序排列），交换两节点*/</span><br><span class="line">          t=T-&gt;nodes[j];</span><br><span class="line">          T-&gt;nodes[j]=T-&gt;nodes[j+1];</span><br><span class="line">          T-&gt;nodes[j+1]=t;</span><br><span class="line">          f=1; /* 交换标志置1 */</span><br><span class="line">          for(k=j;k&lt;T-&gt;n;k++) /* 改变父节点序号 */</span><br><span class="line">            if(T-&gt;nodes[k].parent==j)</span><br><span class="line">              T-&gt;nodes[k].parent++; /* 父节点序号改为j+1 */</span><br><span class="line">            else if(T-&gt;nodes[k].parent==j+1)</span><br><span class="line">              T-&gt;nodes[k].parent--; /* 父节点序号改为j */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">  &#125;</span><br><span class="line">  else /* 树T不存在 */</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除子树"><a href="#删除子树" class="headerlink" title="删除子树"></a>删除子树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Status deleted[MAX_TREE_SIZE+1]; /* 删除标志数组(全局量) */</span><br><span class="line">void DeleteChild(PTree *T,TElemType p,int i)</span><br><span class="line">&#123; /* 初始条件：树T存在，p是T中某个节点，1≤i≤p所指节点的度 */</span><br><span class="line">  /* 操作结果：删除T中节点p的第i棵子树 */</span><br><span class="line">  int j,k,n=0;</span><br><span class="line">  LinkQueue q;</span><br><span class="line">  QElemType pq,qq;</span><br><span class="line">  for(j=0;j&lt;=T-&gt;n;j++)</span><br><span class="line">    deleted[j]=0; /* 置初值为0(不删除标记) */</span><br><span class="line">  pq.name=&apos;a&apos;; /* 此成员不用 */</span><br><span class="line">  InitQueue(&amp;q); /* 初始化队列 */</span><br><span class="line">  for(j=0;j&lt;T-&gt;n;j++)</span><br><span class="line">    if(T-&gt;nodes[j].data==p)</span><br><span class="line">      break; /* j为节点p的序号 */</span><br><span class="line">  for(k=j+1;k&lt;T-&gt;n;k++)</span><br><span class="line">  &#123;</span><br><span class="line">    if(T-&gt;nodes[k].parent==j)</span><br><span class="line">      n++;</span><br><span class="line">    if(n==i)</span><br><span class="line">      break; /* k为p的第i棵子树节点的序号 */</span><br><span class="line">  &#125;</span><br><span class="line">  if(k&lt;T-&gt;n) /* p的第i棵子树节点存在 */</span><br><span class="line">  &#123;</span><br><span class="line">    n=0;</span><br><span class="line">    pq.num=k;</span><br><span class="line">    deleted[k]=1; /* 置删除标记 */</span><br><span class="line">    n++;</span><br><span class="line">    EnQueue(&amp;q,pq);</span><br><span class="line">    while(!QueueEmpty(q))</span><br><span class="line">    &#123;</span><br><span class="line">      DeQueue(&amp;q,&amp;qq);</span><br><span class="line">      for(j=qq.num+1;j&lt;T-&gt;n;j++)</span><br><span class="line">        if(T-&gt;nodes[j].parent==qq.num)</span><br><span class="line">        &#123;</span><br><span class="line">          pq.num=j;</span><br><span class="line">          deleted[j]=1; /* 置删除标记 */</span><br><span class="line">          n++;</span><br><span class="line">          EnQueue(&amp;q,pq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(j=0;j&lt;T-&gt;n;j++)</span><br><span class="line">      if(deleted[j]==1)</span><br><span class="line">      &#123;</span><br><span class="line">        for(k=j+1;k&lt;=T-&gt;n;k++)</span><br><span class="line">        &#123;</span><br><span class="line">          deleted[k-1]=deleted[k];</span><br><span class="line">          T-&gt;nodes[k-1]=T-&gt;nodes[k];</span><br><span class="line">          if(T-&gt;nodes[k].parent&gt;j)</span><br><span class="line">            T-&gt;nodes[k-1].parent--;</span><br><span class="line">        &#125;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    T-&gt;n-=n; /* n为待删除节点数 */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层序遍历树"><a href="#层序遍历树" class="headerlink" title="层序遍历树"></a>层序遍历树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void TraverseTree(PTree *T,void(*Visit)(TElemType))</span><br><span class="line">&#123; /* 初始条件：二叉树T存在,Visit是对节点操作的应用函数 */</span><br><span class="line">  /* 操作结果：层序遍历树T,对每个节点调用函数Visit一次且仅一次 */</span><br><span class="line">  int i;</span><br><span class="line">  for(i=0;i&lt;T-&gt;n;i++)</span><br><span class="line">    Visit(T-&gt;nodes[i].data);</span><br><span class="line">  printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h5><p>存储结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*树的孩子链表存储表示*/</span><br><span class="line">typedef struct CTNode &#123; // 孩子节点</span><br><span class="line">  int child;</span><br><span class="line">  struct CTNode *next;</span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">  ElemType data； // 节点的数据元素</span><br><span class="line">  ChildPtr firstchild； // 孩子链表头指针</span><br><span class="line">&#125; CTBox;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">  CTBox nodes[MAX_TREE_SIZE]；</span><br><span class="line">  int n, r； // 节点数和根节点的位置</span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p>
<h3 id="二叉树和树的根本区别"><a href="#二叉树和树的根本区别" class="headerlink" title="二叉树和树的根本区别"></a>二叉树和树的根本区别</h3><ul>
<li>二叉树可以为空，树不能为空</li>
<li>二叉树中每个元素都恰好有两棵子树（其中一个或两个可能为空）。而树中每个元素可以有若干子树。</li>
<li>在二叉树中每个元素的子树都是有序的，也就是说，可以用左、右子树来区别。而树的子树间是无序的。</li>
</ul>
<h3 id="二叉树的特性"><a href="#二叉树的特性" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h3><ul>
<li><p>1.包含n(n&gt;0)个元素的二叉树边数是n-1。</p>
<blockquote>
<p>证明 二叉树中每个元素 (除了根节点)有且只有一个父节点。在子节点与父节点间有且只有一条边，因此边数为n-1。</p>
</blockquote>
</li>
<li><p>2.若二叉树的高度为h,h≥0,则该二叉树最少有h个元素，最多有2h−1个元素。<br><img src="http://qiniu.hayato.tech/markdownimages/algorithms-BinaryTree-.png" alt=""></p>
</li>
</ul>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>二维结构的线性化(一维化)</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ul>
<p>其中，<code>先序遍历、中序遍历、后序遍历</code>三种方式<code>经过的路径相同</code>，且<code>每一结点</code>均<code>被经过三次</code>(设没有左右子结点的结点的对应子结点为空结点)，只是被访问的时机不同(分别为第1、2、3次)。<br><br>层次遍历的结果与编号序列相同</p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>① 访问根结点<br><br>② 先序遍历其左子树<br><br>③ 先序遍历其右子树<br><br><img src="http://qiniu.hayato.tech/markdownimages/Argorithms-BinTreePreOrderTraversal.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void PreOrderTraversal(BinTree BT)</span><br><span class="line">&#123;</span><br><span class="line">    if(BT) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result: A B D F E C G H I</span><br></pre></td></tr></table></figure></p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>① 中序遍历其左子树<br><br>② 访问根结点<br><br>③ 中序遍历其右子树<br><br><img src="http://qiniu.hayato.tech/markdownimages/Argorithms-BinTreeInOrderTraversal.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void InOrderTraversal(BinTree BT) </span><br><span class="line">&#123;</span><br><span class="line">    if(BT) &#123;</span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        printf(&quot;%d&quot;, BT-&gt;Data);</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result: D B E F A G H C I</span><br></pre></td></tr></table></figure></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>① 后序遍历其左子树<br><br>② 后序遍历其右子树<br><br>③ 访问根结点<br><br><img src="http://qiniu.hayato.tech/markdownimages/Argorithms-BinTreePostOrderTraversal.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void PostOrderTraversal(BinTree BT)</span><br><span class="line">&#123;</span><br><span class="line">    if (BT) &#123;</span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">        printf(&quot;%d&quot;, BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resutl: D E F B H G I C A</span><br></pre></td></tr></table></figure></p>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>核心问题：二维结构的线性化<br></p>
<p>过程：</p>
<ul>
<li>从结点访问其左、右子结点</li>
<li>访问左子结点后，右子结点无法访问</li>
</ul>
<p>所以：</p>
<ul>
<li>需要一个存储结构保存暂时不访问的结点</li>
<li>存储结构：堆栈、队列</li>
</ul>
<p><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-BinTreeLevelTraverse.png" alt=""></p>
<p>队列实现：<br>遍历从根结点开始，首先将根结点入队，然后开始执行循环：结点出队、访问该结点、其左右子结点入队</p>
<p>层序基本过程：先根结点入队，然后：<br>① 从队列中取出一个元素<br><br>② 访问该元素所指向的结点<br><br>③ 若该元素所指的左、右子结点非空，则将其左、右子结点的指针顺序入队<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void LevelOrderTraversal(BinTree BT) </span><br><span class="line">&#123;</span><br><span class="line">    if (!BT) return;// 若树为空直接返回</span><br><span class="line">    Queue Q; BinTree T;</span><br><span class="line">    Q = CreatQueue(MaxSize);// 创建并初始化队列Q</span><br><span class="line">    AddQ(Q, BT);</span><br><span class="line">    while(!IsEmpty( Q )) &#123;</span><br><span class="line">        T = Delete( Q );</span><br><span class="line">        printf(&quot;%d\n&quot;, T-&gt;Data);// 访问取出队列的结点</span><br><span class="line">        </span><br><span class="line">        if(T-&gt;Left) &#123;</span><br><span class="line">            AddQ(Q, T-&gt;Left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(T-&gt;Right) &#123;</span><br><span class="line">            AddQ(Q,T-&gt;Right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二叉树的非递归遍历-使用栈"><a href="#二叉树的非递归遍历-使用栈" class="headerlink" title="二叉树的非递归遍历(使用栈)"></a>二叉树的非递归遍历(使用栈)</h3><p>中序遍历:<br><br>① 遇到一个结点，就把它压栈，并去遍历它的左子树<br><br>② 当左子树遍历结束后，从栈顶弹出这个结点并访问它<br><br>③ 再去中序遍历该结点的右子树<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void InOrderTraversal(BinTree BT)</span><br><span class="line">&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreatStack(MaxSize);// 创建并初始化栈S</span><br><span class="line">    while(T || !IsEmpty(S)) &#123;// 树不为空或栈内有值</span><br><span class="line">        while(T)&#123;// 一直向左并将沿途结点压入栈</span><br><span class="line">            Push(S, T-&gt;Data);</span><br><span class="line">            // printf(&quot;%d&quot;, T-&gt;Data);若在此处访问即为先序遍历</span><br><span class="line">            T = T-&gt;Left;   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(!IsEmpty(S)) &#123;</span><br><span class="line">            T = Pop(S);// 从栈中弹出结点</span><br><span class="line">            printf(&quot;%d&quot;, T-&gt;Data);// 访问(打印)结点，此处访问为中序遍历</span><br><span class="line">            T = T-&gt;Right;// 转向右子树</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="遍历二叉树的应用"><a href="#遍历二叉树的应用" class="headerlink" title="遍历二叉树的应用"></a>遍历二叉树的应用</h2><h3 id="输出二叉树中的叶子结点"><a href="#输出二叉树中的叶子结点" class="headerlink" title="输出二叉树中的叶子结点"></a>输出二叉树中的叶子结点</h3><p>思路：在遍历算法中输出结点处增加检测：左右结点是否都为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void PreOrderPrintLeaves(BinTree BT) </span><br><span class="line">&#123;</span><br><span class="line">    if (BT) &#123;</span><br><span class="line">        if (!BT-&gt;Left &amp;&amp; !BT-&gt;Right) &#123;</span><br><span class="line">            printf(&quot;%d&quot;, BT-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        PreOrderPrintLeaves(BT-&gt;Left);</span><br><span class="line">        PreOrderPrintLeaves(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="计算二叉树的高度"><a href="#计算二叉树的高度" class="headerlink" title="计算二叉树的高度"></a>计算二叉树的高度</h3><p>思路：Height = max(LeftHeight, RightHeight) + 1;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int PostOrderGetHeight(BinTree BT)</span><br><span class="line">&#123;</span><br><span class="line">    int leftHeight, rightHeight, maxHeight;</span><br><span class="line">    if (BT) &#123;</span><br><span class="line">        leftHeight = PostOrderGetHeight(BT-&gt;Left);// 左子树的深度</span><br><span class="line">        rightHeight = PostOrderGetHeight(BT-&gt;Right);// 右子树的深度</span><br><span class="line">        maxHeight = max(leftHeight, rightHeight);// 取左右树较大的深度</span><br><span class="line">        return maxHeight + 1;// 返回树的深度</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;// 空树深度为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二元运算表达树"><a href="#二元运算表达树" class="headerlink" title="二元运算表达树"></a>二元运算表达树</h3><p><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-BinTreeBinaryOperation.png" alt=""></p>
<h3 id="由两种序列遍历结果确定二叉树"><a href="#由两种序列遍历结果确定二叉树" class="headerlink" title="由两种序列遍历结果确定二叉树"></a>由两种序列遍历结果确定二叉树</h3><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>已知中序遍历结果，与先序或者后序其一即可确定唯一的二叉树。<br><br>如果仅有先序和后序而没有中序是不能确定的。<br>|先序+中序|中序+后序|先序+后序|<br>|:—:|:—:|:—:|<br>|✅|✅|❌|</p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li>可以根据前序/后序队列确定出根结点</li>
<li>在中序遍历中可由根结点分割处左右子树</li>
<li>对左右子树分别递归以上操作继续分解即可确定二叉树排列</li>
</ul>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>二叉查找树（Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>1.若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>2.若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>3.任意节点的左、右子树也分别为二叉查找树；</li>
<li>4.没有键值相等的节点。</li>
</ul>
<h3 id="二叉搜索树查找指定值"><a href="#二叉搜索树查找指定值" class="headerlink" title="二叉搜索树查找指定值"></a>二叉搜索树查找指定值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Position IterFind(ElementType X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    while( BST) &#123;</span><br><span class="line">        if (X &gt; BST-&gt;Data) &#123;</span><br><span class="line">            BST = BST-&gt;Right;// 向右子树移动，继续查找</span><br><span class="line">        &#125; else if(X &lt; BST-&gt;Data) &#123;</span><br><span class="line">            BST = BST-&gt;Left;// 向左子树移动，继续查找</span><br><span class="line">        &#125; else &#123;// x == BST-&gt;Data</span><br><span class="line">            return BST;// 查找成功，返回结点地址</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NotFound;// 查找失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树查找最小值"><a href="#二叉搜索树查找最小值" class="headerlink" title="二叉搜索树查找最小值"></a>二叉搜索树查找最小值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Position FinMin(BinTree BST) &#123;</span><br><span class="line">    if (!BST) &#123;// 数据校验</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125; else if (!BST-&gt;Left) &#123; // 找到最左叶结点</span><br><span class="line">        return BST-&gt;Data;</span><br><span class="line">    &#125; else &#123; // 沿左分枝递归查找</span><br><span class="line">        return FinMin(BST-&gt;Left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树查找最大值"><a href="#二叉搜索树查找最大值" class="headerlink" title="二叉搜索树查找最大值"></a>二叉搜索树查找最大值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Position FinMax(BinTree BST) &#123;</span><br><span class="line">    if (!BST) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125; else if (!BST-&gt;Right) &#123;</span><br><span class="line">        return BST-&gt;Data; </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return FinMax(BST-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树插入元素"><a href="#二叉搜索树插入元素" class="headerlink" title="二叉搜索树插入元素"></a>二叉搜索树插入元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BinTree Insert(ElementType X, BinTree BST) </span><br><span class="line">&#123;</span><br><span class="line">    if (!BST) &#123;// 原树为空和递归到最后插入的子树X时的情况</span><br><span class="line">        BST = malloc(sizeof(struct TreeNode));</span><br><span class="line">        BST-&gt;Data = x;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = NULL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (X &lt; BST-&gt;Left) &#123; // 递归插入左子树</span><br><span class="line">            BST-&gt;Left = Insert(X, BST-&gt;Left);</span><br><span class="line">        &#125; else if (X &gt; BST-&gt;Right) &#123; // 递归插入右子树</span><br><span class="line">            BST-&gt;Right = Insert(X, BST-Right);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // X已存在，do nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树删除结点"><a href="#二叉搜索树删除结点" class="headerlink" title="二叉搜索树删除结点"></a>二叉搜索树删除结点</h3><ol>
<li>要删除的结点只有一个子树<blockquote>
<p>用该唯一子树替换被删除的结点树</p>
</blockquote>
</li>
<li>要删除的结点有左、右两个子树<blockquote>
<p>选取左子树的最大结点，用该最大结点替换被删除结点，并将结点左指针指向已删除该最大结点的左子树</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>或选取右子树的最小结点，用该最小结点替换被删除结点，并将结点右指针指向已删除该最小结点的右子树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BinTree Delete (ElementType X, BinTree BST) &#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    if (!BST) return NULL;// 数据校验 </span><br><span class="line">  </span><br><span class="line">    if (X &lt; BST-&gt;Data) &#123;</span><br><span class="line">        BST-&gt;Left = Delete (X, BST-&gt;Left);// 左子树中递归删除</span><br><span class="line">    &#125; else if (X &gt; BST-&gt;Data) &#123;</span><br><span class="line">        BST-&gt;Right = Delete (X, BST-&gt;Right);// 右子树中递归删除</span><br><span class="line">    &#125; else &#123; // 查找到要删除的结点</span><br><span class="line">        if (BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; // 被删除结点有左右两个子结点</span><br><span class="line">            Tmp = FindMin(BST-&gt;Right);</span><br><span class="line">            BST-&gt;Data = tmp-&gt;Data;</span><br><span class="line">            BST-&gt;Right = Delete(tmp-&gt;Data, BST-&gt;Right);</span><br><span class="line">        &#125; else &#123; // 被删除结点只有一个或者没有子结点</span><br><span class="line">            Tmp = BST-&gt;Data;</span><br><span class="line">            if (!BST-&gt;Left) &#123; // 有右孩子或者无子结点</span><br><span class="line">                BST = BST-&gt;Right;</span><br><span class="line">            &#125; else if (!BST-&gt;Right)&#123; // 有左孩子或者无子结点</span><br><span class="line">                BST = BST-&gt;Left;</span><br><span class="line">            &#125; </span><br><span class="line">            free (Tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="平衡二叉查找树-AVL树"><a href="#平衡二叉查找树-AVL树" class="headerlink" title="平衡二叉查找树 AVL树"></a>平衡二叉查找树 AVL树</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>在AVL树中任何结点的左右两子树的高度差最大为1，也被称为高度平衡树</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>给定结点数为N的AVL树的最大高度为O(log<sub>2</sub>N)</p>
<h3 id="平衡二叉树的调整-旋转"><a href="#平衡二叉树的调整-旋转" class="headerlink" title="平衡二叉树的调整-旋转"></a>平衡二叉树的调整-旋转</h3><ol>
<li>原因: 在每一次插入数值之后，树的平衡性都可能被破坏，这时可以通过一个简单的操作来矫正平衡–旋转。</li>
<li>方式：旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</li>
<li>过程：通过旋转可以降低高度</li>
</ol>
<ul>
<li>所谓的<strong>左旋</strong>和<strong>右旋</strong>都是以子树为原点的：如b是a的子树，那么旋转就围绕b来进行。</li>
<li>如果b是a的左子树，那么就围绕b将a向右旋转，看着就像是a直接掉下来了，掉成了b的右子树。</li>
<li>如果b是a的右子树，那么就围绕b将a向左旋转，看着就像是a直接掉下来了，掉成了b的左子树。</li>
</ul>
<ol start="4">
<li>插入节点时分四种情况，四种情况对应的旋转方法是不同的：<br><br>例如对于被破坏平衡的挂叉着节点 a 来说：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">插入方式</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">旋转方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LL</td>
<td style="text-align:left">在a的左子树根节点的左子树上插入节点而破坏平衡</td>
<td style="text-align:left">右单旋</td>
</tr>
<tr>
<td style="text-align:left">RR</td>
<td style="text-align:left">在a的右子树根节点的右子树上插入节点而破坏平衡</td>
<td style="text-align:left">左单旋</td>
</tr>
<tr>
<td style="text-align:left">LR</td>
<td style="text-align:left">在a的左子树根节点的右子树上插入节点而破坏平衡</td>
<td style="text-align:left">先左旋后右旋</td>
</tr>
<tr>
<td style="text-align:left">RL</td>
<td style="text-align:left">在a的右子树根节点的左子树上插入节点而破坏平衡</td>
<td style="text-align:left">先右旋后左旋</td>
</tr>
</tbody>
</table>
<p><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVLExample.png" alt="VAL示例"></p>
<h4 id="LL旋转-右单旋）"><a href="#LL旋转-右单旋）" class="headerlink" title="LL旋转(右单旋）"></a>LL旋转(右单旋）</h4><p><strong>LL插入</strong>:不平衡的<strong>制造者</strong>插入<strong>发现者</strong>的左子树的左子结点上 -&gt;LL旋转</p>
<h5 id="破坏平衡"><a href="#破坏平衡" class="headerlink" title="破坏平衡"></a>破坏平衡</h5><p>在示例VAL搜索树上插入一个元素3，就会变成下面这样，破坏平衡：<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVL-LL1.png" alt=""></p>
<h5 id="态势感知"><a href="#态势感知" class="headerlink" title="态势感知"></a>态势感知</h5><p>被破坏了平衡首先要找到是哪个树被破坏了平衡，然后调整这个树。然后继续往上一个一个的调整。<br><br>既然是被新插入的节点3破坏的，那么不平衡的树一定在从新插入的节点3到根节点8的路径上。找离新插入的节点最近的不平衡的树进行调整，上图中就是7.<br><br>节点7的左子树 高度为1，右子树为空，高度为-1 ，不平衡<br></p>
<h5 id="确认方案"><a href="#确认方案" class="headerlink" title="确认方案"></a>确认方案</h5><p>根据表格要进行右单旋。</p>
<h5 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h5><ol>
<li>先把7这颗不平衡的树挑出来： </li>
</ol>
<p><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVL-LL2.png" alt=""><br>这棵树是最近的不平衡的树，7的左子树5高度为1，右子树为空，所以右子树高度是-1.两者的高度差达到了2，超过了1。<br></p>
<ol start="2">
<li>因为左子树5的高度更高，所以要把左子树5向上提一下，这时旋转就很明显了，抓着5向上一提，7就掉到5的右边了，成了5的右子树。<br><br>这个过程就是右旋： <br><br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVL-LL3.png" alt=""><br>这时继续往上找，发现每个节点都符合了平衡条件，所以整棵树就变成了AVL树。</li>
</ol>
<h5 id="旋转-移花接木"><a href="#旋转-移花接木" class="headerlink" title="旋转+移花接木"></a>旋转+移花接木</h5><p>如果节点5在插入前有右子树，照样右旋转，只要把原来5的右子树变成旋转后的7的左子树就行了。因为5的右子树肯定比5大，但是也肯定比7小的：<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVL-LL4.png" alt=""></p>
<p>其实上面最后旋转成的树是下面这样的：<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVL-LR2.png" alt=""><br>这棵树的根节点还是不平衡的，需要使用先左旋后右旋来调整。</p>
<p>使用LR先左旋后右旋调整后是这样的：<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVL-LR3.png" alt=""></p>
<h4 id="LR旋转"><a href="#LR旋转" class="headerlink" title="LR旋转"></a>LR旋转</h4><p><strong>LR插入</strong>：不平衡的<strong>制造者</strong>插入<strong>发现者</strong>的左子树的右子结点 -&gt; LR旋转<br>如果在第一个例子中插入的不是3，而是6，就成了下面的样子<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVL-LR1.png" alt=""><br>被破坏平衡的树依然是7，但是这次就不能通过一次旋转解决了，咋转都不行。</p>
<p>要从6开始到7进行先左旋再右旋才可以矫正平衡：<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVL-LR2.png" alt=""></p>
<h4 id="RR旋转-左单旋"><a href="#RR旋转-左单旋" class="headerlink" title="RR旋转(左单旋)"></a>RR旋转(左单旋)</h4><p><strong>RR插入</strong>:不平衡的<strong>制造者</strong>插入<strong>发现者</strong>的右子树的右子结点上 -&gt; RR旋转<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVLRRRoteteGif.gif" alt=""></p>
<p><strong>左单旋</strong>和<strong>右单旋</strong>类似，如下：<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVL-RR1.png" alt=""></p>
<h4 id="RL旋转"><a href="#RL旋转" class="headerlink" title="RL旋转"></a>RL旋转</h4><p><strong>LR插入</strong>：不平衡的<strong>制造者</strong>插入<strong>发现者</strong>的右子树的左子结点 -&gt; RL旋转<br>当破坏平衡的节点是这个树的右子树的左子树时，要进行先右旋转再左旋转来矫正。</p>
<p>同样是从破坏平衡的那个节点开始旋转，先右旋转后左旋转：<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-AVL-RL1.png" alt=""></p>
<h4 id="有时候插入元素后依旧是平衡搜索树，单需要重新计算一些平衡因子"><a href="#有时候插入元素后依旧是平衡搜索树，单需要重新计算一些平衡因子" class="headerlink" title="有时候插入元素后依旧是平衡搜索树，单需要重新计算一些平衡因子"></a>有时候插入元素后依旧是平衡搜索树，单需要重新计算一些平衡因子</h4><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">// 1.建立一个节点类</span><br><span class="line">private static class AVLNode&lt;E&gt;  &#123;</span><br><span class="line">    E element;</span><br><span class="line">    AVLNode&lt;E&gt; left;</span><br><span class="line">    AVLNode&lt;E&gt; right;</span><br><span class="line">    int height;</span><br><span class="line"></span><br><span class="line">    public AVLNode(E element) &#123;</span><br><span class="line">        this(element, null, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AVLNode(E element, AVLNode&lt;E&gt; left, AVLNode&lt;E&gt; right) &#123;</span><br><span class="line">        this.element = element;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.建立一个树类，包括插入方法insert()，删除方法remove()，求高度的方法height()</span><br><span class="line">public class MyAVLTree&lt;E extends Comparable&lt;E&gt;&gt; &#123;</span><br><span class="line">    private AVLNode root;</span><br><span class="line"></span><br><span class="line">    public MyAVLTree() &#123;</span><br><span class="line">        this.root = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insert(E x) &#123;</span><br><span class="line">        root = insert(x, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove(E x) &#123;</span><br><span class="line">        remove(x, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int height() &#123;</span><br><span class="line">        return height(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插入新数据</span><br><span class="line">     */</span><br><span class="line">    public AVLNode&lt;E&gt; insert(E x, AVLNode&lt;E&gt; t) &#123;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            return new AVLNode&lt;E&gt;(x);</span><br><span class="line">        &#125;</span><br><span class="line">        //先比较 是插左边还是插右边</span><br><span class="line">        int compareResult = x.compareTo(t.element);</span><br><span class="line">        if (compareResult &lt; 0) &#123;//插到左子树上</span><br><span class="line">            t.left = insert(x, t.left);</span><br><span class="line">            //插入之后要判断是否打破了平衡，因为插入的是左子树，</span><br><span class="line">            // 只有左子树才会打破平衡，用左子树的高减去右子树的高</span><br><span class="line">            if (height(t.left) - height(t.right) == 2) &#123;</span><br><span class="line">                //如果等于2，说明平衡被打破了，需要进行调整。就看选择什么方法调整</span><br><span class="line">                if (x.compareTo(t.left.element) &lt; 0) &#123;</span><br><span class="line">                    //如果x小于t的左子树的值，那么x会被插到t的左子树的左子树上，符合LL 用右旋转调整。</span><br><span class="line">                    t = rightRotate(t);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //如果x大于t的左子树的值，则会被插到t的左子树的右子树上，符合LR，用先左旋转后右旋转来矫正。</span><br><span class="line">                    t = leftAndRightRotate(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (compareResult &gt; 0) &#123;//插到右子树上，逻辑和上面一样。</span><br><span class="line">            t.right = insert(x, t.right);</span><br><span class="line">            if (height(t.right) - height(t.left) == 2) &#123;</span><br><span class="line">                if (x.compareTo(t.right.element) &gt; 0) &#123;</span><br><span class="line">                    t = leftRotate(t);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    t = rightAndLeftRotate(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //已经有这个值了</span><br><span class="line">        &#125;</span><br><span class="line">        t.height = Math.max(height(t.left), height(t.right)) + 1;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除数据</span><br><span class="line">     */</span><br><span class="line">    private AVLNode&lt;E&gt; remove(E x, AVLNode&lt;E&gt; t) &#123;</span><br><span class="line">        if (t == null)</span><br><span class="line">            return null;</span><br><span class="line">        int compareResult = x.compareTo(t.element);</span><br><span class="line">        if (compareResult &lt; 0) &#123;</span><br><span class="line">            t.left = remove(x, t.left);</span><br><span class="line">            //完了之后验证该子树是否平衡</span><br><span class="line">            if (t.right != null) &#123;        //若右子树为空，则一定是平衡的，此时左子树相当对父节点深度最多为1, 所以只考虑右子树非空情况</span><br><span class="line">                if (t.left == null) &#123;     //若左子树删除后为空，则需要判断右子树</span><br><span class="line">                    if (height(t.right) - t.height == 2) &#123;</span><br><span class="line">                        AVLNode&lt;E&gt; k = t.right;</span><br><span class="line">                        if (k.right != null) &#123;        //右子树存在，按正常情况单旋转</span><br><span class="line">                            t = leftRotate(t);</span><br><span class="line">                        &#125; else &#123;                      //否则是右左情况，双旋转</span><br><span class="line">                            t = rightAndLeftRotate(t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (t.left!=null)&#123;                  //否则判断左右子树的高度差</span><br><span class="line">                    //左子树自身也可能不平衡，故先平衡左子树，再考虑整体</span><br><span class="line">                    AVLNode&lt;E&gt; k = t.left;</span><br><span class="line">                    //删除操作默认用右子树上最小节点补删除的节点</span><br><span class="line">                    //k的左子树高度不低于k的右子树</span><br><span class="line">                    if (k.right != null) &#123;</span><br><span class="line">                        if (height(k.left) - height(k.right) == 2) &#123;</span><br><span class="line">                            AVLNode&lt;E&gt; m = k.left;</span><br><span class="line">                            if (m.left != null) &#123;     //左子树存在，按正常情况单旋转</span><br><span class="line">                                k = rightRotate(k);</span><br><span class="line">                            &#125; else &#123;                      //否则是左右情况，双旋转</span><br><span class="line">                                k = leftAndRightRotate(k);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (height(k.left) - k.height == 2) &#123;</span><br><span class="line">                            AVLNode&lt;E&gt; m = k.left;</span><br><span class="line">                            if (m.left != null) &#123;     //左子树存在，按正常情况单旋转</span><br><span class="line">                                k = rightRotate(k);</span><br><span class="line">                            &#125; else &#123;                      //否则是左右情况，双旋转</span><br><span class="line">                                k = leftAndRightRotate(k);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (height(t.right) - height(t.left) == 2) &#123;</span><br><span class="line">                        //右子树自身一定是平衡的，左右失衡的话单旋转可以解决问题</span><br><span class="line">                        t = leftRotate(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //完了之后更新height值</span><br><span class="line">            t.height = Math.max(height(t.left), height(t.right)) + 1;</span><br><span class="line">        &#125; else if (compareResult &gt; 0) &#123;</span><br><span class="line">            t.right = remove(x, t.right);</span><br><span class="line">            //下面验证子树是否平衡</span><br><span class="line">            if (t.left != null) &#123;         //若左子树为空，则一定是平衡的，此时右子树相当对父节点深度最多为1</span><br><span class="line">                t = balanceChild(t);</span><br><span class="line">            &#125;</span><br><span class="line">            //完了之后更新height值</span><br><span class="line">            t.height = Math.max(height(t.left), height(t.right)) + 1;</span><br><span class="line">        &#125; else if (t.left != null &amp;&amp; t.right != null) &#123;</span><br><span class="line">            //默认用其右子树的最小数据代替该节点的数据并递归的删除那个节点</span><br><span class="line">            AVLNode&lt;E&gt; min = t.right;</span><br><span class="line">            while (min.left != null) &#123;</span><br><span class="line">                min = min.left;</span><br><span class="line">            &#125;</span><br><span class="line">//            t.element = findMin(t.right).element;</span><br><span class="line">            t.element = min.element;</span><br><span class="line">            t.right = remove(t.element, t.right);</span><br><span class="line">            t = balanceChild(t);</span><br><span class="line">            //完了之后更新height值</span><br><span class="line">            t.height = Math.max(height(t.left), height(t.right)) + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            t = (t.left != null) ? t.left : t.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private AVLNode&lt;E&gt; balanceChild(AVLNode&lt;E&gt; t) &#123;</span><br><span class="line">        if (t.right == null) &#123;        //若右子树删除后为空，则只需判断左子树与根的高度差</span><br><span class="line">            if (height(t.left) - t.height == 2) &#123;</span><br><span class="line">                AVLNode&lt;E&gt; k = t.left;</span><br><span class="line">                if (k.left != null) &#123;</span><br><span class="line">                    t = rightRotate(t);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    t = leftAndRightRotate(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;              //若右子树删除后非空，则判断左右子树的高度差</span><br><span class="line">            //右子树自身也可能不平衡，故先平衡右子树，再考虑整体</span><br><span class="line">            AVLNode&lt;E&gt; k = t.right;</span><br><span class="line">            //删除操作默认用右子树上最小节点（靠左）补删除的节点</span><br><span class="line"></span><br><span class="line">            if (k.left != null) &#123;</span><br><span class="line">                if (height(k.right) - height(k.left) == 2) &#123;</span><br><span class="line">                    AVLNode&lt;E&gt; m = k.right;</span><br><span class="line">                    if (m.right != null) &#123;        //右子树存在，按正常情况单旋转</span><br><span class="line">                        k = leftRotate(k);</span><br><span class="line">                    &#125; else &#123;                      //否则是右左情况，双旋转</span><br><span class="line">                        k = rightAndLeftRotate(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (height(k.right) - k.height == 2) &#123;</span><br><span class="line">                    AVLNode&lt;E&gt; m = k.right;</span><br><span class="line">                    if (m.right != null) &#123;        //右子树存在，按正常情况单旋转</span><br><span class="line">                        k = leftRotate(k);</span><br><span class="line">                    &#125; else &#123;                      //否则是右左情况，双旋转</span><br><span class="line">                        k = rightAndLeftRotate(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //左子树自身一定是平衡的，左右失衡的话单旋转可以解决问题</span><br><span class="line">            if (height(t.left) - height(t.right) == 2) &#123;</span><br><span class="line">                t = rightRotate(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 右旋转</span><br><span class="line">     *</span><br><span class="line">     * @param t 需要调整的树</span><br><span class="line">     * @return 调整后的树</span><br><span class="line">     */</span><br><span class="line">    private AVLNode&lt;E&gt; rightRotate(AVLNode&lt;E&gt; t) &#123;</span><br><span class="line">        AVLNode newTree = t.left;</span><br><span class="line">        t.left = newTree.right;</span><br><span class="line">        newTree.right = t;</span><br><span class="line">        t.height = Math.max(height(t.left), height(t.right)) + 1;</span><br><span class="line">        newTree.height = Math.max(height(newTree.left), height(newTree.right)) + 1;</span><br><span class="line">        return newTree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 左旋转</span><br><span class="line">     */</span><br><span class="line">    private AVLNode&lt;E&gt; leftRotate(AVLNode t) &#123;</span><br><span class="line">        AVLNode&lt;E&gt; newTree = t.right;</span><br><span class="line">        t.right = newTree.left;</span><br><span class="line">        newTree.left = t;</span><br><span class="line">        t.height = Math.max(height(t.left), height(t.right)) + 1;</span><br><span class="line">        newTree.height = Math.max(height(newTree.left), height(newTree.right)) + 1;</span><br><span class="line">        return newTree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 先左旋后右旋</span><br><span class="line">     */</span><br><span class="line">    private AVLNode&lt;E&gt; leftAndRightRotate(AVLNode&lt;E&gt; t) &#123;</span><br><span class="line">        t.left = leftRotate(t.left);</span><br><span class="line">        return rightRotate(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 先右旋后左旋</span><br><span class="line">     */</span><br><span class="line">    private AVLNode&lt;E&gt; rightAndLeftRotate(AVLNode&lt;E&gt; t) &#123;</span><br><span class="line">        t.right = rightRotate(t.right);</span><br><span class="line">        return leftRotate(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定树的高度</span><br><span class="line">     */</span><br><span class="line">    private int height(AVLNode&lt;E&gt; t) &#123;</span><br><span class="line">        return t == null ? -1 : t.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printTree() &#123;</span><br><span class="line">        printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void printTree(AVLNode&lt;E&gt; tree) &#123;</span><br><span class="line">        if (tree == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(tree.element + &quot; &quot;);</span><br><span class="line">        printTree(tree.left);</span><br><span class="line">        printTree(tree.right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class AVLNode&lt;E&gt; &#123;</span><br><span class="line">        E element;</span><br><span class="line">        AVLNode&lt;E&gt; left;</span><br><span class="line">        AVLNode&lt;E&gt; right;</span><br><span class="line">        int height;</span><br><span class="line"></span><br><span class="line">        public AVLNode(E element) &#123;</span><br><span class="line">            this(element, null, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public AVLNode(E element, AVLNode&lt;E&gt; left, AVLNode&lt;E&gt; right) &#123;</span><br><span class="line">            this.element = element;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p>
<ul>
<li>1.堆中某个节点的值总是不大于或不小于其父节点的值；</li>
<li>2.堆是用数组表示的一棵完全二叉树。</li>
</ul>
<p>当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。(大顶堆的根结点是堆有序的二叉树中的最大结点。)</p>
<p><img src="http://qiniu.hayato.tech/markdownimages/algorithms-heap1.png" alt=""></p>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li>1.大顶堆（子节点永远小于父节点）</li>
<li>2.小顶堆（子节点永远大于父节点）<br>上图所示是一个大顶堆,我们可以使用一个数组来存储一个堆(通常从第1个元素开始，第0个元素一般用作哨兵)。<br><br><code>[ -, 90, 36, 17, 25, 26, 7, 1, 2, 3, 10 ]</code></li>
</ul>
<p>注意我们将数组下标为 0 的位置弃用了，根据图示我们不难得出结论：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个堆中，位置 k 的结点的父结点的位置为[ k / 2 ] ，而它的两个子结点的位置则分别是 2k 或者 2k+1 。</span><br></pre></td></tr></table></figure></p>
<h3 id="维护堆"><a href="#维护堆" class="headerlink" title="维护堆"></a>维护堆</h3><p>维护一个堆需要做两件事情：插入元素和删除最大元素</p>
<p>两个操作：</p>
<ul>
<li>由下至上的堆有序化（上浮）</li>
<li>由上至下的堆有序化（下沉）</li>
</ul>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>进队需要做的事情很简单，先将元素丢进队列尾，然后和父节点进行比较，比父节点大时则于其交换位置，比父节点小时则表示进队完成。<br></p>
<p>注：按定义，堆中每次都只能删除根节点数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。<br><img src="http://qiniu.hayato.tech/markdownimages/algorithms-heapInput1.gif" alt=""></p>
<h3 id="删除最大元素"><a href="#删除最大元素" class="headerlink" title="删除最大元素"></a>删除最大元素</h3><p>出队如图所示，只需要将队列头位置的元素取出（下标为 1 的元素），然后将队列尾的元素填充到队列头，接下来和子节点较大者对换位置，直至比子节点的元素都要大时结束交换位置。<br><img src="http://qiniu.hayato.tech/markdownimages/algorithms-headOutput1.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ElementType DeleteMax( MaxHeap H )</span><br><span class="line">&#123; /* 从最大堆H中取出键值为最大的元素，并删除一个结点 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType MaxItem, temp;</span><br><span class="line">    if ( IsEmpty(H) ) &#123;</span><br><span class="line">        printf(&quot;最大堆已为空&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">     MaxItem = H-&gt;Elements[1]; /* 取出根结点最大值 */</span><br><span class="line">    /* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span><br><span class="line">    temp = H-&gt;Elements[H-&gt;Size--];</span><br><span class="line">    for( Parent=1; Parent*2&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2;</span><br><span class="line">        if((Child!= H-&gt;Size) &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child+1])) &#123;</span><br><span class="line">            Child++; /* Child指向左右子结点的较大者 */</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if( temp &gt;= H-&gt;Elements[Child] ) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;/* 移动temp元素到下一层 */</span><br><span class="line">            H-&gt;Elements[Parent] = H-&gt;Elements[Child];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[Parent] = temp;</span><br><span class="line">    return MaxItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆的建立"><a href="#堆的建立" class="headerlink" title="堆的建立"></a>堆的建立</h3><p>建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中<br><br>方法：</p>
<ol>
<li>通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为O(N logN)。</li>
<li>在线性时间复杂度下建立最大堆。<blockquote>
<p>1.将N个元素按输入顺序存入，先满足完全二叉树的结构特性<br>2.调整各结点位置，以满足最大堆的有序特性。</p>
</blockquote>
</li>
</ol>
<p>技巧：<br>完全二叉树完成后需要排序，从最后一个结点的父结点开始排序</p>
<h2 id="哈夫曼树-最优二叉树"><a href="#哈夫曼树-最优二叉树" class="headerlink" title="哈夫曼树(最优二叉树)"></a>哈夫曼树(最优二叉树)</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>带权路径长度(WPL)：二叉树有n个叶子结点，每个叶子结点带有权值W，从根结点到每个叶子结点的长度为L，则每个叶子结点的带权路径长度之和就是：WPL = W1<em>L1 + W2</em>L2 + … Wn*Ln。<br><br>哈夫曼树即为WPL最小的树</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>选出两棵权值最小的二叉树，组成一棵新的二叉树，其权值为这两棵二叉树的权值之和。该和加入到集合中，重复执行上述操作<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-HuffmanTree1.png" alt=""><br>则按照以上步骤，可以构造出如下面左图所示的赫夫曼树<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-HuffmanTree2.png" alt=""><br>当然也可能构造出如下面右图所示的赫夫曼树，这并不是唯一的<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-HuffmanTree3.png" alt=""></p>
<p>注意：可以构造出不同的哈夫曼树，但是WPL是相同的</p>
<p>整体复杂度为O(N logN)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef struct TreeNode *HuffmanTree;</span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int Weight;</span><br><span class="line">    HuffmanTree Left, Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuffmanTree Huffman( MinHeap H )</span><br><span class="line">&#123; /* 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里 */</span><br><span class="line">    int i; HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H); /*将H-&gt;Elements[]按权值调整为最小堆*/</span><br><span class="line">    for (i = 1; i &lt; H-&gt;Size; i++) &#123; /*做H-&gt;Size-1次合并*/</span><br><span class="line">        T = malloc( sizeof( struct TreeNode) ); /*建立新结点*/</span><br><span class="line">        T-&gt;Left = DeleteMin(H);</span><br><span class="line">         /*从最小堆中删除一个结点，作为新T的左子结点*/</span><br><span class="line">        T-&gt;Right = DeleteMin(H);</span><br><span class="line">         /*从最小堆中删除一个结点，作为新T的右子结点*/</span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;</span><br><span class="line">        /*计算新权值*/</span><br><span class="line">        Insert( H, T ); /*将新T插入最小堆*/</span><br><span class="line">    &#125;</span><br><span class="line">    T = DeleteMin(H);</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h3><ul>
<li>没有度为1的结点</li>
<li>n个叶子结点的哈夫曼树共有2n-1个结点</li>
<li>哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树</li>
<li>对同一组数据，可能构造出不止一种哈夫曼树，但是WPL相同</li>
</ul>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><ul>
<li>避免二义性 -&gt; 不出现前缀码(不能存在父结点)</li>
<li>效率高 -&gt; 哈夫曼树</li>
</ul>
<p>对每个字符设计长度不等的编码，让电文中出现较多的字符采用尽可能短的编码</p>
<p><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-HuffmanCode.png" alt=""></p>
<p> 左分支编码为字符0，右分支编码为字符1，将从根节点到叶子节点的路径上分支字符组成的字符串作为叶子节点字符的编码，这便是赫夫曼编码。</p>
<p>上图各叶子节点的赫夫曼编码如下：</p>
<blockquote>
<p>权值为5的也自己节点的赫夫曼编码为：00<br><br>权值为4的也自己节点的赫夫曼编码为：01<br><br>权值为3的也自己节点的赫夫曼编码为：10<br><br>权值为2的也自己节点的赫夫曼编码为：110<br><br>权值为1的也自己节点的赫夫曼编码为：111<br></p>
</blockquote>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>表示<strong>多对多</strong>的关系</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>一组定点：通常用V(Vertex)表示顶点集合</li>
<li>一组边：通常用E(Edge)表示边的集合<blockquote>
<p>边是顶点对：(v,w) ∈ <strong>E</strong>,其中v,w ∈ <strong>V</strong> V — W<br>有向边&lt;v,w&gt;表示从v指向w的边(单行线）    V –&gt; W<br>不考虑重边和自回路</p>
</blockquote>
</li>
</ul>
<h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>类型名称：图（Graph)</li>
<li>数据对象集：G(V,E)由一个非空的有限顶点集合v和一个有限边集合E组成</li>
<li>操作集：对于任意图G ∈ Graph,以及v ∈ V，e ∈ E<blockquote>
<p>Graph Create():建立并返回空图;<br><br>Graph InsertVertex(Graph G, Vertex v):将v插入G;<br><br>Graph InsertEdge(Graph G, Edge e):将e插入G;<br><br>void DFS(Graph G, Vertex v):从顶点v出发深度优先遍历图G;<br><br>void BFS(Graph G, Vertex v):从顶点v出发宽度优先遍历图G;<br><br>void ShortestPath(Graph G, Vertex v, int Dist[]):计 算图G中顶点v到任意其他顶点的最短距离;<br><br>void MST(Graph G):计算图G的最小生成树;</p>
</blockquote>
</li>
</ul>
<h2 id="程序表示"><a href="#程序表示" class="headerlink" title="程序表示"></a>程序表示</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-Graph-AdjacencyMatrix.png" alt=""></p>
<h4 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h4><ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有“邻接点”(有边直接相连的顶点）</li>
<li>方便计算任一顶点的“度”(从该点发出的边数为“出 度”，指向该点的边数为“入度”)<blockquote>
<p>无向图:对应行(或列)非0元素的个数<br><br>有向图:对应行非0元素的个数是“出度”;对应列非0元素的 个数是“入度”</p>
</blockquote>
</li>
</ul>
<h4 id="改善-针对无向图节省一半空间"><a href="#改善-针对无向图节省一半空间" class="headerlink" title="改善 - 针对无向图节省一半空间"></a>改善 - 针对无向图节省一半空间</h4><p>用一个长度为N(N+1)/2的1维数组A存储 {G00,G10,G11,……,Gn-1 0,…,Gn-1 n-1}， 则Gij在A中对应的下标是:<br>(i*(i+1)/2 + j)</p>
<p>对于网络，只要把G[i][j]的值定义为边&lt; v<sub>i</sub> ,v<sub>j</sub> &gt;的权重即可</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/* 图的邻接矩阵表示法（C语言实现） */</span><br><span class="line">#define  MaxVertexNum  100      /* 最大顶点数设为100 */</span><br><span class="line">#define  INFINITY  65535     /* ∞设为双字节无符号整数的最大值65535*/</span><br><span class="line">typedef  char  VertexType;      /* 顶点类型设为字符型 */</span><br><span class="line">typedef  int  EdgeType;         /* 边的权值设为整型 */</span><br><span class="line">enum GraphType &#123; DG, UG, DN, UN &#125;;  </span><br><span class="line">/* 有向图,无向图,有向网图,无向网图*/</span><br><span class="line">  </span><br><span class="line">typedef  struct &#123;</span><br><span class="line">    VertexType  Vertices[ MaxVertexNum ];  /* 顶点表 */</span><br><span class="line">    EdgeType  Edges[ MaxVertexNum ][ MaxVertexNum ]; </span><br><span class="line">/* 邻接矩阵，即边表  */</span><br><span class="line">    int  n, e;   /* 顶点数n和边数e */</span><br><span class="line">    enum GraphType GType;   /* 图的类型分4种：UG、DG、UN、DN */</span><br><span class="line">&#125; MGraph;    /* MGragh是以邻接矩阵存储的图类型 */</span><br><span class="line">  </span><br><span class="line">void  CreateMGraph ( MGraph *G )</span><br><span class="line">&#123;  </span><br><span class="line">    int  i, j, k, w;</span><br><span class="line">    G-&gt; GType = UN;    /* Undirected Network  无向网图  */</span><br><span class="line">    printf( &quot;请输入顶点数和边数(输入格式为:顶点数, 边数):\n&quot; );</span><br><span class="line">    scanf( &quot;%d, %d&quot;,&amp;(G-&gt;n), &amp;(G-&gt;e) ); /* 输入顶点数和边数 */</span><br><span class="line">    printf(&quot;请输入顶点信息(输入格式为:顶点号&lt;CR&gt;):\n&quot;);</span><br><span class="line">    for ( i = 0; i &lt; G-&gt;n; i++ ) </span><br><span class="line">       scanf( &quot;%c&quot;,&amp;(G-&gt; Vertices[i]) ); /*  输入顶点信息，建立顶点表  */</span><br><span class="line">    for ( i = 0; i &lt; G-&gt;n; i++ )</span><br><span class="line">       for ( j = 0; j &lt; G-&gt;n; j++ )  </span><br><span class="line">           G-&gt;Edges[i][j] = INFINITY; /* 初始化邻接矩阵 */</span><br><span class="line">    printf( &quot;请输入每条边对应的两个顶点的序号和权值，输入格式为:i, j, w:\n&quot; );</span><br><span class="line">    for ( k = 0; k &lt; G-&gt;e; k++ ) &#123;</span><br><span class="line">       scanf(&quot;%d,%d,%d &quot;,&amp;i, &amp;j, &amp;w); /* 输入e条边上的权，建立邻接矩阵 */</span><br><span class="line">       G-&gt;Edges[i][j] = w; </span><br><span class="line">       G-&gt;Edges[j][i] = w; /* 因为无向网图的邻接矩阵是对称的 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>G[N]为指针数组，对应矩阵每行一个链表， 只存非0元素。<br>对于网络，结构中要增加权重的域<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-Graph-AdjacencyList.png" alt=""></p>
<h4 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h4><ul>
<li>方便找任一顶点的所有“邻接点”</li>
<li>节约稀疏图的空间<blockquote>
<p>需要N个头指针 + 2E个结点(每个结点至少2个域)</p>
</blockquote>
</li>
<li>方便计算任一顶点的“度”?<blockquote>
<p>对无向图:是的<br><br>对有向图:只能计算“出度”;需要构造“逆邻接表”(存指向自己 的边)来方便计算“入度”</p>
</blockquote>
</li>
<li>不方便检查任意一对顶点间是否存在边</li>
</ul>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* 图的邻接表表示法（C语言实现） */</span><br><span class="line">#define  MaxVertexNum  100     /* 最大顶点数为100 */</span><br><span class="line">enum GraphType &#123; DG, UG, DN, UN &#125;; </span><br><span class="line">/* 有向图,无向图,有向网图,无向网图*/</span><br><span class="line">typedef  struct  node&#123;   /* 边表结点 */</span><br><span class="line">    int AdjV;            /* 邻接点域 */</span><br><span class="line">    struct  node  *Next;  /* 指向下一个邻接点的指针域 */</span><br><span class="line">    /* 若要表示边上的权值信息，则应增加一个数据域Weight */</span><br><span class="line">&#125; EdgeNode;</span><br><span class="line">typedef  char  VertexType;   /* 顶点用字符表示 */</span><br><span class="line">typedef  struct  Vnode&#123;      /* 顶点表结点 */</span><br><span class="line">    VertexType  Vertex;      /* 顶点域 */</span><br><span class="line">    EdgeNode  *FirstEdge; /* 边表头指针 */</span><br><span class="line">&#125; VertexNode; </span><br><span class="line">typedef VertexNode AdjList[ MaxVertexNum ]; /* AdjList是邻接表类型 */</span><br><span class="line">typedef  struct&#123;  </span><br><span class="line">    AdjList  adjlist;    /* 邻接表 */</span><br><span class="line">    int  n, e;               /* 顶点数和边数 */</span><br><span class="line">    enum GraphType GType;    /* 图的类型分4种：UG、DG、UN、DN */</span><br><span class="line">&#125; ALGraph;  /*ALGraph是以邻接表方式存储的图类型 */</span><br><span class="line">  </span><br><span class="line">void CreateALGraph( ALGraph *G )</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    EdgeNode *edge;</span><br><span class="line">    G-&gt; GType = DG;  /* Directed Graph  有向图  */</span><br><span class="line">    printf( &quot;请输入顶点数和边数(输入格式为:顶点数,边数)：\n&quot; );</span><br><span class="line">    scanf( &quot;%d,%d&quot;, &amp;(G-&gt;n), &amp;(G-&gt;e) ); /* 读入顶点数和边数 */ </span><br><span class="line">    printf( &quot;请输入顶点信息(输入格式为:顶点号&lt;CR&gt;)：\n&quot; );</span><br><span class="line">    for ( i=0; i &lt; G-&gt;n; i++ ) &#123;   /* 建立有n个顶点的顶点表 */</span><br><span class="line">        scanf( &quot; %c&quot;, &amp;(G-&gt;adjlist[i].Vertex) );  /* 读入顶点信息 */</span><br><span class="line">       G-&gt;adjlist[i].FirstEdge = NULL; /* 顶点的边表头指针设为空 */</span><br><span class="line">    &#125;</span><br><span class="line">    printf( &quot;请输入边的信息(输入格式为: i, j &lt;CR&gt;)：\n&quot; );</span><br><span class="line">    for ( k=0; k &lt; G-&gt;e; k++ )&#123;   /* 建立边表 */</span><br><span class="line">       scanf( &quot;\n%d,%d&quot;, &amp;i, &amp;j); /* 读入边&lt;vi,vj&gt;的顶点对应序号*/</span><br><span class="line">       edge = (EdgeNode*)malloc(sizeof(EdgeNode)); /* 生成新边结点edge */</span><br><span class="line">       edge-&gt;AdjV = j; /* 邻接点序号为j */</span><br><span class="line">       edge-&gt;Next = G-&gt;adjlist[i].FirstEdge;</span><br><span class="line">       /* 将新边表结点edge插入到顶点vi的边表头部 */</span><br><span class="line">       G-&gt;adjlist[i].FirstEdge = edge;</span><br><span class="line">       /* 若是无向图，还要生成一个结点，用来表示边&lt; vj, vi&gt;  */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="深度优先搜索-Depth-First-Search-DFS"><a href="#深度优先搜索-Depth-First-Search-DFS" class="headerlink" title="深度优先搜索(Depth First Search, DFS)"></a>深度优先搜索(Depth First Search, DFS)</h3><p>ps:类似于树的先序遍历<br>路径特点：原路返回<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-Graph-DFS-order.png" alt=""></p>
<p><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-Graph-DFS-animation.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void DFS ( Vertex V ) &#123; </span><br><span class="line">    visited[ V ] = true;</span><br><span class="line">    for ( V 的每个邻接点 W ) &#123;</span><br><span class="line">        if ( !visited[ W ] )</span><br><span class="line">    &#125;</span><br><span class="line">    DFS( W ); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索-Breadth-First-Search-BFS"><a href="#广度优先搜索-Breadth-First-Search-BFS" class="headerlink" title="广度优先搜索(Breadth First Search, BFS)"></a>广度优先搜索(Breadth First Search, BFS)</h3><p>ps：类似于树中的层序遍历<br>路径特带：辐射</p>
<p><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-Graph-DFS-order.png" alt=""></p>
<p><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-Graph-BFS-animation.gif" alt=""></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 邻接表存储的图 – DFS（C语言实现） */</span><br><span class="line">/* Visited[]为全局变量，已经初始化为FALSE */</span><br><span class="line">void  DFS( ALGraph *G,  int i )</span><br><span class="line">&#123;   /* 以Vi为出发点对邻接表存储的图G进行DFS搜索 */</span><br><span class="line">    EdgeNode *W;</span><br><span class="line">    printf( &quot;visit vertex: %c\n&quot;, G-&gt;adjlist[i].Vertex );</span><br><span class="line">    /* 相当于访问顶点Vi */</span><br><span class="line">    Visited[i] = TRUE;   /* 标记Vi已访问 */</span><br><span class="line">    for( W = G-&gt;adjlist[i].FirstEdge;  W;  W = W-&gt;Next ) </span><br><span class="line">       if ( !Visited[ W-&gt;AdjV ] )</span><br><span class="line">           DFS( G, W-&gt;AdjV );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* 邻接矩阵存储的图 – BFS（C语言实现） */</span><br><span class="line">void  BFS ( MGraph G )</span><br><span class="line">&#123;   /* 按广度优先遍历图G。使用辅助队列Q和访问标志数组Visited */</span><br><span class="line">    Queue  *Q;    </span><br><span class="line">    VertexType  U, V, W;</span><br><span class="line">    for ( U = 0; U &lt; G.n; ++U )  </span><br><span class="line">       Visited[U] = FALSE;</span><br><span class="line">    Q = CreatQueue( MaxSize ); /* 创建空队列Q */</span><br><span class="line">    for ( U = 0; U&lt;G.n; ++U )</span><br><span class="line">       if ( !Visited[U] ) &#123; /* 若U尚未访问 */</span><br><span class="line">           Visited[U] = TRUE; </span><br><span class="line">           printf( &quot;visit vertex: %c\n&quot;, G.Vertices[U] );</span><br><span class="line">           /* 相当于访问顶点U */</span><br><span class="line">           AddQ (Q, U);    /* U入队列 */</span><br><span class="line">           while ( ! IsEmptyQ(Q) ) &#123;</span><br><span class="line">              V = DeleteQ( Q );  /*  队头元素出队并置为V */</span><br><span class="line">              for( W = FirstAdjV(G, V);  W;  W = NextAdjV(G, V, W) )</span><br><span class="line">                  if ( !Visited[W] ) &#123;</span><br><span class="line">                     Visited[W] = TRUE;</span><br><span class="line">                     printf( &quot;visit vertex: %c\n&quot;, G.Vertices[W] );</span><br><span class="line">                     /* 相当于访问顶点W */</span><br><span class="line">                     AddQ (Q, W);</span><br><span class="line">                  &#125;</span><br><span class="line">           &#125; /* while结束*/</span><br><span class="line">    &#125; /* 结束从U开始的BFS */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度与搜索方式无关，只与存储方式有关，搜索方式只影响搜索路径。</p>
<p>若有N个顶点、E条边，时间复杂度是：</p>
<ul>
<li>用邻接表存储图，有O(N+E)</li>
<li>用邻接矩阵存储图，有O(N 2 )</li>
</ul>
<h2 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h2><ul>
<li>连通：如果从V到W存在一条（无向）路径，则称 V和W是连通的</li>
<li>路径：V到W的路径是一系列顶点{V, v<sub>1</sub>, v<sub>2</sub>, …, v<sub>n</sub>, W}的集合，其中任一对相邻的顶点间都有图中的边。<strong>路径的长度</strong>是路径中的边数（如果带权，则是所有边的权重和）。如果V到W之间的所有顶点都不同(没有回路)，则称简单路径</li>
<li>回路：起点等于终点的路径</li>
<li>连通图：图中任意两顶点均连通</li>
<li>连通分量：无向图的最大连通子图<blockquote>
<p>最大顶点数：再加1个顶点就不连通了<br><br>最大边数：包含子图中所有顶点相连的所有边</p>
</blockquote>
</li>
<li>强连通：有向图中顶点V和W之间存在双向路径，则称V和W是强连通的</li>
<li>强连通图：有向图中任意两顶点均强连通</li>
<li>强连通分量：有向图的最大强连通子图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void ListComponents ( Graph G ) </span><br><span class="line">&#123; </span><br><span class="line">    for ( each V in G ) &#123;</span><br><span class="line">        if ( !visited[V] ) &#123;</span><br><span class="line">            DFS( V ); /*or BFS( V )*/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用范例"><a href="#应用范例" class="headerlink" title="应用范例"></a>应用范例</h2><h3 id="拯救007"><a href="#拯救007" class="headerlink" title="拯救007"></a>拯救007</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void ListComponents ( Graph G ) &#123; </span><br><span class="line">    for ( each V in G ) &#123;</span><br><span class="line">        if ( !visited[V] ) &#123;</span><br><span class="line">            DFS( V );</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Save007 ( Graph G ) &#123; </span><br><span class="line">    for ( each V in G ) &#123;</span><br><span class="line">        if (!visited[V] &amp;&amp; FirstJump(V)) &#123; </span><br><span class="line">            answer = DFS( V ); </span><br><span class="line">            if (answer==YES) break; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    if (answer==YES) output(“Yes”); </span><br><span class="line">    else output(“No”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6度空间理论"><a href="#6度空间理论" class="headerlink" title="6度空间理论"></a>6度空间理论</h3><p>算法思路：</p>
<ul>
<li>对每个结点，进行广度优先搜索</li>
<li>搜索过程中累积访问的结点数</li>
<li>记录层数，限定在6层以内</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void SDS() </span><br><span class="line">&#123; </span><br><span class="line">    for ( each V in G ) &#123; </span><br><span class="line">    count = BFS(V); Output(count/N); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int BFS ( Vertex V )</span><br><span class="line">&#123;</span><br><span class="line">    visited[V] = true; </span><br><span class="line">    count = 1;</span><br><span class="line">    level = 0; </span><br><span class="line">    last = V; </span><br><span class="line">    tail = V;</span><br><span class="line">    Enqueue(V, Q);</span><br><span class="line">    while(!IsEmpty(Q))&#123; </span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        for ( V 的每个邻接点 W ) &#123;</span><br><span class="line">            if ( !visited[W] ) &#123;</span><br><span class="line">                visited[W] = true;</span><br><span class="line">                Enqueue(W, Q); count++;</span><br><span class="line">                tail = W;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ( V == last ) &#123; </span><br><span class="line">            level++; last = tail; </span><br><span class="line">            &#125; </span><br><span class="line">        if ( level == 6 ) break;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据中序结果-前序结果-直接计算-后序"><a href="#根据中序结果-前序结果-直接计算-后序" class="headerlink" title="根据中序结果 + 前序结果 直接计算 后序"></a>根据中序结果 + 前序结果 直接计算 后序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void solve( int preL, int inL, int postL, int n ) </span><br><span class="line">&#123; </span><br><span class="line">    if (n==0) return; </span><br><span class="line">    if (n==1) &#123;</span><br><span class="line">        post[postL] = pre[preL]; </span><br><span class="line">        return;</span><br><span class="line">    &#125; </span><br><span class="line">    root = pre[preL];</span><br><span class="line">    post[postL+n-1] = root; </span><br><span class="line">    for (i=0; i&lt;n; i++) &#123;</span><br><span class="line">        if (in[inL+i] == root) </span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    L = i; R = n-L-1;</span><br><span class="line">    solve(preL+1, inL, postL, L); </span><br><span class="line">    solve(preL+L+1, inL+L+1, postL+L, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入一组数据-求-完全二叉搜索树-层序输出结果"><a href="#输入一组数据-求-完全二叉搜索树-层序输出结果" class="headerlink" title="输入一组数据 求 完全二叉搜索树 层序输出结果"></a>输入一组数据 求 完全二叉搜索树 层序输出结果</h2><p>输入： 1 2 3 4 5 6 7 8 9 0</p>
<p>输出： 6 3 8 1 5 7 9 0 2 4<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-BinTree-completeTree.png" alt=""></p>
<ul>
<li><p>数组表示</p>
<blockquote>
<p>排列 == 层序遍历<br>对于非完全二叉树，浪费空间</p>
</blockquote>
</li>
<li><p>链表</p>
<blockquote>
<p>节省空间<br>需要操作指针</p>
</blockquote>
</li>
</ul>
<p>思路：<br>对于一个有序的一组树，可以根据完全二叉树的特征确认root及左右子树的集合，递归即可得出完全二叉树的分布</p>
<h3 id="如何计算左子树的规模"><a href="#如何计算左子树的规模" class="headerlink" title="如何计算左子树的规模"></a>如何计算左子树的规模</h3><p>H为树的高度，H<sub>root</sub> = 1;</p>
<p>则有：</p>
<ul>
<li>完美二叉树节点总数 = 2<sup>H</sup> - 1</li>
<li>对于完全二叉树需要考虑最下非满层的叶结点X<blockquote>
<p>完全二叉树节点数 N = 2<sup>H</sup> - 1 + X<br><br>可以推导出 H = log<sub>2</sub> (N+1）</p>
</blockquote>
</li>
</ul>
<p>有效X = MIN(X,2<sup>H - 1</sup>),超过2<sup>H - 1</sup>的部分在右子树上</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ALeft &amp;&amp; ARight分别表示输入排序后数组的起始和终止</span><br><span class="line">// T表示输出结果数组</span><br><span class="line">void solve( int ALeft, int ARight, int TRoot ) </span><br><span class="line">&#123; /* 初始调用为 solve(0, N-1, 0) */</span><br><span class="line">    n = ARight – ALeft + 1; </span><br><span class="line">    if (n==0) return; </span><br><span class="line">    L = GetLeftLength(n); /* 计算出n个结点的树其左子树有多少个结点 */ </span><br><span class="line">    T[TRoot] = A[ALeft + L]; </span><br><span class="line">    LeftTRoot = TRoot * 2 + 1; </span><br><span class="line">    RightTRoot = LeftTRoot + 1; </span><br><span class="line">    solve(ALeft, ALeft+L-1, LeftTRoot); </span><br><span class="line">    solve(ALeft+L+1, ARight, RightTRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h3 id="抽象问题"><a href="#抽象问题" class="headerlink" title="抽象问题"></a>抽象问题</h3><p>在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径</p>
<ul>
<li>这条路径就是两点之间的最短路径（Shortest Path）</li>
<li>第一个顶点为源点（Source）</li>
<li>最后一个顶点为终点（Destination）</li>
</ul>
<h3 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h3><p><strong>单源</strong>最短路径问题：从某固定源点出发，求其 到所有其他顶点的最短路径</p>
<ul>
<li>（有向）无权图 </li>
<li>（有向）有权图</li>
</ul>
<p><strong>多源</strong>最短路径问题：求任意两顶点间的最短路径</p>
<h3 id="无权图的单源最短路算法"><a href="#无权图的单源最短路算法" class="headerlink" title="无权图的单源最短路算法"></a>无权图的单源最短路算法</h3><p>类似图的BFS算法<br>T = O( |V| + |E| )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// dist[W] = S到W的最短距离 </span><br><span class="line">// dist[S] = 0 </span><br><span class="line">// path[W] = S到W的路上经过的某顶点</span><br><span class="line">void Unweighted ( Vertex S ) </span><br><span class="line">&#123; </span><br><span class="line">    Enqueue(S, Q);</span><br><span class="line">    while(!IsEmpty(Q))&#123; </span><br><span class="line">        V = Dequeue(Q); </span><br><span class="line">        for ( V 的每个邻接点 W ) &#123;</span><br><span class="line">            if ( dist[W]==-1 ) &#123; </span><br><span class="line">                dist[W] = dist[V]+1; </span><br><span class="line">                path[W] = V; </span><br><span class="line">                Enqueue(W, Q); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="有权图的单源最短路算法-Dijkstra-算法"><a href="#有权图的单源最短路算法-Dijkstra-算法" class="headerlink" title="有权图的单源最短路算法 Dijkstra 算法"></a>有权图的单源最短路算法 Dijkstra 算法</h3><p>有权图最短路径算法<strong>不能有负值圈</strong>，即不能有权重为负的环形路径，否则可以不断重复无边界)</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>令S={源点s + 已经确定了最短路径的顶点v<sub>i</sub> }</li>
<li>对任一未收录的顶点v，定义dist[v]为s到v的最 短路径长度，但该路径仅经过S中的顶点。即路径 {s -&gt; (v<sub>i</sub> ∈ S) -&gt; v}的最小长度</li>
<li>若路径是按照递增（非递减）的顺序生成的，则<blockquote>
<p>真正的最短路必须只经过S中的顶点<br><br>每次从未收录的顶点中选一个dist最小的收录（贪心算法）<br><br>增加一个v进入S，可能影响另外一个w的dist值！(dist[w] = min{dist[w], dist[v] + &lt;v,w&gt;的权重})</p>
</blockquote>
</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra( Vertex s ) </span><br><span class="line">&#123;</span><br><span class="line">    while (1) </span><br><span class="line">    &#123;</span><br><span class="line">        V = 未收录顶点中dist最小者;</span><br><span class="line">        if ( 这样的V不存在 ) break;</span><br><span class="line">        </span><br><span class="line">        collected[V] = true;</span><br><span class="line">        for ( V 的每个邻接点 W ) &#123;</span><br><span class="line">            if ( collected[W] == false ) &#123;</span><br><span class="line">                if ( dist[V]+E&lt;V,W&gt; &lt; dist[W] &#123; </span><br><span class="line">                    dist[W] = dist[V] + E&lt;V,W&gt; ;   </span><br><span class="line">                    path[W] = V; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; /* 不能解决有负边的情况 */</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>直接扫描所有未收录顶点 &gt; T = O( |V| 2 + |E| ) &gt; 稠密图效果好</li>
<li>将dist存在最小堆中 &gt; T = O( |E| log|V| ) &gt; 稀疏图效果好</li>
</ul>
<h3 id="多源最短路算法-Floyd算法"><a href="#多源最短路算法-Floyd算法" class="headerlink" title="多源最短路算法 Floyd算法"></a>多源最短路算法 Floyd算法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul>
<li>D<sup>k</sup>[i][j] = 路径{ i -&gt; { l &lt;= k } -&gt; j }的最小长度</li>
<li>D<sup>0</sup>, D<sup>1</sup>, …, D<sup>|V|-1</sup> [i][j]即给出了i到j的真正最短距离</li>
<li>当D<sup>k-1</sup>已经完成，递推到D<sup>0k</sup>时：<blockquote>
<p>或者k ∉ 最短路径{ i -&gt; { l &lt;= k } -&gt; j }，则D<sup>k</sup> = D<sup>k-1</sup><br><br>或者k ∈ 最短路径{ i -&gt; { l &lt;= k } -&gt; j }，则<strong>该路径必定由两段最短路径组成</strong>： D<sup>k</sup>[i][j]=D<sup>k-1</sup>[i][k]+D<sup>k-1</sup> [k][j]</p>
</blockquote>
</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Floyd() &#123; </span><br><span class="line">    for ( i = 0; i &lt; N; i++ ) &#123;</span><br><span class="line">        for( j = 0; j &lt; N; j++ ) &#123;</span><br><span class="line">            D[i][j] = G[i][j];</span><br><span class="line">            path[i][j] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for( k = 0; k &lt; N; k++ ) &#123;</span><br><span class="line">        for( i = 0; i &lt; N; i++ ) &#123;</span><br><span class="line">            for( j = 0; j &lt; N; j++ ) &#123;</span><br><span class="line">                if( D[i][k] + D[k][j] &lt; D[i][j] ) &#123;</span><br><span class="line">                    D[i][j] = D[i][k] + D[k][j]; </span><br><span class="line">                    path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>T = O(|V|<sup>3</sup>)</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><ul>
<li>是一颗树<blockquote>
<p>无回路(环)<br>|V|个顶点一定有|V|-1条边</p>
</blockquote>
</li>
<li>是生成树<blockquote>
<p>包含全部顶点<br>|V|-1条边都在图里</p>
</blockquote>
</li>
<li>边的权重和最小</li>
</ul>
<h3 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h3><ul>
<li>最小生成树存在的图肯定是连通的图</li>
<li>向生成树中任加一条边都一定构成回路</li>
</ul>
<h3 id="Prim算法-让一颗小树长大"><a href="#Prim算法-让一颗小树长大" class="headerlink" title="Prim算法 - 让一颗小树长大"></a>Prim算法 - 让一颗小树长大</h3><p>T = O(|V|<sup>2</sup>) -&gt; 稠密图合算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void Prim()</span><br><span class="line">&#123; </span><br><span class="line">    MST = &#123;s&#125;;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        V = 未收录顶点中dist最小者;</span><br><span class="line">        if ( 这样的V不存在 ) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        将V收录进MST: dist[V] = 0;</span><br><span class="line">        for ( V 的每个邻接点 W ) &#123;</span><br><span class="line">            if ( dist[W]!= 0 ) &#123;</span><br><span class="line">                if ( E(V,W) &lt; dist[W] ) &#123;</span><br><span class="line">                    dist[W] = E(V,W) ;</span><br><span class="line">                    parent[W] = V;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( MST中收的顶点不到|V|个 )</span><br><span class="line">    Error ( “生成树不存在” );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Kruskal算法-将森林合并成树"><a href="#Kruskal算法-将森林合并成树" class="headerlink" title="Kruskal算法 - 将森林合并成树"></a>Kruskal算法 - 将森林合并成树</h3><p>T = O( |E| log |E| )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Kruskal ( Graph G )</span><br><span class="line">&#123; </span><br><span class="line">    MST = &#123; &#125; ;</span><br><span class="line">    while ( MST 中不到 |V| - 1 条边 &amp;&amp; E 中还有边 ) &#123;</span><br><span class="line">        从 E 中取一条权重最小的边 E(v,w) ;// 最小堆</span><br><span class="line">        将 E(v,w)从 E 中删除;</span><br><span class="line">        if ( E(V,W)不在 MST 中构成回路) &#123;// 并查集</span><br><span class="line">            将 E(V,W) 加入 MST;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            彻底无视 E(V,W);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( MST 中不到 |V| - 1 条边 ) &#123;</span><br><span class="line">        Error ( “生成树不存在” );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul>
<li>拓扑序：如果图中从V到W有一条有向路径，<br>则V一定排在W之前。满足此条件的顶点序列<br>称为一个拓扑序</li>
<li>获得一个拓扑序的过程就是拓扑排序</li>
<li>AOV如果有合理的拓扑序，则必定是有向无环<br>图（Directed Acyclic Graph, DAG）</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>T = O( |V| + |E| )</p>
<p>可以用来检测有向图是否DAG<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 将入度变为0的顶点放到一个容器里</span><br><span class="line">void TopSort()</span><br><span class="line">&#123; </span><br><span class="line">    for ( 图中每个顶点 V )</span><br><span class="line">        if ( Indegree[V]==0 ) &#123;</span><br><span class="line">            Enqueue( V, Q );</span><br><span class="line">        &#125;</span><br><span class="line">    while ( !IsEmpty(Q) ) &#123;</span><br><span class="line">        V = Dequeue( Q );</span><br><span class="line">        输出V，或者记录V的输出序号; cnt++;</span><br><span class="line">        for ( V 的每个邻接点 W ) &#123;</span><br><span class="line">            if ( ––Indegree[W]==0 ) &#123;</span><br><span class="line">                Enqueue( W, Q );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( cnt != |V| )</span><br><span class="line">    Error( “图中有回路” );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="关键路径问题"><a href="#关键路径问题" class="headerlink" title="关键路径问题"></a>关键路径问题</h2><p>AOE (Activity On Edge) 网络，一般用于安排项目的工序<br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-Graph-AOE-struct.png" alt=""><br><img src="http://qiniu.hayato.tech/markdownimages/Algorithms-Graph-AOE-time.png" alt=""></p>
<h2 id="路线规划问题"><a href="#路线规划问题" class="headerlink" title="路线规划问题"></a>路线规划问题</h2><ul>
<li>城市为节点</li>
<li>公路为边<blockquote>
<p>权重1:距离<br>权重2:收费</p>
</blockquote>
</li>
<li>单源最短路<blockquote>
<p>Dijkstra - 距离<br>等距离时按收费更新</p>
</blockquote>
</li>
</ul>
<h3 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra( Vertex s )</span><br><span class="line">&#123; </span><br><span class="line">    while (1) &#123;</span><br><span class="line">        V = 未收录顶点中dist最小者;</span><br><span class="line">        if ( 这样的V不存在 ) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        collected[V] = true;</span><br><span class="line">        for ( V 的每个邻接点 W ) &#123;</span><br><span class="line">            if ( collected[W] == false ) &#123;</span><br><span class="line">                if ( dist[V]+E&lt;V,W&gt; &lt; dist[W] ) &#123;</span><br><span class="line">                    dist[W] = dist[V] + E&lt;V,W&gt; ;</span><br><span class="line">                    path[W] = V;</span><br><span class="line">                    cost[W] = cost[V] + C&lt;V,W&gt; ;</span><br><span class="line">                &#125; else if ( (dist[V]+E&lt;V,W&gt; == dist[W])</span><br><span class="line">&amp;&amp; (cost[V]+C&lt;V,W&gt; &lt; cost[W]) ) &#123;</span><br><span class="line">                    cost[W] = cost[V] + C&lt;V,W&gt; ;</span><br><span class="line">                    path[W] = V;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他类似问题"><a href="#其他类似问题" class="headerlink" title="其他类似问题"></a>其他类似问题</h3><ul>
<li>要求数最短路径有多少条<blockquote>
<p>count[s] = 1<br><br>如果找到更短路：count[W]=count[V]<br><br>如果找到等长路：count[W]+=count[V]<br></p>
</blockquote>
</li>
<li>要求边数最少的最短路<blockquote>
<p>count[s] = 0<br><br>如果找到更短路：count[W]=count[V]+1<br><br>如果找到等长路：count[W]=count[V]+1<br></p>
</blockquote>
</li>
</ul>
<h1 id="散列表-哈希表"><a href="#散列表-哈希表" class="headerlink" title="散列表(哈希表)"></a>散列表(哈希表)</h1><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>符号表：SymbolTable</p>
<p>数据对象集:符号表是”名字(Name)-属性(Attibute)”对的集合</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><ol>
<li>以关键字key为自变量，通过一个确定的哈希函数hash，计算出对应的函数值hash(key)作为数据对象的存储地址</li>
<li>需要冲突解决策略：不同的key可能哈希映射到一个哈希地址上，即hash(key1) == hash(key2)(key1 ≠ key2)称为冲突(Collision)</li>
</ol>
<p>装填因子（Loading Factor）：设散列表空间大小为m，填入表<br>中元素个数是n，则称α＝ n / m为散列表的装填因子</p>
<h2 id="操作集"><a href="#操作集" class="headerlink" title="操作集"></a>操作集</h2><p>Table ∈ SymbolTable, Name ∈ NameType, Arrt ∈ ArrtibuteType<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建一个长度为TableSize的符号表</span><br><span class="line">SymbolTable InitializeTable( int TableSize )：</span><br><span class="line">// 2.查找特定的名字Name是否在符号表Table中</span><br><span class="line">Boolean IsIn( SymbolTable Table, NameType Name)：</span><br><span class="line">// 3.获取Table中指定名字Name对应的属性</span><br><span class="line">AttributeType Find( SymbolTable Table, NameType Name)：</span><br><span class="line">// 4.将Table中指定名字Name的属性修改为Attr</span><br><span class="line">SymbolTable Modefy(SymbolTable Table, NameType Name, AttributeType Attr)：</span><br><span class="line">// 5.向Table中插入一个新名字Name及其属性Attr</span><br><span class="line">SymbolTable Insert(SymbolTable Table, NameType Name, AttributeType Attr)：</span><br><span class="line">// 6.从Table中删除一个名字Name及其属性</span><br><span class="line">SymbolTable Delete(SymbolTable Table, NameType Name)：</span><br></pre></td></tr></table></figure></p>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><h3 id="2个重要指标"><a href="#2个重要指标" class="headerlink" title="2个重要指标"></a>2个重要指标</h3><ol>
<li>足够简单：访问频率高，以便提高转换速度</li>
<li>Key对应的地址空间分布均匀，以尽量减少冲突</li>
</ol>
<h3 id="常用数字key散列函数"><a href="#常用数字key散列函数" class="headerlink" title="常用数字key散列函数"></a>常用数字key散列函数</h3><ol>
<li>直接定址法 hash(key) = a * key + b (a、b为常数）</li>
<li>除留余数法： hash(key) = key % p (p为素数, p = Tablesize）</li>
<li>数字分析法： hash(key) = atoi(key + 7) 分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址</li>
<li>折叠法：把关键词分割成位数相同的几个部分，然后叠加</li>
<li>平方取中法</li>
</ol>
<h3 id="常用字符key散列函数"><a href="#常用字符key散列函数" class="headerlink" title="常用字符key散列函数"></a>常用字符key散列函数</h3><p>位移法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Index hash(const char *key, int tableSize) </span><br><span class="line">&#123;</span><br><span class="line">    unsigned int h = 0;// 散列函数值，初始化为0</span><br><span class="line">    while (*key != ‘\0’) &#123;// 位移映射</span><br><span class="line">        h = (h &lt;&lt; 5) + *key==;</span><br><span class="line">    &#125;</span><br><span class="line">    return h % tableSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h2><h3 id="开放地址法-Open-Addressing"><a href="#开放地址法-Open-Addressing" class="headerlink" title="开放地址法 Open Addressing"></a>开放地址法 Open Addressing</h3><p>一旦产生冲突(该地址已有其他元素)，就按某种规则去寻找另一空地址；</p>
<p>若发生了第 i 次冲突，试探的下一个地址将增加di，基本公式是：<br>hash<sub>i</sub>(key) = (hash(key) + d<sub>i</sub>) % tableSize (1 ≤ i &lt; tableSize)(d<sub>i</sub> 决定了不同的解决冲突方案：线性探测d<sub>i</sub> = i、平方探测d<sub>i</sub> = ± i<sup>2</sup>、双散列d<sub>i</sub> = i * hash<sub>2</sub>(key))</p>
<p>注意：在开放地址散列表中，删除操作要很小心。通常只能“懒惰删除”，即需要增加一个“删除标记(Deleted)”，而并不是真正删除它。以便查找时不会“断链”。其空间可以在下次插入时重用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/*开放地址法*/</span><br><span class="line">#define tablesize 10//定义hash表的长度</span><br><span class="line"> </span><br><span class="line">typedef int  HashTable[10];</span><br><span class="line">typedef int  KeyType;</span><br><span class="line"> </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">//Search</span><br><span class="line">int Search_HashTable(HashTable ht, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">	int address = key % tablesize;</span><br><span class="line">	int comparetimer = 0; //aviod the loop of death. </span><br><span class="line"> </span><br><span class="line">	while(comparetimer &lt; tablesize &amp;&amp; ht[address] != key &amp;&amp; ht[address] != -1)</span><br><span class="line">	&#123;</span><br><span class="line">		comparetimer ++; </span><br><span class="line">		address = (address + 1) % tablesize;  // *****sequence probing. *****</span><br><span class="line">	&#125;</span><br><span class="line">	if(comparetimer == tablesize)</span><br><span class="line">		return -1;</span><br><span class="line">	return address;   // no match if ht[address] = -1.</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//Insert</span><br><span class="line">int Insert_HashTable(HashTable ht, KeyType key)</span><br><span class="line">&#123;</span><br><span class="line">	int address;</span><br><span class="line">	address = Search_HashTable(ht, key);</span><br><span class="line">	if(ht[address] == -1)</span><br><span class="line">	&#123;</span><br><span class="line">		ht[address] = key;</span><br><span class="line">		return 1; //insert success.</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		return -1;  //the key has been insert into the hashtable yet,or the HashTable is full.</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//initialization</span><br><span class="line">void Initial_HashTable(HashTable ht)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i = 0; i &lt; tablesize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ht[i] = -1;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线性探测法-Linear-Probing"><a href="#线性探测法-Linear-Probing" class="headerlink" title="线性探测法(Linear Probing)"></a>线性探测法(Linear Probing)</h4><h4 id="平方探测法（Quadratic-Probing"><a href="#平方探测法（Quadratic-Probing" class="headerlink" title="平方探测法（Quadratic Probing)"></a>平方探测法（Quadratic Probing)</h4><p>如果散列表长度TableSize是某个4k+3（k是正整数）形式的素数时，平方探测法就可以探查到整个散列表空间。</p>
<h4 id="双散列探测法"><a href="#双散列探测法" class="headerlink" title="双散列探测法"></a>双散列探测法</h4><h4 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h4><ul>
<li>当散列表元素太多(即装填因子α太大）时，查找效率会下降<blockquote>
<p>实用最大装填因子一般取 0.5 &lt;= α&lt;= 0.85</p>
</blockquote>
</li>
<li>当装填因子过大时，解决的方法是加倍扩大散列表，这个过程叫<br>做“再散列（Rehashing）”</li>
</ul>
<h3 id="分离链接法（Separate-Chaining）"><a href="#分离链接法（Separate-Chaining）" class="headerlink" title="分离链接法（Separate Chaining）"></a>分离链接法（Separate Chaining）</h3><p>分离链接法：将相应位置上冲突的所有关键词存储在同一个单链表中<br><img src="http://qiniu.hayato.tech/markdownimages/Algrothms-hashTable-SeparateChaining.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode;</span><br><span class="line">typedef struct ListNode *Position, *List;</span><br><span class="line">struct HashTbl;</span><br><span class="line">typedef struct HashTbl *HashTable; </span><br><span class="line">struct ListNode</span><br><span class="line">&#123;</span><br><span class="line">    ElementType Element;</span><br><span class="line">    Position Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Position Find( ElementType Key, HashTable H ) </span><br><span class="line">&#123;</span><br><span class="line">    Position P;</span><br><span class="line">    List L;</span><br><span class="line">    L = &amp;( H-&gt;TheLists[ Hash( Key, H-&gt;TableSize ) ] );</span><br><span class="line">    P = L-&gt;Next;</span><br><span class="line">    while（ P != NULL &amp;&amp; strcmp(P-&gt;Element, Key)） &#123;</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    return P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/* 链地址法*/</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">#define tablesize 5</span><br><span class="line">typedef int ElemType;  </span><br><span class="line">typedef struct HashNode  </span><br><span class="line">&#123;  </span><br><span class="line">	ElemType elem; // 记录key值，出现冲突时确定结点</span><br><span class="line">	struct HashNode *next;  </span><br><span class="line">&#125;HashNode;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">typedef struct  </span><br><span class="line">&#123;  </span><br><span class="line">	HashNode ChainHash[tablesize];  </span><br><span class="line">	int  count;  </span><br><span class="line">&#125;HashTable;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int hash_mod(ElemType key)  </span><br><span class="line">&#123;  </span><br><span class="line">	return key % tablesize;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void InsertHash(HashTable *h, int key)  </span><br><span class="line">&#123;  </span><br><span class="line">	HashNode *p;  </span><br><span class="line">	int index;  </span><br><span class="line">	p = (HashNode*)malloc(sizeof(HashNode));  </span><br><span class="line">	p-&gt;elem = key;  </span><br><span class="line">	index = hash_mod(key);  </span><br><span class="line">	p-&gt;next = h-&gt;ChainHash[index].next;  </span><br><span class="line">	h-&gt;ChainHash[index].next = p;  </span><br><span class="line">	h-&gt;count++;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void CreateHashTable(HashTable *h, int n)  </span><br><span class="line">&#123;  </span><br><span class="line">	int key;  </span><br><span class="line">	int i;  </span><br><span class="line">	for(i = 0; i &lt; n; i++)  </span><br><span class="line">	&#123;  </span><br><span class="line">		printf(&quot;Input the  %d key :&quot;, i+1);  </span><br><span class="line">		scanf_s(&quot;%d&quot;, &amp;key);  </span><br><span class="line">		InsertHash(h, key);  </span><br><span class="line">	&#125;	</span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void PrintHashTable(HashTable *h)  </span><br><span class="line">&#123;  </span><br><span class="line">	int i;  </span><br><span class="line">	HashNode *p;  </span><br><span class="line">	for(i = 0;i &lt;= tablesize; i++)  </span><br><span class="line">	&#123;  </span><br><span class="line">		p = h-&gt;ChainHash[i].next;  </span><br><span class="line">		while(p)  </span><br><span class="line">		&#123;  </span><br><span class="line">			printf(&quot;%-5d&quot;, p-&gt;elem);  </span><br><span class="line">			p = p-&gt;next;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int SearchHash(HashTable *h, int key)  </span><br><span class="line">&#123;  </span><br><span class="line">	HashNode *p;  </span><br><span class="line">	int index;  </span><br><span class="line">	int counter = 0;  </span><br><span class="line">	index = hash_mod(key);  </span><br><span class="line">	p = h-&gt;ChainHash[index].next;  </span><br><span class="line">	while(p)  </span><br><span class="line">	&#123;  </span><br><span class="line">		if(p-&gt;elem == key)  </span><br><span class="line">			return 1;  </span><br><span class="line">		else   </span><br><span class="line">			p = p-&gt;next;  </span><br><span class="line">	&#125;  </span><br><span class="line">	return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>平均查找长度(ASL）用来度量散列表查找效率：成功、不成功</li>
<li>关键词的比价次数，取决于产生冲突的多少,影响产生冲突多少有以下三个因素：<blockquote>
<p>1.散列函数是否均匀<br>2.处理冲突的方法<br>3.散列表的装填因子α</p>
</blockquote>
</li>
</ul>
<p>装填因子（Loading Factor）：设散列表空间大小为m，填入表<br>中元素个数是n，则称α＝ n / m为散列表的装填因子</p>
<p><img src="http://qiniu.hayato.tech/markdownimages/Algrothms-performance-suitable.png" alt=""></p>
<h3 id="线性探测法的查找性能"><a href="#线性探测法的查找性能" class="headerlink" title="线性探测法的查找性能"></a>线性探测法的查找性能</h3><p><img src="http://qiniu.hayato.tech/markdownimages/Algrothms-performance-liner.png" alt=""></p>
<p>当α= 0.5时，</p>
<ul>
<li>插入操作和不成功查找的期望 ASLu = 0.5*(1+1/(1-0.5)<sup>2</sup><br>) = 2.5 次</li>
<li>成功查找的期望 ASLs = 0.5*(1+1/(1-0.5)） = 1.5次</li>
</ul>
<h3 id="平方探测法和双散列探测法的查找性能"><a href="#平方探测法和双散列探测法的查找性能" class="headerlink" title="平方探测法和双散列探测法的查找性能"></a>平方探测法和双散列探测法的查找性能</h3><p><img src="http://qiniu.hayato.tech/markdownimages/Algrothms-performance-QuadraticProbing.png" alt=""></p>
<p>当α= 0.5时，</p>
<ul>
<li>插入操作和不成功查找的期望 ASLu = 1/(1-0.5) = 2 次</li>
<li>成功查找的期望 ASLs = -1/0.5 * ln(1-0.5) ≈ 1.39 次</li>
</ul>
<h3 id="分离链接法的查找性能"><a href="#分离链接法的查找性能" class="headerlink" title="分离链接法的查找性能"></a>分离链接法的查找性能</h3><p>所有地址链表的平均长度定义成装填因子α，α有可能超过1。<br>不难证明：其期望探测次数 p为：<br><img src="http://qiniu.hayato.tech/markdownimages/Algrothms-performance-Separate.png" alt=""><br>当α = 1时，</p>
<ul>
<li>插入操作和不成功查找的期望 ASLu = 1+e<sup>-1</sup> = 1.37 次，</li>
<li>成功查找的期望 ASLs = 1+1/2 = 1.5 次。</li>
</ul>
<p>👍选择合适的散列函数，散列法的查找效率期望是常数O(1),它几乎与关键字的空间大小n无关！也适合于关键字直接比较计算量大的问题<br><br>👉它是以较小的α为前提。因此，散列方法是一个以空间换时间<br><br>👎散列方法的存储对关键字是随机的，不便于顺序查找关键字，也不适合于范围查找，或最大值最小值查找<br></p>
<h3 id="开放地址法和分离链法在性能对比的优劣"><a href="#开放地址法和分离链法在性能对比的优劣" class="headerlink" title="开放地址法和分离链法在性能对比的优劣"></a>开放地址法和分离链法在性能对比的优劣</h3><h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><p>👍散列表是一个数组，存储效率高，随机查找<br><br>👎散列表有“聚集”现象<br></p>
<h4 id="分离链法"><a href="#分离链法" class="headerlink" title="分离链法"></a>分离链法</h4><p>👍关键字删除不需要“懒惰删除”法，从而没有存储“垃圾”<br><br>👉散列表是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低<br><br>👎太小的α可能导致空间浪费，大的α又将付出更多的时间代价。不均匀的链表长度导致时间效率的严重下降<br></p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者: <a href="https://haojiaqiang.github.io">Hayato</a>
            <p>原文链接: <a href="https://haojiaqiang.github.io/2016/09/30/Algorithms/">https://haojiaqiang.github.io/2016/09/30/Algorithms/</a>
            <p>发表日期: <a href="https://haojiaqiang.github.io/2016/09/30/Algorithms/">September 30th 2016, 2:08:23 pm</a>
            <p>版权声明: <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC-SA 4.0</a></p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2016/11/20/Design-Pattern-Odyssey/" title= 大话设计模式 >
                    <div class="nextTitle">大话设计模式</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2016/09/30/操作系统原理/" title= 操作系统原理 >
                    <div class="prevTitle">操作系统原理</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!--PC和WAP自适应版-->

    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
    
        
            
                <a href="https://github.com/haojiaqiang" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="https://about.me/haojiaqiang" class="iconfont-archer others" target="_blank" title=others></a>
            
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#部分算法实现动态效果"><span class="toc-number">1.</span> <span class="toc-text">部分算法实现动态效果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础"><span class="toc-number">2.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二分查找"><span class="toc-number">2.1.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据抽象"><span class="toc-number">2.2.</span> <span class="toc-text">数据抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">2.2.1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#背包、队列和栈"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">背包、队列和栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加减乘除-括号的最基本算法实现"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">加减乘除+括号的最基本算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链表"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串对象"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">字符串对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#子字符串"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">子字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#算法增长数量级表"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">算法增长数量级表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不成熟的优化时所有罪恶之源-–-快速排序发明人Knuth"><span class="toc-number">2.2.1.7.</span> <span class="toc-text">不成熟的优化时所有罪恶之源 – 快速排序发明人Knuth</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-number">2.3.</span> <span class="toc-text">树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序"><span class="toc-number">3.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#各种排序方式的对比"><span class="toc-number">3.1.</span> <span class="toc-text">各种排序方式的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#空间复杂度"><span class="toc-number">3.1.1.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最快的排序算法是桶排序"><span class="toc-number">3.1.2.</span> <span class="toc-text">最快的排序算法是桶排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#冒泡排序"><span class="toc-number">3.2.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现方式"><span class="toc-number">3.2.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">3.2.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例"><span class="toc-number">3.2.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择排序-在剩下的元素中找到最小的元素"><span class="toc-number">3.3.</span> <span class="toc-text">选择排序(在剩下的元素中找到最小的元素)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现方式-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-1"><span class="toc-number">3.3.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直接插入排序"><span class="toc-number">3.4.</span> <span class="toc-text">直接插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现方式-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点-2"><span class="toc-number">3.4.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-2"><span class="toc-number">3.4.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#希尔排序"><span class="toc-number">3.5.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点-3"><span class="toc-number">3.5.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-3"><span class="toc-number">3.5.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归并排序"><span class="toc-number">3.6.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义"><span class="toc-number">3.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现方式-3"><span class="toc-number">3.6.2.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#递归法（Top-down）"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">递归法（Top-down）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代法（Bottom-up）"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">迭代法（Bottom-up）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点-4"><span class="toc-number">3.6.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-4"><span class="toc-number">3.6.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速排序-划分交换排序"><span class="toc-number">3.7.</span> <span class="toc-text">快速排序(划分交换排序)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现方式-4"><span class="toc-number">3.7.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点-5"><span class="toc-number">3.7.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-5"><span class="toc-number">3.7.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆排序"><span class="toc-number">3.8.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先队列"><span class="toc-number">3.9.</span> <span class="toc-text">优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意"><span class="toc-number">3.9.1.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表排序"><span class="toc-number">3.10.</span> <span class="toc-text">表排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#桶排序-Bucket-sort"><span class="toc-number">3.11.</span> <span class="toc-text">桶排序(Bucket sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基数排序"><span class="toc-number">3.12.</span> <span class="toc-text">基数排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#查找"><span class="toc-number">4.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#树-1"><span class="toc-number">4.1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点-6"><span class="toc-number">4.1.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#种类"><span class="toc-number">4.1.3.</span> <span class="toc-text">种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储"><span class="toc-number">4.1.4.</span> <span class="toc-text">存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序存储结构"><span class="toc-number">4.1.5.</span> <span class="toc-text">顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#父节点表示法"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">父节点表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#存储结构"><span class="toc-number">4.1.5.1.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#基本操作"><span class="toc-number">4.1.5.1.2.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#构造空树"><span class="toc-number">4.1.5.1.3.</span> <span class="toc-text">构造空树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#构造树"><span class="toc-number">4.1.5.1.4.</span> <span class="toc-text">构造树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#判断树是否为空"><span class="toc-number">4.1.5.1.5.</span> <span class="toc-text">判断树是否为空</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取树的深度"><span class="toc-number">4.1.5.1.6.</span> <span class="toc-text">获取树的深度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取根节点"><span class="toc-number">4.1.5.1.7.</span> <span class="toc-text">获取根节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取第i个节点的值"><span class="toc-number">4.1.5.1.8.</span> <span class="toc-text">获取第i个节点的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#改变节点的值"><span class="toc-number">4.1.5.1.9.</span> <span class="toc-text">改变节点的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取节点的父节点"><span class="toc-number">4.1.5.1.10.</span> <span class="toc-text">获取节点的父节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取节点的最左孩子节点"><span class="toc-number">4.1.5.1.11.</span> <span class="toc-text">获取节点的最左孩子节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取节点的右兄弟节点"><span class="toc-number">4.1.5.1.12.</span> <span class="toc-text">获取节点的右兄弟节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#输出树"><span class="toc-number">4.1.5.1.13.</span> <span class="toc-text">输出树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#向树中插入另一棵树"><span class="toc-number">4.1.5.1.14.</span> <span class="toc-text">向树中插入另一棵树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除子树"><span class="toc-number">4.1.5.1.15.</span> <span class="toc-text">删除子树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#层序遍历树"><span class="toc-number">4.1.5.1.16.</span> <span class="toc-text">层序遍历树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#孩子链表表示法"><span class="toc-number">4.1.5.1.17.</span> <span class="toc-text">孩子链表表示法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树"><span class="toc-number">4.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-2"><span class="toc-number">4.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树和树的根本区别"><span class="toc-number">4.2.2.</span> <span class="toc-text">二叉树和树的根本区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的特性"><span class="toc-number">4.2.3.</span> <span class="toc-text">二叉树的特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树的遍历"><span class="toc-number">4.3.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#意义"><span class="toc-number">4.3.1.</span> <span class="toc-text">意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分类"><span class="toc-number">4.3.2.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#先序遍历"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中序遍历"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后序遍历"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#层次遍历"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">层次遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的非递归遍历-使用栈"><span class="toc-number">4.3.3.</span> <span class="toc-text">二叉树的非递归遍历(使用栈)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遍历二叉树的应用"><span class="toc-number">4.4.</span> <span class="toc-text">遍历二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#输出二叉树中的叶子结点"><span class="toc-number">4.4.1.</span> <span class="toc-text">输出二叉树中的叶子结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算二叉树的高度"><span class="toc-number">4.4.2.</span> <span class="toc-text">计算二叉树的高度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二元运算表达树"><span class="toc-number">4.4.3.</span> <span class="toc-text">二元运算表达树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#由两种序列遍历结果确定二叉树"><span class="toc-number">4.4.4.</span> <span class="toc-text">由两种序列遍历结果确定二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#结论"><span class="toc-number">4.4.4.1.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原因"><span class="toc-number">4.4.4.2.</span> <span class="toc-text">原因</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉查找树"><span class="toc-number">4.5.</span> <span class="toc-text">二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-3"><span class="toc-number">4.5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉搜索树查找指定值"><span class="toc-number">4.5.2.</span> <span class="toc-text">二叉搜索树查找指定值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉搜索树查找最小值"><span class="toc-number">4.5.3.</span> <span class="toc-text">二叉搜索树查找最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉搜索树查找最大值"><span class="toc-number">4.5.4.</span> <span class="toc-text">二叉搜索树查找最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉搜索树插入元素"><span class="toc-number">4.5.5.</span> <span class="toc-text">二叉搜索树插入元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉搜索树删除结点"><span class="toc-number">4.5.6.</span> <span class="toc-text">二叉搜索树删除结点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#平衡二叉查找树-AVL树"><span class="toc-number">4.6.</span> <span class="toc-text">平衡二叉查找树 AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-4"><span class="toc-number">4.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度"><span class="toc-number">4.6.2.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#平衡二叉树的调整-旋转"><span class="toc-number">4.6.3.</span> <span class="toc-text">平衡二叉树的调整-旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LL旋转-右单旋）"><span class="toc-number">4.6.3.1.</span> <span class="toc-text">LL旋转(右单旋）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#破坏平衡"><span class="toc-number">4.6.3.1.1.</span> <span class="toc-text">破坏平衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#态势感知"><span class="toc-number">4.6.3.1.2.</span> <span class="toc-text">态势感知</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#确认方案"><span class="toc-number">4.6.3.1.3.</span> <span class="toc-text">确认方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#旋转"><span class="toc-number">4.6.3.1.4.</span> <span class="toc-text">旋转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#旋转-移花接木"><span class="toc-number">4.6.3.1.5.</span> <span class="toc-text">旋转+移花接木</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR旋转"><span class="toc-number">4.6.3.2.</span> <span class="toc-text">LR旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RR旋转-左单旋"><span class="toc-number">4.6.3.3.</span> <span class="toc-text">RR旋转(左单旋)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RL旋转"><span class="toc-number">4.6.3.4.</span> <span class="toc-text">RL旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有时候插入元素后依旧是平衡搜索树，单需要重新计算一些平衡因子"><span class="toc-number">4.6.3.5.</span> <span class="toc-text">有时候插入元素后依旧是平衡搜索树，单需要重新计算一些平衡因子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现"><span class="toc-number">4.6.3.6.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆"><span class="toc-number">4.7.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#本质"><span class="toc-number">4.7.1.</span> <span class="toc-text">本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分类-1"><span class="toc-number">4.7.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#维护堆"><span class="toc-number">4.7.3.</span> <span class="toc-text">维护堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入元素"><span class="toc-number">4.7.4.</span> <span class="toc-text">插入元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除最大元素"><span class="toc-number">4.7.5.</span> <span class="toc-text">删除最大元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆的建立"><span class="toc-number">4.7.6.</span> <span class="toc-text">堆的建立</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈夫曼树-最优二叉树"><span class="toc-number">4.8.</span> <span class="toc-text">哈夫曼树(最优二叉树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-5"><span class="toc-number">4.8.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造"><span class="toc-number">4.8.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点-7"><span class="toc-number">4.8.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈夫曼编码"><span class="toc-number">4.8.4.</span> <span class="toc-text">哈夫曼编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图"><span class="toc-number">5.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-6"><span class="toc-number">5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组成"><span class="toc-number">5.2.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型-1"><span class="toc-number">5.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序表示"><span class="toc-number">5.4.</span> <span class="toc-text">程序表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接矩阵"><span class="toc-number">5.4.1.</span> <span class="toc-text">邻接矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点-8"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#改善-针对无向图节省一半空间"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">改善 - 针对无向图节省一半空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-1"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接表"><span class="toc-number">5.4.2.</span> <span class="toc-text">邻接表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点-9"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-2"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遍历"><span class="toc-number">5.5.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#深度优先搜索-Depth-First-Search-DFS"><span class="toc-number">5.5.1.</span> <span class="toc-text">深度优先搜索(Depth First Search, DFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#广度优先搜索-Breadth-First-Search-BFS"><span class="toc-number">5.5.2.</span> <span class="toc-text">广度优先搜索(Breadth First Search, BFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-3"><span class="toc-number">5.5.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度-1"><span class="toc-number">5.5.4.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连通性"><span class="toc-number">5.6.</span> <span class="toc-text">连通性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用范例"><span class="toc-number">5.7.</span> <span class="toc-text">应用范例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拯救007"><span class="toc-number">5.7.1.</span> <span class="toc-text">拯救007</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6度空间理论"><span class="toc-number">5.7.2.</span> <span class="toc-text">6度空间理论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#根据中序结果-前序结果-直接计算-后序"><span class="toc-number">5.8.</span> <span class="toc-text">根据中序结果 + 前序结果 直接计算 后序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入一组数据-求-完全二叉搜索树-层序输出结果"><span class="toc-number">5.9.</span> <span class="toc-text">输入一组数据 求 完全二叉搜索树 层序输出结果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何计算左子树的规模"><span class="toc-number">5.9.1.</span> <span class="toc-text">如何计算左子树的规模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-4"><span class="toc-number">5.9.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最短路径问题"><span class="toc-number">5.10.</span> <span class="toc-text">最短路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象问题"><span class="toc-number">5.10.1.</span> <span class="toc-text">抽象问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题分类"><span class="toc-number">5.10.2.</span> <span class="toc-text">问题分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无权图的单源最短路算法"><span class="toc-number">5.10.3.</span> <span class="toc-text">无权图的单源最短路算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有权图的单源最短路算法-Dijkstra-算法"><span class="toc-number">5.10.4.</span> <span class="toc-text">有权图的单源最短路算法 Dijkstra 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路"><span class="toc-number">5.10.4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码"><span class="toc-number">5.10.4.2.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度-2"><span class="toc-number">5.10.4.3.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多源最短路算法-Floyd算法"><span class="toc-number">5.10.5.</span> <span class="toc-text">多源最短路算法 Floyd算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路-1"><span class="toc-number">5.10.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码-1"><span class="toc-number">5.10.5.2.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度-3"><span class="toc-number">5.10.5.3.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最小生成树"><span class="toc-number">5.11.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点-10"><span class="toc-number">5.11.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim算法-让一颗小树长大"><span class="toc-number">5.11.2.</span> <span class="toc-text">Prim算法 - 让一颗小树长大</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal算法-将森林合并成树"><span class="toc-number">5.11.3.</span> <span class="toc-text">Kruskal算法 - 将森林合并成树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拓扑排序"><span class="toc-number">5.12.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法"><span class="toc-number">5.12.1.</span> <span class="toc-text">算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键路径问题"><span class="toc-number">5.13.</span> <span class="toc-text">关键路径问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#路线规划问题"><span class="toc-number">5.14.</span> <span class="toc-text">路线规划问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#核心算法"><span class="toc-number">5.14.1.</span> <span class="toc-text">核心算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他类似问题"><span class="toc-number">5.14.2.</span> <span class="toc-text">其他类似问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#散列表-哈希表"><span class="toc-number">6.</span> <span class="toc-text">散列表(哈希表)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-7"><span class="toc-number">6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本思路"><span class="toc-number">6.2.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作集"><span class="toc-number">6.3.</span> <span class="toc-text">操作集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#散列函数"><span class="toc-number">6.4.</span> <span class="toc-text">散列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2个重要指标"><span class="toc-number">6.4.1.</span> <span class="toc-text">2个重要指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用数字key散列函数"><span class="toc-number">6.4.2.</span> <span class="toc-text">常用数字key散列函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用字符key散列函数"><span class="toc-number">6.4.3.</span> <span class="toc-text">常用字符key散列函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理冲突"><span class="toc-number">6.5.</span> <span class="toc-text">处理冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#开放地址法-Open-Addressing"><span class="toc-number">6.5.1.</span> <span class="toc-text">开放地址法 Open Addressing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线性探测法-Linear-Probing"><span class="toc-number">6.5.1.1.</span> <span class="toc-text">线性探测法(Linear Probing)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#平方探测法（Quadratic-Probing"><span class="toc-number">6.5.1.2.</span> <span class="toc-text">平方探测法（Quadratic Probing)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双散列探测法"><span class="toc-number">6.5.1.3.</span> <span class="toc-text">双散列探测法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#再散列"><span class="toc-number">6.5.1.4.</span> <span class="toc-text">再散列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分离链接法（Separate-Chaining）"><span class="toc-number">6.5.2.</span> <span class="toc-text">分离链接法（Separate Chaining）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能分析"><span class="toc-number">6.6.</span> <span class="toc-text">性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线性探测法的查找性能"><span class="toc-number">6.6.1.</span> <span class="toc-text">线性探测法的查找性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#平方探测法和双散列探测法的查找性能"><span class="toc-number">6.6.2.</span> <span class="toc-text">平方探测法和双散列探测法的查找性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分离链接法的查找性能"><span class="toc-number">6.6.3.</span> <span class="toc-text">分离链接法的查找性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开放地址法和分离链法在性能对比的优劣"><span class="toc-number">6.6.4.</span> <span class="toc-text">开放地址法和分离链法在性能对比的优劣</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#开放地址法"><span class="toc-number">6.6.4.1.</span> <span class="toc-text">开放地址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分离链法"><span class="toc-number">6.6.4.2.</span> <span class="toc-text">分离链法</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 20
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/19</span><a class="archive-post-title" href= "/2020/11/19/网游加速器原理/" >网游加速器原理、技术与实现</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/30</span><a class="archive-post-title" href= "/2017/11/30/关于死锁的几个经典问题/" >关于死锁的几个经典问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/03</span><a class="archive-post-title" href= "/2017/09/03/howRuntimeWorks/" >彻底理解Runtime</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/29</span><a class="archive-post-title" href= "/2017/06/29/Runloop/" >Runloop</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/08</span><a class="archive-post-title" href= "/2017/05/08/Computer-Networking-A-Top-Down-Approach-NOTES/" >计算机网络 自顶向下方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span><a class="archive-post-title" href= "/2017/04/19/GCD-queue-and-sync-async/" >GCD队列与同步异步的组合</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span><a class="archive-post-title" href= "/2017/01/02/iOS-Core-Animation/" >iOS Core Animation</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2016 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/20</span><a class="archive-post-title" href= "/2016/11/20/Design-Pattern-Odyssey/" >大话设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/30</span><a class="archive-post-title" href= "/2016/09/30/Algorithms/" >Algorithms</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/30</span><a class="archive-post-title" href= "/2016/09/30/操作系统原理/" >操作系统原理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span><a class="archive-post-title" href= "/2016/09/08/Effective-Objective-C-2-0/" >Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/03</span><a class="archive-post-title" href= "/2016/08/03/SwiftGrammar/" >SwiftGrammar</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/22</span><a class="archive-post-title" href= "/2016/05/22/Computer-Systems-A-Programmer-s-Perspective/" >深入理解计算机系统</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/22</span><a class="archive-post-title" href= "/2016/04/22/Pro-multithreading-and-memory-management-for-iOS-and-OS-X/" >Object-C 高级编程 iOS和OS X多线程和内存管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/12</span><a class="archive-post-title" href= "/2016/03/12/git/" >Git</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2015 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/25</span><a class="archive-post-title" href= "/2015/06/25/special-kind-of-pointer/" >几种特殊指针的含义区别</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/08</span><a class="archive-post-title" href= "/2015/05/08/InstallShadowsocks/" >部署Shadowsocks</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/30</span><a class="archive-post-title" href= "/2015/03/30/SQL查询实现方式/" >SQL查询实现方式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/11</span><a class="archive-post-title" href= "/2015/03/11/SQL/" >SQL</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href= "/2015/01/01/How-does-the-program-run/" >程序是怎样跑起来的</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="设计模式"><span class="iconfont-archer">&#xe606;</span>设计模式</span>
    
        <span class="sidebar-tag-name" data-tags="async"><span class="iconfont-archer">&#xe606;</span>async</span>
    
        <span class="sidebar-tag-name" data-tags="sync"><span class="iconfont-archer">&#xe606;</span>sync</span>
    
        <span class="sidebar-tag-name" data-tags="queue"><span class="iconfont-archer">&#xe606;</span>queue</span>
    
        <span class="sidebar-tag-name" data-tags="app"><span class="iconfont-archer">&#xe606;</span>app</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="内存管理"><span class="iconfont-archer">&#xe606;</span>内存管理</span>
    
        <span class="sidebar-tag-name" data-tags="SQL"><span class="iconfont-archer">&#xe606;</span>SQL</span>
    
        <span class="sidebar-tag-name" data-tags="pointer"><span class="iconfont-archer">&#xe606;</span>pointer</span>
    
        <span class="sidebar-tag-name" data-tags="id"><span class="iconfont-archer">&#xe606;</span>id</span>
    
        <span class="sidebar-tag-name" data-tags="NSObject"><span class="iconfont-archer">&#xe606;</span>NSObject</span>
    
        <span class="sidebar-tag-name" data-tags="id<NSObject>"><span class="iconfont-archer">&#xe606;</span>id<NSObject></span>
    
        <span class="sidebar-tag-name" data-tags="void *"><span class="iconfont-archer">&#xe606;</span>void *</span>
    
        <span class="sidebar-tag-name" data-tags="nil"><span class="iconfont-archer">&#xe606;</span>nil</span>
    
        <span class="sidebar-tag-name" data-tags="Nil"><span class="iconfont-archer">&#xe606;</span>Nil</span>
    
        <span class="sidebar-tag-name" data-tags="NSNull"><span class="iconfont-archer">&#xe606;</span>NSNull</span>
    
        <span class="sidebar-tag-name" data-tags="deadLock"><span class="iconfont-archer">&#xe606;</span>deadLock</span>
    
        <span class="sidebar-tag-name" data-tags="计算机系统"><span class="iconfont-archer">&#xe606;</span>计算机系统</span>
    
        <span class="sidebar-tag-name" data-tags="消息"><span class="iconfont-archer">&#xe606;</span>消息</span>
    
        <span class="sidebar-tag-name" data-tags="load"><span class="iconfont-archer">&#xe606;</span>load</span>
    
        <span class="sidebar-tag-name" data-tags="Shadowsocks"><span class="iconfont-archer">&#xe606;</span>Shadowsocks</span>
    
        <span class="sidebar-tag-name" data-tags="CentOS"><span class="iconfont-archer">&#xe606;</span>CentOS</span>
    
        <span class="sidebar-tag-name" data-tags="AWS root"><span class="iconfont-archer">&#xe606;</span>AWS root</span>
    
        <span class="sidebar-tag-name" data-tags="Swift"><span class="iconfont-archer">&#xe606;</span>Swift</span>
    
        <span class="sidebar-tag-name" data-tags="Git"><span class="iconfont-archer">&#xe606;</span>Git</span>
    
        <span class="sidebar-tag-name" data-tags="proxy"><span class="iconfont-archer">&#xe606;</span>proxy</span>
    
        <span class="sidebar-tag-name" data-tags="加速器"><span class="iconfont-archer">&#xe606;</span>加速器</span>
    
        <span class="sidebar-tag-name" data-tags="OS"><span class="iconfont-archer">&#xe606;</span>OS</span>
    
        <span class="sidebar-tag-name" data-tags="runtime"><span class="iconfont-archer">&#xe606;</span>runtime</span>
    
        <span class="sidebar-tag-name" data-tags="计算机网络"><span class="iconfont-archer">&#xe606;</span>计算机网络</span>
    
        <span class="sidebar-tag-name" data-tags="Runloop"><span class="iconfont-archer">&#xe606;</span>Runloop</span>
    
        <span class="sidebar-tag-name" data-tags="Core Animation"><span class="iconfont-archer">&#xe606;</span>Core Animation</span>
    
        <span class="sidebar-tag-name" data-tags="Algorithms"><span class="iconfont-archer">&#xe606;</span>Algorithms</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Hayato"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


