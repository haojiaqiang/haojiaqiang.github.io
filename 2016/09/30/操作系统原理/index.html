<!DOCTYPE html>
<html>
    <!-- title -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Hayato">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Hayato">
    <meta name="keywords" content="Hayato's Studio | Hayato">
    <meta name="description" content="">
    <meta name="Cache-Control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>操作系统原理 · Hayato&#39;s Studio</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s 1;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= /css/style.css?v=20180709 as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= /css/mobile.css?v=20180709 media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Hayato&#39;s Studio.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">操作系统原理</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Hayato's Studio.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style=








height:50vh;

>
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            操作系统原理
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "OS">OS</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count">8,223</span> / Reading time: <span class="post-count">29 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2016/09/30</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介 Introduction"></a>简介 Introduction</h1><p>I/O由对应的控制器负责，CPU一般不直接负责I/O<br>控制器都有对应的缓冲区 &gt; 控制器发送中断信号 &gt; CPU根据中断信号执行对应的中断处理程序<br>陷阱：由程序自身产生的特殊的中断</p>
<p>多级缓存数据一致性：</p>
<ul>
<li>写通过 write-through</li>
</ul>
<h1 id="操作系统服务（Operation-System-Structure）"><a href="#操作系统服务（Operation-System-Structure）" class="headerlink" title="操作系统服务（Operation System Structure）"></a>操作系统服务（Operation System Structure）</h1><p>操作系统亦可称为中断驱动系统</p>
<h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><ul>
<li>批处理 Batch:早期解决方案 》 提高资源利用率，但不支持实时交互</li>
<li>多道 Multiprocessor:</li>
<li>分时 Time-sharing:CPU的运行分时间片（一般1ms，&gt;上下文切换时间）,轮转时间片，最适合交互的通用型系统</li>
<li>实时系统 Real Time:及时性，独占性（如导弹控制机）专用性系统</li>
</ul>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul>
<li><p>与硬件的关系</p>
<blockquote>
<p>控制CPU工作<br><br>访问存储器<br><br>设备驱动、中断处理<br></p>
</blockquote>
</li>
<li><p>与用户及其他软件的关系</p>
<blockquote>
<p>控制管理<br><br>提供方便的用户界面和优质服务</p>
</blockquote>
</li>
</ul>
<h2 id="系统调用-System-Call"><a href="#系统调用-System-Call" class="headerlink" title="系统调用(System Call)"></a>系统调用(System Call)</h2><p>操作系统提供给用户的程序接口。内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，并将处理结果返回给应用程序</p>
<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><h3 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h3><p>通过基址寄存器base(起始值)&amp;&amp;界限 寄存器length等用作保护，判断目标区域是否在对应的内存访问区域base~base+length，如果不是，则越界访问中断</p>
<h3 id="存储扩充"><a href="#存储扩充" class="headerlink" title="存储扩充"></a>存储扩充</h3><p>提供虚拟存储技术，扩大逻辑主存</p>
<h1 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程是程序的一次运行过程。</p>
<h2 id="进程控制块PCB-Process-Control-Block"><a href="#进程控制块PCB-Process-Control-Block" class="headerlink" title="进程控制块PCB(Process Control Block)"></a>进程控制块PCB(Process Control Block)</h2><p>是一个有结构的系统存储区间，用以保存进程执行过程中相关信息，描述进程与其他进程、系统资源的关系以及进程在各个不同时期所处的状态。<br><br>每一被创建进程都有自己的PCB，系统通过PCB感知进程的存在，是进程存在的唯一标志</p>
<p>PCB:</p>
<ul>
<li>Process state</li>
<li>Program Counter</li>
<li>CPU registers</li>
<li>CPU scheduling information</li>
<li>Memory-management information</li>
<li>Accounting information</li>
<li>I/O status information</li>
</ul>
<h2 id="进程状态-Process-State"><a href="#进程状态-Process-State" class="headerlink" title="进程状态(Process State)"></a>进程状态(Process State)</h2><p>进程执行过程中所处的状态。有就绪(Ready)、执行(Running)、等待(Waiting)等至少三个基本状态，实际操作系统中，进程状态设置有所不同</p>
<ul>
<li>就绪(Ready)：进程已经获得了除cpu之外的全部资源，等待系统分配cpu，一旦获得cpu，进程就可以变为运行态</li>
<li>执行(Running)：正在cpu上执行的进程所处的状态。在单cpu系统中，任何时候最多只能有一个进程处于运行状态</li>
<li>等待/阻塞(Waiting/Blocked)：正在运行的进程因等待某个条件发生而不能运行时所处的状态。处于阻塞态的进程在逻辑上是不能运行的，即使cpu空闲，它也不能占用cpu</li>
</ul>
<h2 id="进程队列-Process-Queue"><a href="#进程队列-Process-Queue" class="headerlink" title="进程队列 Process Queue"></a>进程队列 Process Queue</h2><p>进程根据其状态处于不同的队列，并随着状态变化在各队列之间迁移</p>
<h2 id="进程调度-Process-Scheduling"><a href="#进程调度-Process-Scheduling" class="headerlink" title="进程调度 Process Scheduling"></a>进程调度 Process Scheduling</h2><p>选择一个可用的进程（可能从多个可用进程集合中选择）到CPU上执行</p>
<h3 id="短程调度（Short-term-Scheduler-又称进程调度、CPU调度或低级调度）"><a href="#短程调度（Short-term-Scheduler-又称进程调度、CPU调度或低级调度）" class="headerlink" title="短程调度（Short-term Scheduler,又称进程调度、CPU调度或低级调度）"></a>短程调度（Short-term Scheduler,又称进程调度、CPU调度或低级调度）</h3><p>按照一定算法，从就绪队列选择满足条件的进程，分配CPU,进入运行状态。进程<strong>调度执行频率高</strong></p>
<h3 id="长程调度（Long-term-Scheduler-又称作业调度或高级调度"><a href="#长程调度（Long-term-Scheduler-又称作业调度或高级调度" class="headerlink" title="长程调度（Long-term Scheduler,又称作业调度或高级调度)"></a>长程调度（Long-term Scheduler,又称作业调度或高级调度)</h3><p>按照一定算法，从磁盘后备队列中选择满足条件的作业，创建进程，入就绪队列。作业调度控制多道程序中的“道数”，<strong>执行频率较低</strong></p>
<h3 id="中程调度（Medium-term-Scheduler-又称中级调度"><a href="#中程调度（Medium-term-Scheduler-又称中级调度" class="headerlink" title="中程调度（Medium-term Scheduler,又称中级调度)"></a>中程调度（Medium-term Scheduler,又称中级调度)</h3><p>按照一定算法或原则，将内存中部分进程换出（Swap Out)到磁盘交换区，或者将处于磁盘交换区的进程换入(Swap In）内存就绪队列</p>
<h2 id="上下文-进程的运行环境"><a href="#上下文-进程的运行环境" class="headerlink" title="上下文 - 进程的运行环境"></a>上下文 - 进程的运行环境</h2><ol>
<li>用户级上下文</li>
</ol>
<ul>
<li>进程的代码、数据、共享内存、用户栈</li>
<li>该进程虚拟地址空间</li>
<li>在请求页式系统中，该级上下文内容不必全部进入内存</li>
</ul>
<ol start="2">
<li>寄存器上下文</li>
</ol>
<ul>
<li>程序计数器PC</li>
<li>处理机状态寄存器PS</li>
<li>栈指针SP</li>
<li>通用寄存器组：保存进程运行过程中所产生的中间结果</li>
</ul>
<ol start="3">
<li>系统级上下文</li>
</ol>
<ul>
<li>每个进程的</li>
<li>进程user结构</li>
<li>进程区表表项、也表，用于从虚拟地址到无力地址的转换</li>
<li>进程核心栈</li>
</ul>
<h3 id="上下文切换（Context-Switch"><a href="#上下文切换（Context-Switch" class="headerlink" title="上下文切换（Context Switch)"></a>上下文切换（Context Switch)</h3><p>当进程调度选中某一进程执行时，需要保存（Save）当前进程执行相关状态，并装入（Load）被选中进程已经保存的相关状态，这个过程称之为上下文切换。上下文切换属于系统消耗（Overhead)</p>
<h2 id="进程通讯-Inter-process-Communication"><a href="#进程通讯-Inter-process-Communication" class="headerlink" title="进程通讯(Inter-process Communication)"></a>进程通讯(Inter-process Communication)</h2><p>进程间交换数据或信息保持协调的一种机制，一般分为消息通讯(Message Passing)与共享主存(Shared Memory)两种通讯方式</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>消息传递(通过系统调用send() &amp;&amp; receive()，通过全权限的系统控制内存区域达到信息传递)</li>
<li>共享内存(对有公共内存访问的进程之间的通讯)</li>
</ul>
<h2 id="多道程序设计-Multi-programming"><a href="#多道程序设计-Multi-programming" class="headerlink" title="多道程序设计(Multi-programming)"></a>多道程序设计(Multi-programming)</h2><p>是在计算机内存中同时存放几道相互独立的程序，是它们在管理程序控制之下，相互穿插的运行。两个或两个以上程序在计算机系统中同处于开始和结束之间的状态，就称为多道程序技术</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>多道</li>
<li>宏观上并行</li>
<li>微观上串行</li>
</ul>
<h2 id="程序的一些特性"><a href="#程序的一些特性" class="headerlink" title="程序的一些特性"></a>程序的一些特性</h2><ul>
<li>顺序性(Sequential)：是指顺序程序所规定的每个动作都在上个动作结束后才开始的特性</li>
<li>封闭性(Closeness)：是指只有程序本身的动作才能改变程序的运行环境（并发无效）</li>
<li>可再现性(Reproducibility)：是指程序的执行结果与程序运行的速度无关（并发无效）</li>
<li>并发性(Concurrency)：又称为共行性是指能处理多个同时性活动的能力。</li>
<li>原语(Primitive )：指操作系统中实现一些具有特定功能的程序段，这些程序段的执行过程是不可分割的，即其执行过程不允许被中断。一般通过把操作的优先级设置为最高实现</li>
</ul>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p>busy waitting</p>
<h1 id="线程（Thread）"><a href="#线程（Thread）" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>有时被称为轻量级进程（Lightweight Process,LWP),是程序执行流的最小单元。一个标准的线程由<code>线程ID</code>,当前<code>指令指针</code>（PC)，<code>寄存器集合</code>和<code>堆栈</code>组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的代码段、数据段及其他操作系统全部资源。<br><img src="http://qiniu.hayato.tech/markdownimages/OSmultithread1.png" alt=""></p>
<h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><ul>
<li>内核级线程（Kernel Threads）：内核支持的线程</li>
<li>用户级线程（User Threads):通过用户级线程库（User-level Threads Libtary)管理的线程。<h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2></li>
<li>线程库（Thread Library):为程序员提供创建和管理线程的API。</li>
<li>异步取消（Asynchronous Cancellation):一个线程立即终止目标线程。</li>
<li>延迟取消（Deferred Cancellation）：目标线程不断的检查它是否应终止，这允许目标线程有机会以有序方式来终止自己。</li>
</ul>
<h1 id="CPU调度（CPU-Scheduling）"><a href="#CPU调度（CPU-Scheduling）" class="headerlink" title="CPU调度（CPU Scheduling）"></a>CPU调度（CPU Scheduling）</h1><h2 id="批处理系统中采用的调度算法"><a href="#批处理系统中采用的调度算法" class="headerlink" title="批处理系统中采用的调度算法"></a>批处理系统中采用的调度算法</h2><ul>
<li>FCFS(First come first service)非抢占式的先来先服务算法：按照进程就绪的先后顺序使用CPU<blockquote>
<p>特点：公平，实现简单，但是长进程后面的短进程需要等待很长时间，不利于用户体验</p>
</blockquote>
</li>
<li>SRTN(Shortest Remaining Time Next)最短剩余时间优先：SJF抢占版本，即当一个新就绪进程比当前运行进程具有更短完成时间时，系统抢占当前进程，选择新就绪的进程执行<blockquote>
<p>SJF(Shortest Job First )最短作业优先调度算法特点：改善短作业的周转时间，但如果源源不断有短任务到来，可能使长的任务长时间得不到运行，产生饥饿现象。</p>
</blockquote>
</li>
<li>HRRN（Highest Response Ratio Next）最高响应比优先算法:是一个综合算法，调度时，首先计算每个进程的响应比R,之后总是选择R最高的进程执行。<blockquote>
<p>响应比R = (等待时间+处理时间）/处理时间</p>
</blockquote>
</li>
</ul>
<h2 id="交互系统中采用的调度算法"><a href="#交互系统中采用的调度算法" class="headerlink" title="交互系统中采用的调度算法"></a>交互系统中采用的调度算法</h2><ul>
<li>时间片轮转调度算法：每个进程被分配一个时间片，允许该进程在该时间段运行，如果在时间片结束时该进程还在运行，则剥夺CPU并分配给另外一个进程，如果该进程在时间片结束前Waiting或结束，则CPU立即进行切换。<blockquote>
<p>1.当时间选择片太长，其降级为FSFS算法，引起对短的交互请求响应时间长<br>2.当时间片选择太短，会导致频繁的进程切换，浪费CPU时间<br>3.通常选择为20ms~50ms<br>4.对进程表中不同进程的大小差异较大的有利，而对进程都是相同大小的不利</p>
</blockquote>
</li>
<li>虚拟轮转法：主要基于时间片轮转法进行改进，解决在CPU调度中对I/O密集型进程的不友好。其设置了一个辅助队列，对于I/O型进程执行完一个时间片之后，则进入辅助队列，CPU调度时总是先检查辅助队列是否为空，如果不为空总是优先调度辅助队列里的进程，直到为空，才调度就绪队列的进程<br><img src="http://qiniu.hayato.tech/markdownimages/OS-CPUSchedulingRound1.png" alt=""></li>
<li>最高优先级调度算法：选择优先级最高的进程优先执行。<blockquote>
<p>1.优先级可以静态不变，也可以动态调整<br>2.优先数决定优先级<br>3.就绪队列可以按照优先级组织<br>4.实现简单，但不公平，可能导致优先级低的进程产生饥饿现象<br>5.可能产生优先级反转问题（基于优先级的抢占式算法），即一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行</p>
</blockquote>
</li>
<li>多级反馈队列调度算法<blockquote>
<p>1.设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，依次递减优先级<br>2.对于各个队列进程执行时间片的大小也不同，优先级越高的队列，分配到的时间片越少<br>3.当第一级队列为空时，再第二级队列进行调度，依次类推，各级队列按照时间片轮转方式进行调度<br>4.当一个新进程创建后，首先把它放入第一队列的末尾。按照FCFS原则排队等待调度。当轮到该进程执行时，如它在该时间片完成，便可准备撤离系统，如果它在一个时间片结束时尚未完成，则调度程序便将该进程转入第二队列的末尾，再同样的按照FCFS原则等待调度执行。依次类推。<br><img src="http://qiniu.hayato.tech/markdownimages/OS-CPUSchedulingFeedback1.png" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="各种调度算法比较"><a href="#各种调度算法比较" class="headerlink" title="各种调度算法比较"></a>各种调度算法比较</h2><p><img src="http://qiniu.hayato.tech/markdownimages/OS-CPUSchedulingAlgorithmsCompare.png" alt=""></p>
<h1 id="Process-Synchronization进程同步"><a href="#Process-Synchronization进程同步" class="headerlink" title="Process Synchronization进程同步"></a>Process Synchronization进程同步</h1><p>原子操作：单核一般通过禁止中断(提高优先级)实现，多核可通过总线锁等方式实现</p>
<h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><ul>
<li>软件：临界区【访问(互斥)临界资源的代码段】</li>
<li>硬件：特殊指令</li>
<li>信号量</li>
</ul>
<p>临界区特点：</p>
<blockquote>
<p>1.忙则等待(互斥)<br>2.空闲让进<br>3.有限等待(避免饥饿)<br>4.让权(CPU)等待</p>
</blockquote>
<h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int value;</span><br><span class="line">    struct process *list;</span><br><span class="line">&#125; semaphore</span><br></pre></td></tr></table></figure>
<ul>
<li>P/wait() 原语操作-1;</li>
<li>V/signal() 源于操作+1;</li>
</ul>
<h3 id="解决busy-waiting问题-gt-互斥锁效果"><a href="#解决busy-waiting问题-gt-互斥锁效果" class="headerlink" title="解决busy waiting问题 &gt; 互斥锁效果"></a>解决busy waiting问题 &gt; 互斥锁效果</h3><p>定义semaphore为一个包含链表的结构，当一个task执行wait()操作发现信号量值不为正，将该task置为waiting状态等待，并将task.pcb加入到semaphore的<pcb *="">list链表中。当semaphore执行signal()之后，通过list链表获取task并通过wakeup(task)切换到reading等待CPU调度</pcb></p>
<h2 id="spinLock自旋锁"><a href="#spinLock自旋锁" class="headerlink" title="spinLock自旋锁"></a>spinLock自旋锁</h2><p>执行单元轮询检查锁变量是否可用，该单元一直处于忙等状态</p>
<ul>
<li>优点：线程在等待锁时不进行上下文切换，效率高（适用于占用锁时间短的场景，多处理器情况下可以可由非执行处理器进行busy waiting）</li>
<li>缺点：忙等状态浪费CPU资源</li>
</ul>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>执行单元当锁不可用时被置为waiting,当锁可用时被调度到reading</p>
<ul>
<li>优点：锁不可用时不被调度，不浪费CPU资源</li>
<li>缺点：需要上下文切换</li>
</ul>
<h2 id="Monitors管程-监视器-秘书进程"><a href="#Monitors管程-监视器-秘书进程" class="headerlink" title="Monitors管程/监视器/秘书进程"></a>Monitors管程/监视器/秘书进程</h2><ul>
<li>概念：是一种程序结构，结构内的多个子程序(对象或模块)形成的多个工作线程互斥访问共享资源。</li>
<li>特点：封装了同步操作，对线程隐蔽了同步细节，简化了同步功能的调用</li>
<li>优势：解决信号量的PV操作由各线程自由控制，分散不易管理的问题。<br><blockquote>
<p>1、把分散在各进程中的临界区集中起来进行管理；<br>2、防止进程有意或无意的违法同步操作；<br>3、便于用高级语言来书写程序，也便于程序正确性验证。</p>
</blockquote>
</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">monitor monitor name</span><br><span class="line">&#123;</span><br><span class="line">    // shared variable declarations</span><br><span class="line">    procedure P1(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">     procedure P2(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">    procedure Pn(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    initialization code (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.hayato.tech/markdownimages/OSMonitor.png" alt=""></p>
<h2 id="Turnstile十字转门"><a href="#Turnstile十字转门" class="headerlink" title="Turnstile十字转门"></a>Turnstile十字转门</h2><p>一种数据抽象，用来封装休眠队列和互斥锁和读/写锁相关的优先级继承信息。用来解决休眠队列在处理其他资源等待时无法通过优先级继承处理优先级反转问题</p>
<h2 id="transaction事务"><a href="#transaction事务" class="headerlink" title="transaction事务"></a>transaction事务</h2><p>执行单个逻辑功能的一组指令或操作，是一个原子执行的程序单元。<br>当多个事务重叠执行时，为保证串行化，常用以下并发控制方案：</p>
<blockquote>
<p>加锁协议<br>时间戳顺序协议</p>
</blockquote>
<h1 id="deadlock-死锁"><a href="#deadlock-死锁" class="headerlink" title="deadlock 死锁"></a>deadlock 死锁</h1><p>两个或两个以上的执行单元在执行过程中，因竞争资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进，此时系统所处的状态称为死锁。</p>
<p>四个必要条件</p>
<ul>
<li>互斥：至少一个资源，一次只能被一个线程使用，不能共享</li>
<li>占有并等待：线程已经拥有部分资源，还需要等待正在被其他线程使用的资源</li>
<li>非抢占式资源：线程获得的资源，只能由自己主动释放，而不能被强行剥夺</li>
<li>环路等待：一组进程之间对资源的拥有与申请构成环路</li>
</ul>
<h2 id="死锁防止（Deadlock-Prevention）"><a href="#死锁防止（Deadlock-Prevention）" class="headerlink" title="死锁防止（Deadlock Prevention）"></a>死锁防止（Deadlock Prevention）</h2><p>要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态</p>
<h2 id="死锁避免-DeadlockAvoidance"><a href="#死锁避免-DeadlockAvoidance" class="headerlink" title="死锁避免(DeadlockAvoidance)"></a>死锁避免(DeadlockAvoidance)</h2><p>对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。就是说，在资源分配过程中若预测有发生死锁的可能性，则加以避免。这种方法的关键是确定资源分配的安全性</p>
<h2 id="安全序列-Security-Sequence"><a href="#安全序列-Security-Sequence" class="headerlink" title="安全序列(Security Sequence)"></a>安全序列(Security Sequence)</h2><p>针对当前分配状态来说，系统至少能够按照某种次序为每个进程分配资源（直至最大需求），并且使他们依次成功地运行完毕，这种进程序列{p1,p2,…,pn}就是安全序列。</p>
<h2 id="死锁避免算法"><a href="#死锁避免算法" class="headerlink" title="死锁避免算法"></a>死锁避免算法</h2><h3 id="资源分配图算法"><a href="#资源分配图算法" class="headerlink" title="资源分配图算法"></a>资源分配图算法</h3><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><ul>
<li>安全性算法</li>
<li>资源请求算法</li>
</ul>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><h2 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h2><h3 id="应用终止"><a href="#应用终止" class="headerlink" title="应用终止"></a>应用终止</h3><h3 id="资源抢占"><a href="#资源抢占" class="headerlink" title="资源抢占"></a>资源抢占</h3><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="空间分片"><a href="#空间分片" class="headerlink" title="空间分片"></a>空间分片</h2><ul>
<li>大小不等的区域 – 分区/分段存储管理</li>
<li>大小相等的片 – 页式存储管理</li>
<li>二者结合 – 段页式存储管理</li>
</ul>
<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><ol>
<li>物理地址(绝对地址、实地址)<br>物理地址是计算机主存单元的真实地址，又称为绝对地址或实地址</li>
<li>主存空间<br>物理地址的集合所对应的空间组成了主存空间</li>
<li>逻辑地址(相对地址、虚地址)<br>用户的程序地址（指令地址或操作数地址）均为逻辑地址</li>
<li>作业地址空间<br>用户程序所有的逻辑地址集合对应的空间</li>
</ol>
<h2 id="主存管理功能"><a href="#主存管理功能" class="headerlink" title="主存管理功能"></a>主存管理功能</h2><ul>
<li>实现逻辑地址到物理地址的映射</li>
<li>主存分配</li>
<li>存储保护</li>
<li>主存扩充</li>
</ul>
<h2 id="地址映射-by-内存管理单元MMU"><a href="#地址映射-by-内存管理单元MMU" class="headerlink" title="地址映射 by 内存管理单元MMU"></a>地址映射 by 内存管理单元MMU</h2><p>逻辑地址 -&gt; 物理地址</p>
<h3 id="地址映射的时机和类别"><a href="#地址映射的时机和类别" class="headerlink" title="地址映射的时机和类别"></a>地址映射的时机和类别</h3><ul>
<li>编程/编译时期 &gt; 绝对代码</li>
<li>load时期 &gt; 可重定位代码（静态地址映射） </li>
<li>运行时期 &gt; 每条指令和数据访问时才进行映射（动态地址映射）</li>
</ul>
<h2 id="主存分配"><a href="#主存分配" class="headerlink" title="主存分配"></a>主存分配</h2><ol>
<li>构造分配用的数据结构<br>主存资源信息块：等待队列；空闲区队列；主存分配程序</li>
<li>制定策略<blockquote>
<p>主存分配策略 - 在众多请求者中选择一个请求者的原则<br><br>放置策略 - 在可用资源中，选择一个空闲区的原则<br><br>调入策略 - 决定信息装入主存的时机(分预调策略和请调策略)<br><br>牺牲策略 - 当主存已满，决定哪些信息从主存中移除</p>
</blockquote>
</li>
<li>实时主存分配与回收</li>
</ol>
<h2 id="主存分配方式"><a href="#主存分配方式" class="headerlink" title="主存分配方式"></a>主存分配方式</h2><ol>
<li>连续分配</li>
<li>离散分配</li>
</ol>
<ul>
<li>分页 </li>
<li>分段 </li>
<li>段页式 </li>
</ul>
<h2 id="主存扩充"><a href="#主存扩充" class="headerlink" title="主存扩充"></a>主存扩充</h2><ol>
<li>可行性 局部性特征</li>
<li>实现方法 <blockquote>
<p>程序的代码和数据存放在辅存中<br><br>将程序当前执行所涉及的那部分程序代码放入主存中<br><br>程序执行时，当所需信息不在主存(Page fault缺页)，由操作系统和硬件相配合来完成主存从辅存中调入信息，程序继续执行<br></p>
</blockquote>
</li>
<li>虚拟存储器<br>由操作系统和硬件相配合来完成主存和辅存之间的信息的动态调度。这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器</li>
</ol>
<h2 id="虚拟存储器的核心"><a href="#虚拟存储器的核心" class="headerlink" title="虚拟存储器的核心"></a>虚拟存储器的核心</h2><ul>
<li>逻辑地址与物理地址的分离</li>
<li>存储空间与虚拟地址空间的分离</li>
<li>提供地址变换机构</li>
</ul>
<h2 id="实现虚拟存储器的物质基础"><a href="#实现虚拟存储器的物质基础" class="headerlink" title="实现虚拟存储器的物质基础"></a>实现虚拟存储器的物质基础</h2><ul>
<li>有相当容量的辅存<br>  足以存放应用程序的虚拟地址空间</li>
<li>有一定容量的主存<br>  存放进入主存的多进程的信息</li>
<li>地址变换机构</li>
</ul>
<h2 id="存储保护-1"><a href="#存储保护-1" class="headerlink" title="存储保护"></a>存储保护</h2><ol>
<li>什么是存储保护<br>在多用户环境中，主存存储器按区分配给各用户程序使用。为了互不影响，必须由硬件（软件配合）保证各用户程序只能在给定的存储区域内活动，这种措施叫做存储保护</li>
<li>实现方法</li>
</ol>
<ul>
<li>界地址保护(常用的base + length)</li>
<li>存储键保护</li>
</ul>
<h2 id="内存分区分配算法"><a href="#内存分区分配算法" class="headerlink" title="内存分区分配算法"></a>内存分区分配算法</h2><p><img src="http://qiniu.hayato.tech/markdownimages/OS-memoryAllocationAlgorithms.png" alt=""></p>
<ol>
<li><p>首次适应算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首次适应是从空闲链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止，然后按照作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍然留在空闲链中。若从头到尾都不能找到一个能满足空间要求的分区，则此次内存分配失败。该算法倾向优先使用内存中低地址部分的空闲分区，从而保留了高址部分的大空闲区，为后续到达的大作业分配大的内存空间创造了条件。那么相反，每次都从空闲链首开始查找，低地址部分不断的被划分就会导致产生许多难以利用的、很小的空闲分区，同时也会增加每次查找的开销</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环首次适应算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是在首次适应算法的基础上添加了循环的功能，使用该算法为进程分配内存空间时，不再从头开始，而是从上次分配的位置为起点的下一个分区为起点开始查找，其余与首次适应算法相同。这样就解决了每次从头开始查找开销大的问题，但是这样在多次分配之后也会导致缺乏大的空闲分区</span><br></pre></td></tr></table></figure>
</li>
<li><p>最佳适应算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最佳适应是在每次分配时将**能满足要求的最小的**空闲分区分配给作业，避免了大材小用。为了加速查找，该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链，这样，从该空闲分区链中查找到的第一块符合要求的空闲区必然是最佳的。但是最佳适应算法也是有缺点的，每次分配的是最佳，那么剩余的空闲将会是尽可能的小，就会导致小的空闲分区无法分配给作业，就会在存储器中留下许多难以利用的小空闲区</span><br></pre></td></tr></table></figure>
</li>
<li><p>最坏适应算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与最佳适应算法正好相反，最坏适应算法是挑选一个最大的空闲分区给作业分配使用，其优点是可使剩余空间不至于太小，产生碎片的几率最小，对中、小作业有利。同时，该算法要求所有的空闲分区按其容量以从大到小的顺序形成空闲分区链，查找时只要看第一个分区能产生否满足要求即可。，那么它的缺点就对应是缺少大的空闲分区</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速适应算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">又称为分类搜索法，是将空闲分区根据其容量按照大小进行分类，对每类相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，就会在系统中存在多个空闲分区链表，同时会在内存中设立一张管理索引表，该表的每一个表项对应一种空闲分区类型，并记录该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分，比如2k、4k、8k等，对于特殊大小的分区，如7k大小，即可放在特殊的分区中，也可放在8k分区的链表当中。</span><br><span class="line">该算法的优点是查找效率高，仅需要根据进程的长度，寻找到能容纳它的最小空间区链表，并取第一块进行分割即可。另外该算法在进行空闲分区分配时不会对任何分区产生分割，所以能保留大的分区，也不会产生内存碎片。</span><br><span class="line">缺点是在进行分区归还时算法复杂，系统开销大。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>ps：1、2、3、4四种算法也称为顺序搜索法</p>
<h2 id="碎片问题及碎片整理"><a href="#碎片问题及碎片整理" class="headerlink" title="碎片问题及碎片整理"></a>碎片问题及碎片整理</h2><ol>
<li>碎片问题<br> 在已分配区之间存在着的一些没有被充分利用的空闲区</li>
<li>碎片整理<br> 移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲</li>
</ol>
<h2 id="内存分区分配常用的数据结构"><a href="#内存分区分配常用的数据结构" class="headerlink" title="内存分区分配常用的数据结构"></a>内存分区分配常用的数据结构</h2><ol>
<li><p>空闲分区表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在系统中设置一张空闲分区表，用于记录，每个空闲分区的情况，每个空闲分区占一个表目，表中包括分区序号，分区开始地址以及分区的大小等数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>空闲分区链</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个数据结构是在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各个分区所用的前后指针，这样可以将所有的空闲分区链接成一个双向链，为了检索方便，在分区尾部重复设置状态位和分区大小表目，当分区已分配，则将状态位由0改为1，此时前后向指针失去作用</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h2><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>程序的地址空间被等分成大小相等的片，称为页面，又称为虚页</p>
<h3 id="主存块"><a href="#主存块" class="headerlink" title="主存块"></a>主存块</h3><p>主存被分成大小相等的片，称为主存块，又称为实页</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>为了实现从地址空间到物理主存的映像，系统建立的逻辑页与物理页帧之间对应关系的地址变换的机构称为页面映像表，简称页表</p>
<p>注意：页表包含在系统空间的PCB中</p>
<h4 id="页表的组成"><a href="#页表的组成" class="headerlink" title="页表的组成"></a>页表的组成</h4><ul>
<li>高速缓冲存储器 – 地址变化速度快，但成本较高</li>
<li>主存区域 – 地址变换速度比硬件慢，相对成本较低<h3 id="使用联想存储器加快页表查询速度"><a href="#使用联想存储器加快页表查询速度" class="headerlink" title="使用联想存储器加快页表查询速度"></a>使用联想存储器加快页表查询速度</h3></li>
<li>使用联想存储器<blockquote>
<p>高速、小容量半导体存储部件，又称缓冲存储器</p>
</blockquote>
</li>
<li>使用快表缓存<blockquote>
<p>在缓冲存储器中存放正在运行的进程当前用到的页号和对应的块号，又称快表</p>
</blockquote>
</li>
</ul>
<h3 id="缺页处理"><a href="#缺页处理" class="headerlink" title="缺页处理"></a>缺页处理</h3><p><img src="http://qiniu.hayato.tech/markdownimages/OS-page fault handler.png" alt=""></p>
<h3 id="抖动-颠簸"><a href="#抖动-颠簸" class="headerlink" title="抖动/颠簸"></a>抖动/颠簸</h3><p>导致系统效率急剧下降的主存和辅存之间的频繁页面置换现象</p>
<h3 id="内存淘汰算法"><a href="#内存淘汰算法" class="headerlink" title="内存淘汰算法"></a>内存淘汰算法</h3><ol>
<li>LRU（Least Recently Used，最少最近使用算法）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计时法:给页表中的每一页增加一个域，专门用来存放计时标志，用来记录该页面自上次被访问以来所经历的时间。页面每被访问一次，计时清0。要装入新页时，从内存的页面中选出时间最长的一页，调出，同时把各页的计时标志全部清0，重新开始计时。 计时法可以稍作改变，成为计数法：页面被访问，计数标志清0，其余所有内存页面计数器加1；要装入新页时，选出计数最大的一页调出，同时所有计数器清0。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链表法:操作系统为每个进程维护一条链表，链表的每个结点记录一张页面的地址。调用一次页面，则把该页面的结点从链中取出，放到链尾；要装入新页，则把链头的页面调出，同时生成调入页面的结点，放到链尾。链表法可看作简单计时/计数法的改良，维护一个链表，自然要比维护所有页面标志要简单和轻松。可是，这并没有在数量级上改变算法的时间复杂度，每调用一个页面，都要在链表中搜寻对应结点并放至链尾的工作量并不算小。</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>FIFO（先进先出算法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">顾名思义，最先被置换进内存的页面最先出来，公正公平，大家都别抢，但是不一定合理，能者要多劳啊。</span><br><span class="line">最先进去的页面，比如一些初始化性质的页面，通常在整个程序运行期间都是需要，被置换出去非常不合理。</span><br></pre></td></tr></table></figure>
</li>
<li><p>NRU（Not Recently Used，最近未使用算法，又称CLK算法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 给每一帧关联一个附加位，称为使用位</span><br><span class="line">2. 当某一页首次装入主存时，该帧的使用位设置为1</span><br><span class="line">3. 当该页随后再被访问到时，它的使用位也被置为1</span><br><span class="line">4. 对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联</span><br><span class="line">5. 当某一页被替换时，该指针被设置成指向缓冲区中的下一帧</span><br><span class="line">6. 当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0</span><br><span class="line">7. 如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换</span><br><span class="line">8. 如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="段式地址空间"><a href="#段式地址空间" class="headerlink" title="段式地址空间"></a>段式地址空间</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>分段是程序中自然划分的一组逻辑意义完整的信息集合。* 代码分段</p>
<ul>
<li>数据分段</li>
<li>栈段页</li>
</ul>
<h3 id="作业地址空间"><a href="#作业地址空间" class="headerlink" title="作业地址空间"></a>作业地址空间</h3><p>由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，它是一个连续的地址区</p>
<h3 id="段式地址结构"><a href="#段式地址结构" class="headerlink" title="段式地址结构"></a>段式地址结构</h3><table>
<thead>
<tr>
<th style="text-align:left">段号 w</th>
<th style="text-align:center">段内位移 s</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h4 id="段式地址步骤"><a href="#段式地址步骤" class="headerlink" title="段式地址步骤"></a>段式地址步骤</h4><ul>
<li>取出程序地址(s, w）</li>
<li>用s检索段表</li>
<li>（Base + w)即为所需主存地址</li>
<li>如w&lt;0或w≥Length则主存越界</li>
</ul>
<h2 id="页式系统与段式系统的区别"><a href="#页式系统与段式系统的区别" class="headerlink" title="页式系统与段式系统的区别"></a>页式系统与段式系统的区别</h2><h3 id="用户地址空间的区别"><a href="#用户地址空间的区别" class="headerlink" title="用户地址空间的区别"></a>用户地址空间的区别</h3><ul>
<li>页式系统中用户地址空间 – 一维地址空间</li>
<li>段式系统中用户地址空间 – 二维地址空间</li>
</ul>
<h3 id="分段和页面的区别"><a href="#分段和页面的区别" class="headerlink" title="分段和页面的区别"></a>分段和页面的区别</h3><table>
<thead>
<tr>
<th style="text-align:left">分段</th>
<th style="text-align:left">页面</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">信息的逻辑划分</td>
<td style="text-align:left">信息的物理划分</td>
</tr>
<tr>
<td style="text-align:left">段长是可变的</td>
<td style="text-align:left">页的大小是固定的</td>
</tr>
<tr>
<td style="text-align:left">用户可见</td>
<td style="text-align:left">用户不可见</td>
</tr>
<tr>
<td style="text-align:left">w字段的溢出将产生越界中断</td>
<td style="text-align:left">w字段的溢出自动加入到页号中</td>
</tr>
</tbody>
</table>
<h2 id="段页式系统"><a href="#段页式系统" class="headerlink" title="段页式系统"></a>段页式系统</h2><p>在段式存储管理中结合分页存储管理技术，在一个分段内划分页面，就形成了段页式存储管理</p>
<h2 id="存储管理技术"><a href="#存储管理技术" class="headerlink" title="存储管理技术"></a>存储管理技术</h2><ol>
<li>Swap对换技术<blockquote>
<p>在主存和交换设备之间传递整个进程映像，而不是进程的一个部分(早期采用)</p>
</blockquote>
</li>
<li>请求调页技术<blockquote>
<p>在主存和交换设备之间传递存储页，而不是整个进程的映像</p>
</blockquote>
</li>
</ol>
<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>用于支持数据在磁盘的存储、定位与检索，实现对磁盘的有效、便捷访问；<br>文件系统提供了在线存储和访问计算机操作系统和所有用户的程序与数据的机制。包括2个组成部分：一组<code>文件</code>和<code>目录结构</code></p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>文件是记录在外存上的相关信息的具有名称的集合。根据其类型具有特定结构。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li>名称：符号名称是唯一的、按照人们容易读取的形式保存</li>
<li>标识符：标识文件系统内文件的唯一标签，通常为数字；对用户而言这是不可读文件名称</li>
<li>类型：被支持不同类型的文件系统所使用</li>
<li>位置：该信息为指向设备和设备上文件位置的指针</li>
<li>大小：文件当前大小(以字节、字或块来统计)，该属性页可包括文件允许的最大容量值</li>
<li>保护：决定谁能读、写、执行等的访问控制信息</li>
<li>时间、日期和用户标识：文件创建、上次修改和上次访问的相关信息。这些数据用于保护、安全和使用追踪</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li>创建文件</li>
<li>写文件</li>
<li>读文件</li>
<li>在文件内重定位</li>
<li>删除文件</li>
<li>截短文件</li>
</ul>
<h1 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h1><h2 id="分配方案"><a href="#分配方案" class="headerlink" title="分配方案"></a>分配方案</h2><ul>
<li>连续分配</li>
<li>链接分配</li>
</ul>
<h1 id="I-O输入系统"><a href="#I-O输入系统" class="headerlink" title="I/O输入系统"></a>I/O输入系统</h1><p>成熟的中断处理特性：</p>
<ol>
<li>在进行关键处理时，能够延迟中断处理特性</li>
<li>更为有效地将中断分发到合适的中断处理程序，而不是检查所有设备以决定哪个设备引起中断</li>
<li>需要中断优先级，这样操作系统能区分高优先级或低优先级的中断，能根据紧迫性的程度来响应</li>
</ol>
<p><img src="http://qiniu.hayato.tech/markdownimages/OS-InterruptVector.png" alt=""></p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>最小特权原则：它规定程序、用户，甚至包括操作系统仅拥有它们能够完成其任务的特权。</p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者: <a href="https://haojiaqiang.github.io">Hayato</a>
            <p>原文链接: <a href="https://haojiaqiang.github.io/2016/09/30/操作系统原理/">https://haojiaqiang.github.io/2016/09/30/操作系统原理/</a>
            <p>发表日期: <a href="https://haojiaqiang.github.io/2016/09/30/操作系统原理/">September 30th 2016, 9:11:25 am</a>
            <p>版权声明: <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC-SA 4.0</a></p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2016/09/30/Algorithms/" title= Algorithms >
                    <div class="nextTitle">Algorithms</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2016/09/08/Effective-Objective-C-2-0/" title= Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法 >
                    <div class="prevTitle">Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!--PC和WAP自适应版-->

    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
    
        
            
                <a href="https://github.com/haojiaqiang" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="https://about.me/haojiaqiang" class="iconfont-archer others" target="_blank" title=others></a>
            
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介-Introduction"><span class="toc-number">1.</span> <span class="toc-text">简介 Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统服务（Operation-System-Structure）"><span class="toc-number">2.</span> <span class="toc-text">操作系统服务（Operation System Structure）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分类："><span class="toc-number">2.1.</span> <span class="toc-text">分类：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关系"><span class="toc-number">2.2.</span> <span class="toc-text">关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统调用-System-Call"><span class="toc-number">2.3.</span> <span class="toc-text">系统调用(System Call)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储管理"><span class="toc-number">2.4.</span> <span class="toc-text">存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#存储保护"><span class="toc-number">2.4.1.</span> <span class="toc-text">存储保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储扩充"><span class="toc-number">2.4.2.</span> <span class="toc-text">存储扩充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Processes"><span class="toc-number">3.</span> <span class="toc-text">Processes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程控制块PCB-Process-Control-Block"><span class="toc-number">3.2.</span> <span class="toc-text">进程控制块PCB(Process Control Block)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程状态-Process-State"><span class="toc-number">3.3.</span> <span class="toc-text">进程状态(Process State)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程队列-Process-Queue"><span class="toc-number">3.4.</span> <span class="toc-text">进程队列 Process Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程调度-Process-Scheduling"><span class="toc-number">3.5.</span> <span class="toc-text">进程调度 Process Scheduling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#短程调度（Short-term-Scheduler-又称进程调度、CPU调度或低级调度）"><span class="toc-number">3.5.1.</span> <span class="toc-text">短程调度（Short-term Scheduler,又称进程调度、CPU调度或低级调度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#长程调度（Long-term-Scheduler-又称作业调度或高级调度"><span class="toc-number">3.5.2.</span> <span class="toc-text">长程调度（Long-term Scheduler,又称作业调度或高级调度)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中程调度（Medium-term-Scheduler-又称中级调度"><span class="toc-number">3.5.3.</span> <span class="toc-text">中程调度（Medium-term Scheduler,又称中级调度)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#上下文-进程的运行环境"><span class="toc-number">3.6.</span> <span class="toc-text">上下文 - 进程的运行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#上下文切换（Context-Switch"><span class="toc-number">3.6.1.</span> <span class="toc-text">上下文切换（Context Switch)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程通讯-Inter-process-Communication"><span class="toc-number">3.7.</span> <span class="toc-text">进程通讯(Inter-process Communication)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分类"><span class="toc-number">3.7.1.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多道程序设计-Multi-programming"><span class="toc-number">3.8.</span> <span class="toc-text">多道程序设计(Multi-programming)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">3.8.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序的一些特性"><span class="toc-number">3.9.</span> <span class="toc-text">程序的一些特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生产者消费者问题"><span class="toc-number">3.10.</span> <span class="toc-text">生产者消费者问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程（Thread）"><span class="toc-number">4.</span> <span class="toc-text">线程（Thread）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念-1"><span class="toc-number">4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分类-1"><span class="toc-number">4.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关名词"><span class="toc-number">4.3.</span> <span class="toc-text">相关名词</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CPU调度（CPU-Scheduling）"><span class="toc-number">5.</span> <span class="toc-text">CPU调度（CPU Scheduling）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#批处理系统中采用的调度算法"><span class="toc-number">5.1.</span> <span class="toc-text">批处理系统中采用的调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#交互系统中采用的调度算法"><span class="toc-number">5.2.</span> <span class="toc-text">交互系统中采用的调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各种调度算法比较"><span class="toc-number">5.3.</span> <span class="toc-text">各种调度算法比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Process-Synchronization进程同步"><span class="toc-number">6.</span> <span class="toc-text">Process Synchronization进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#方式"><span class="toc-number">6.1.</span> <span class="toc-text">方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore-信号量"><span class="toc-number">6.2.</span> <span class="toc-text">Semaphore 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构"><span class="toc-number">6.2.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决busy-waiting问题-gt-互斥锁效果"><span class="toc-number">6.2.2.</span> <span class="toc-text">解决busy waiting问题 &gt; 互斥锁效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spinLock自旋锁"><span class="toc-number">6.3.</span> <span class="toc-text">spinLock自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#互斥锁"><span class="toc-number">6.4.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Monitors管程-监视器-秘书进程"><span class="toc-number">6.5.</span> <span class="toc-text">Monitors管程/监视器/秘书进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#语法"><span class="toc-number">6.5.1.</span> <span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Turnstile十字转门"><span class="toc-number">6.6.</span> <span class="toc-text">Turnstile十字转门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transaction事务"><span class="toc-number">6.7.</span> <span class="toc-text">transaction事务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#deadlock-死锁"><span class="toc-number">7.</span> <span class="toc-text">deadlock 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁防止（Deadlock-Prevention）"><span class="toc-number">7.1.</span> <span class="toc-text">死锁防止（Deadlock Prevention）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁避免-DeadlockAvoidance"><span class="toc-number">7.2.</span> <span class="toc-text">死锁避免(DeadlockAvoidance)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安全序列-Security-Sequence"><span class="toc-number">7.3.</span> <span class="toc-text">安全序列(Security Sequence)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁避免算法"><span class="toc-number">7.4.</span> <span class="toc-text">死锁避免算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#资源分配图算法"><span class="toc-number">7.4.1.</span> <span class="toc-text">资源分配图算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#银行家算法"><span class="toc-number">7.4.2.</span> <span class="toc-text">银行家算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁检测"><span class="toc-number">7.5.</span> <span class="toc-text">死锁检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁恢复"><span class="toc-number">7.6.</span> <span class="toc-text">死锁恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#应用终止"><span class="toc-number">7.6.1.</span> <span class="toc-text">应用终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源抢占"><span class="toc-number">7.6.2.</span> <span class="toc-text">资源抢占</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存管理"><span class="toc-number">8.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#空间分片"><span class="toc-number">8.1.</span> <span class="toc-text">空间分片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几个概念"><span class="toc-number">8.2.</span> <span class="toc-text">几个概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主存管理功能"><span class="toc-number">8.3.</span> <span class="toc-text">主存管理功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#地址映射-by-内存管理单元MMU"><span class="toc-number">8.4.</span> <span class="toc-text">地址映射 by 内存管理单元MMU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#地址映射的时机和类别"><span class="toc-number">8.4.1.</span> <span class="toc-text">地址映射的时机和类别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主存分配"><span class="toc-number">8.5.</span> <span class="toc-text">主存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主存分配方式"><span class="toc-number">8.6.</span> <span class="toc-text">主存分配方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主存扩充"><span class="toc-number">8.7.</span> <span class="toc-text">主存扩充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟存储器的核心"><span class="toc-number">8.8.</span> <span class="toc-text">虚拟存储器的核心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现虚拟存储器的物质基础"><span class="toc-number">8.9.</span> <span class="toc-text">实现虚拟存储器的物质基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储保护-1"><span class="toc-number">8.10.</span> <span class="toc-text">存储保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分区分配算法"><span class="toc-number">8.11.</span> <span class="toc-text">内存分区分配算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#碎片问题及碎片整理"><span class="toc-number">8.12.</span> <span class="toc-text">碎片问题及碎片整理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分区分配常用的数据结构"><span class="toc-number">8.13.</span> <span class="toc-text">内存分区分配常用的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#页式存储管理"><span class="toc-number">8.14.</span> <span class="toc-text">页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#页面"><span class="toc-number">8.14.1.</span> <span class="toc-text">页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主存块"><span class="toc-number">8.14.2.</span> <span class="toc-text">主存块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页表"><span class="toc-number">8.14.3.</span> <span class="toc-text">页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念-2"><span class="toc-number">8.14.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#页表的组成"><span class="toc-number">8.14.3.2.</span> <span class="toc-text">页表的组成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用联想存储器加快页表查询速度"><span class="toc-number">8.14.4.</span> <span class="toc-text">使用联想存储器加快页表查询速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺页处理"><span class="toc-number">8.14.5.</span> <span class="toc-text">缺页处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抖动-颠簸"><span class="toc-number">8.14.6.</span> <span class="toc-text">抖动/颠簸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存淘汰算法"><span class="toc-number">8.14.7.</span> <span class="toc-text">内存淘汰算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段式地址空间"><span class="toc-number">8.15.</span> <span class="toc-text">段式地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念-3"><span class="toc-number">8.15.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作业地址空间"><span class="toc-number">8.15.2.</span> <span class="toc-text">作业地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#段式地址结构"><span class="toc-number">8.15.3.</span> <span class="toc-text">段式地址结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#段式地址步骤"><span class="toc-number">8.15.3.1.</span> <span class="toc-text">段式地址步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#页式系统与段式系统的区别"><span class="toc-number">8.16.</span> <span class="toc-text">页式系统与段式系统的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用户地址空间的区别"><span class="toc-number">8.16.1.</span> <span class="toc-text">用户地址空间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分段和页面的区别"><span class="toc-number">8.16.2.</span> <span class="toc-text">分段和页面的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段页式系统"><span class="toc-number">8.17.</span> <span class="toc-text">段页式系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储管理技术"><span class="toc-number">8.18.</span> <span class="toc-text">存储管理技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件管理"><span class="toc-number">9.</span> <span class="toc-text">文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#文件系统"><span class="toc-number">9.1.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件"><span class="toc-number">9.2.</span> <span class="toc-text">文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念-4"><span class="toc-number">9.2.1.</span> <span class="toc-text">概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性"><span class="toc-number">9.3.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作"><span class="toc-number">9.4.</span> <span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件系统实现"><span class="toc-number">10.</span> <span class="toc-text">文件系统实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分配方案"><span class="toc-number">10.1.</span> <span class="toc-text">分配方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-O输入系统"><span class="toc-number">11.</span> <span class="toc-text">I/O输入系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#安全"><span class="toc-number">12.</span> <span class="toc-text">安全</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 20
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/19</span><a class="archive-post-title" href= "/2020/11/19/网游加速器原理/" >网游加速器原理、技术与实现</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/30</span><a class="archive-post-title" href= "/2017/11/30/关于死锁的几个经典问题/" >关于死锁的几个经典问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/03</span><a class="archive-post-title" href= "/2017/09/03/howRuntimeWorks/" >彻底理解Runtime</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/29</span><a class="archive-post-title" href= "/2017/06/29/Runloop/" >Runloop</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/08</span><a class="archive-post-title" href= "/2017/05/08/Computer-Networking-A-Top-Down-Approach-NOTES/" >计算机网络 自顶向下方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span><a class="archive-post-title" href= "/2017/04/19/GCD-queue-and-sync-async/" >GCD队列与同步异步的组合</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span><a class="archive-post-title" href= "/2017/01/02/iOS-Core-Animation/" >iOS Core Animation</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2016 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/20</span><a class="archive-post-title" href= "/2016/11/20/Design-Pattern-Odyssey/" >大话设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/30</span><a class="archive-post-title" href= "/2016/09/30/Algorithms/" >Algorithms</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/30</span><a class="archive-post-title" href= "/2016/09/30/操作系统原理/" >操作系统原理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span><a class="archive-post-title" href= "/2016/09/08/Effective-Objective-C-2-0/" >Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/03</span><a class="archive-post-title" href= "/2016/08/03/SwiftGrammar/" >SwiftGrammar</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/22</span><a class="archive-post-title" href= "/2016/05/22/Computer-Systems-A-Programmer-s-Perspective/" >深入理解计算机系统</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/22</span><a class="archive-post-title" href= "/2016/04/22/Pro-multithreading-and-memory-management-for-iOS-and-OS-X/" >Object-C 高级编程 iOS和OS X多线程和内存管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/12</span><a class="archive-post-title" href= "/2016/03/12/git/" >Git</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2015 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/25</span><a class="archive-post-title" href= "/2015/06/25/special-kind-of-pointer/" >几种特殊指针的含义区别</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/08</span><a class="archive-post-title" href= "/2015/05/08/InstallShadowsocks/" >部署Shadowsocks</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/30</span><a class="archive-post-title" href= "/2015/03/30/SQL查询实现方式/" >SQL查询实现方式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/11</span><a class="archive-post-title" href= "/2015/03/11/SQL/" >SQL</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href= "/2015/01/01/How-does-the-program-run/" >程序是怎样跑起来的</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="设计模式"><span class="iconfont-archer">&#xe606;</span>设计模式</span>
    
        <span class="sidebar-tag-name" data-tags="async"><span class="iconfont-archer">&#xe606;</span>async</span>
    
        <span class="sidebar-tag-name" data-tags="sync"><span class="iconfont-archer">&#xe606;</span>sync</span>
    
        <span class="sidebar-tag-name" data-tags="queue"><span class="iconfont-archer">&#xe606;</span>queue</span>
    
        <span class="sidebar-tag-name" data-tags="app"><span class="iconfont-archer">&#xe606;</span>app</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="内存管理"><span class="iconfont-archer">&#xe606;</span>内存管理</span>
    
        <span class="sidebar-tag-name" data-tags="SQL"><span class="iconfont-archer">&#xe606;</span>SQL</span>
    
        <span class="sidebar-tag-name" data-tags="pointer"><span class="iconfont-archer">&#xe606;</span>pointer</span>
    
        <span class="sidebar-tag-name" data-tags="id"><span class="iconfont-archer">&#xe606;</span>id</span>
    
        <span class="sidebar-tag-name" data-tags="NSObject"><span class="iconfont-archer">&#xe606;</span>NSObject</span>
    
        <span class="sidebar-tag-name" data-tags="id<NSObject>"><span class="iconfont-archer">&#xe606;</span>id<NSObject></span>
    
        <span class="sidebar-tag-name" data-tags="void *"><span class="iconfont-archer">&#xe606;</span>void *</span>
    
        <span class="sidebar-tag-name" data-tags="nil"><span class="iconfont-archer">&#xe606;</span>nil</span>
    
        <span class="sidebar-tag-name" data-tags="Nil"><span class="iconfont-archer">&#xe606;</span>Nil</span>
    
        <span class="sidebar-tag-name" data-tags="NSNull"><span class="iconfont-archer">&#xe606;</span>NSNull</span>
    
        <span class="sidebar-tag-name" data-tags="deadLock"><span class="iconfont-archer">&#xe606;</span>deadLock</span>
    
        <span class="sidebar-tag-name" data-tags="计算机系统"><span class="iconfont-archer">&#xe606;</span>计算机系统</span>
    
        <span class="sidebar-tag-name" data-tags="消息"><span class="iconfont-archer">&#xe606;</span>消息</span>
    
        <span class="sidebar-tag-name" data-tags="load"><span class="iconfont-archer">&#xe606;</span>load</span>
    
        <span class="sidebar-tag-name" data-tags="Shadowsocks"><span class="iconfont-archer">&#xe606;</span>Shadowsocks</span>
    
        <span class="sidebar-tag-name" data-tags="CentOS"><span class="iconfont-archer">&#xe606;</span>CentOS</span>
    
        <span class="sidebar-tag-name" data-tags="AWS root"><span class="iconfont-archer">&#xe606;</span>AWS root</span>
    
        <span class="sidebar-tag-name" data-tags="Swift"><span class="iconfont-archer">&#xe606;</span>Swift</span>
    
        <span class="sidebar-tag-name" data-tags="Git"><span class="iconfont-archer">&#xe606;</span>Git</span>
    
        <span class="sidebar-tag-name" data-tags="proxy"><span class="iconfont-archer">&#xe606;</span>proxy</span>
    
        <span class="sidebar-tag-name" data-tags="加速器"><span class="iconfont-archer">&#xe606;</span>加速器</span>
    
        <span class="sidebar-tag-name" data-tags="OS"><span class="iconfont-archer">&#xe606;</span>OS</span>
    
        <span class="sidebar-tag-name" data-tags="runtime"><span class="iconfont-archer">&#xe606;</span>runtime</span>
    
        <span class="sidebar-tag-name" data-tags="计算机网络"><span class="iconfont-archer">&#xe606;</span>计算机网络</span>
    
        <span class="sidebar-tag-name" data-tags="Runloop"><span class="iconfont-archer">&#xe606;</span>Runloop</span>
    
        <span class="sidebar-tag-name" data-tags="Core Animation"><span class="iconfont-archer">&#xe606;</span>Core Animation</span>
    
        <span class="sidebar-tag-name" data-tags="Algorithms"><span class="iconfont-archer">&#xe606;</span>Algorithms</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Hayato"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


